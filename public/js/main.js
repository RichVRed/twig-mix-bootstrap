/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	if (typeof execScript !== "undefined")
		execScript(src);
	else
		eval.call(null, src);
}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_script_loader_jquery__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_script_loader_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_script_loader_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_script_loader_what_input__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_script_loader_what_input___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_script_loader_what_input__);


__webpack_require__(3);

$(document).ready(function () {
  $(document).foundation();
});

/***/ },
/* 2 */
/***/ function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ },
/* 3 */
/***/ function(module, exports) {

function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}!function(t){"use strict";function e(t){if(void 0===Function.prototype.name){var e=/function\s([^(]{1,})\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():""}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name}function i(t){return"true"===t||"false"!==t&&(isNaN(1*t)?t:parseFloat(t))}function n(t){return t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}var s="6.3.0",o={version:s,_plugins:{},_uuids:[],rtl:function(){return"rtl"===t("html").attr("dir")},plugin:function(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t},registerPlugin:function(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr("data-"+s)||t.$element.attr("data-"+s,t.uuid),t.$element.data("zfPlugin")||t.$element.data("zfPlugin",t),t.$element.trigger("init.zf."+s),this._uuids.push(t.uuid)},unregisterPlugin:function(t){var i=n(e(t.$element.data("zfPlugin").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr("data-"+i).removeData("zfPlugin").trigger("destroyed.zf."+i);for(var s in t)t[s]=null},reInit:function(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data("zfPlugin")._init()});else{var s=typeof e,o=this,a={object:function(e){e.forEach(function(e){e=n(e),t("[data-"+e+"]").foundation("_init")})},string:function(){e=n(e),t("[data-"+e+"]").foundation("_init")},undefined:function(){this.object(Object.keys(o._plugins))}};a[s](e)}}catch(t){console.error(t)}finally{return e}},GetYoDigits:function(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?"-"+e:"")},reflow:function(e,n){"undefined"==typeof n?n=Object.keys(this._plugins):"string"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find("[data-"+o+"]").addBack("[data-"+o+"]");r.each(function(){var e=t(this),n={};if(e.data("zfPlugin"))return void console.warn("Tried to initialize "+o+" on an element that already has a Foundation plugin.");if(e.attr("data-options")){e.attr("data-options").split(";").forEach(function(t,e){var s=t.split(":").map(function(t){return t.trim()});s[0]&&(n[s[0]]=i(s[1]))})}try{e.data("zfPlugin",new a(t(this),n))}catch(t){console.error(t)}finally{return}})})},getFnName:e,transitionend:function(t){var e,i={transition:"transitionend",WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"otransitionend"},n=document.createElement("div");for(var s in i)"undefined"!=typeof n.style[s]&&(e=i[s]);return e?e:(e=setTimeout(function(){t.triggerHandler("transitionend",[t])},1),"transitionend")}};o.util={throttle:function(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null},e))}}};var a=function(i){var n=typeof i,s=t("meta.foundation-mq"),a=t(".no-js");if(s.length||t('<meta class="foundation-mq">').appendTo(document.head),a.length&&a.removeClass("no-js"),"undefined"===n)o.MediaQuery._init(),o.reflow(this);else{if("string"!==n)throw new TypeError("We're sorry, "+n+" is not a valid parameter. You must use a string representing the method you wish to invoke.");var r=Array.prototype.slice.call(arguments,1),l=this.data("zfPlugin");if(void 0===l||void 0===l[i])throw new ReferenceError("We're sorry, '"+i+"' is not an available method for "+(l?e(l):"this element")+".");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data("zfPlugin"),r)})}return this};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return(new Date).getTime()});for(var t=["webkit","moz"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+"RequestAnimationFrame"],window.cancelAnimationFrame=window[i+"CancelAnimationFrame"]||window[i+"CancelRequestAnimationFrame"]}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i)},i-e)},window.cancelAnimationFrame=clearTimeout}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function(){return Date.now()-this.start}})}(),Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),i=this,n=function(){},s=function(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)))};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n,s})}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width+d.offset.left}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:h.indexOf(!1)===-1}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}}}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case"top":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case"left":return{left:l.offset.left-(r.width+o),top:l.offset.top};case"right":return{left:l.offset.left+l.width+o,top:l.offset.top};case"center top":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case"center bottom":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case"center left":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case"center right":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case"center":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case"reveal":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case"reveal full":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};case"left bottom":return{left:l.offset.left,top:l.offset.top+l.height+s};case"right bottom":return{left:l.offset.left+l.width+o-r.width,top:l.offset.top+l.height+s};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left+o,top:l.offset.top+l.height+s}}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n}}(jQuery),!function(t){function e(t){var e={};for(var i in t)e[t[i]]=t[i];return e}var i={9:"TAB",13:"ENTER",27:"ESCAPE",32:"SPACE",37:"ARROW_LEFT",38:"ARROW_UP",39:"ARROW_RIGHT",40:"ARROW_DOWN"},n={},s={keys:e(i),parseKey:function(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return e=e.replace(/\W+/,""),t.shiftKey&&(e="SHIFT_"+e),t.ctrlKey&&(e="CTRL_"+e),t.altKey&&(e="ALT_"+e),e=e.replace(/_$/,"")},handleKey:function(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);if(!l)return console.warn("Component not defined!");if(o="undefined"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],r&&"function"==typeof r){var d=r.apply();(s.handled||"function"==typeof s.handled)&&s.handled(d)}else(s.unhandled||"function"==typeof s.unhandled)&&s.unhandled()},findFocusable:function(e){return!!e&&e.find("a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]").filter(function(){return!(!t(this).is(":visible")||t(this).attr("tabindex")<0)})},register:function(t,e){n[t]=e},trapFocus:function(t){var e=Foundation.Keyboard.findFocusable(t),i=e.eq(0),n=e.eq(-1);t.on("keydown.zf.trapfocus",function(t){t.target===n[0]&&"TAB"===Foundation.Keyboard.parseKey(t)?(t.preventDefault(),i.focus()):t.target===i[0]&&"SHIFT_TAB"===Foundation.Keyboard.parseKey(t)&&(t.preventDefault(),n.focus())})},releaseFocus:function(t){t.off("keydown.zf.trapfocus")}};Foundation.Keyboard=s}(jQuery),!function(t){function e(t){var e={};return"string"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split("&").reduce(function(t,e){var i=e.replace(/\+/g," ").split("="),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t},{}):e}var i={queries:[],current:"",_init:function(){var i,n=this,s=t(".foundation-mq").css("font-family");i=e(s);for(var o in i)i.hasOwnProperty(o)&&n.queries.push({name:o,value:"only screen and (min-width: "+i[o]+")"});this.current=this._getCurrentSize(),this._watcher()},atLeast:function(t){var e=this.get(t);return!!e&&window.matchMedia(e).matches},is:function(t){return t=t.trim().split(" "),t.length>1&&"only"===t[1]?t[0]===this._getCurrentSize():this.atLeast(t[0])},get:function(t){for(var e in this.queries)if(this.queries.hasOwnProperty(e)){var i=this.queries[e];if(t===i.name)return i.value}return null},_getCurrentSize:function(){for(var t,e=0;e<this.queries.length;e++){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i)}return"object"==typeof t?t.name:t},_watcher:function(){var e=this;t(window).on("resize.zf.mediaquery",function(){var i=e._getCurrentSize(),n=e.current;i!==n&&(e.current=i,t(window).trigger("changed.zf.mediaquery",[i,n]))})}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){"use strict";var t=window.styleMedia||window.media;if(!t){var e=document.createElement("style"),i=document.getElementsByTagName("script")[0],n=null;e.type="text/css",e.id="matchmediajs-test",i&&i.parentNode&&i.parentNode.insertBefore(e,i),n="getComputedStyle"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function(t){var i="@media "+t+"{ #matchmediajs-test { width: 1px; } }";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,"1px"===n.width}}}return function(e){return{matches:t.matchMedium(e||"all"),media:e||"all"}}}()),Foundation.MediaQuery=i}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=r),o=r-a,i.apply(e),o<t?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger("finished.zf.animate",[e]).triggerHandler("finished.zf.animate",[e]))}var s,o,a=null;return 0===t?(i.apply(e),void e.trigger("finished.zf.animate",[e]).triggerHandler("finished.zf.animate",[e])):void(s=window.requestAnimationFrame(n))}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i)}function l(){i[0].style.transitionDuration=0,i.removeClass(u+" "+d+" "+o)}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css("transition","none"),requestAnimationFrame(function(){i.addClass(u),e&&i.show()}),requestAnimationFrame(function(){i[0].offsetWidth,i.css("transition","").addClass(d)}),i.one(Foundation.transitionend(i),r)}}var n=["mui-enter","mui-leave"],s=["mui-enter-active","mui-leave-active"],o={animateIn:function(t,e,n){i(!0,t,e,n)},animateOut:function(t,e,n){i(!1,t,e,n)}};Foundation.Move=e,Foundation.Motion=o}(jQuery),!function(t){var e={Feather:function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"zf";e.attr("role","menubar");var n=e.find("li").attr({role:"menuitem"}),s="is-"+i+"-submenu",o=s+"-item",a="is-"+i+"-submenu-parent";n.each(function(){var e=t(this),n=e.children("ul");n.length&&(e.addClass(a).attr({"aria-haspopup":!0,"aria-label":e.children("a:first").text()}),"drilldown"===i&&e.attr({"aria-expanded":!1}),n.addClass("submenu "+s).attr({"data-submenu":"",role:"menu"}),"drilldown"===i&&n.attr({"aria-hidden":!0})),e.parent("[data-submenu]").length&&e.addClass("is-submenu-item "+o)})},Burn:function(t,e){var i="is-"+e+"-submenu",n=i+"-item",s="is-"+e+"-submenu-parent";t.find(">li, .menu, .menu > li").removeClass(i+" "+n+" "+s+" is-submenu-item submenu is-active").removeAttr("data-submenu").css("display","")}};Foundation.Nest=e}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||"timer",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start()},this.start=function(){this.isPaused=!1,clearTimeout(s),l=l<=0?a:l,t.data("paused",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i&&"function"==typeof i&&i()},l),t.trigger("timerstart.zf."+r)},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data("paused",!0);var e=Date.now();l-=e-n,t.trigger("timerpaused.zf."+r)}}function i(e,i){function n(){s--,0===s&&i()}var s=e.length;0===s&&i(),e.each(function(){if(this.complete||4===this.readyState||"complete"===this.readyState)n();else{var e=t(this).attr("src");t(this).attr("src",e+"?"+(new Date).getTime()),t(this).one("load",function(){n()})}})}Foundation.Timer=e,Foundation.onImagesLoaded=i}(jQuery),function(t){function e(){this.removeEventListener("touchmove",i),this.removeEventListener("touchend",e),u=!1}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=(new Date).getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?"left":"right"),n&&(i.preventDefault(),e.call(this),t(this).trigger("swipe",n).trigger("swipe"+n))}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=(new Date).getTime(),this.addEventListener("touchmove",i,!1),this.addEventListener("touchend",e,!1))}function s(){this.addEventListener&&this.addEventListener("touchstart",n,!1)}t.spotSwipe={version:"1.0.0",enabled:"ontouchstart"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each(["left","up","down","right"],function(){t.event.special["swipe"+this]={setup:function(){t(this).on("swipe",t.noop)}}})}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind("touchstart touchmove touchend touchcancel",function(){e(event)})});var e=function(t){var e,i=t.changedTouches,n=i[0],s={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup"},o=s[t.type];"MouseEvent"in window&&"function"==typeof window.MouseEvent?e=new window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent("MouseEvent"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e)}}}(jQuery),!function(t){function e(){a(),n(),s(),o(),i()}function i(e){var i=t("[data-yeti-box]"),n=["dropdown","tooltip","reveal"];if(e&&("string"==typeof e?n.push(e):"object"==typeof e&&"string"==typeof e[0]?n.concat(e):console.error("Plugin names must be strings")),i.length){var s=n.map(function(t){return"closeme.zf."+t}).join(" ");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(".")[0],s=t("[data-"+n+"]").not('[data-yeti-box="'+i+'"]');s.each(function(){var e=t(this);e.triggerHandler("close.zf.trigger",[e])})})}}function n(e){var i=void 0,n=t("[data-resize]");n.length&&t(window).off("resize.zf.trigger").on("resize.zf.trigger",function(s){i&&clearTimeout(i),i=setTimeout(function(){r||n.each(function(){t(this).triggerHandler("resizeme.zf.trigger")}),n.attr("data-events","resize")},e||10)})}function s(e){var i=void 0,n=t("[data-scroll]");n.length&&t(window).off("scroll.zf.trigger").on("scroll.zf.trigger",function(s){i&&clearTimeout(i),i=setTimeout(function(){r||n.each(function(){t(this).triggerHandler("scrollme.zf.trigger")}),n.attr("data-events","scroll")},e||10)})}function o(e){var i=t("[data-mutate]");i.length&&r&&i.each(function(){t(this).triggerHandler("mutateme.zf.trigger")})}function a(){if(!r)return!1;var e=document.querySelectorAll("[data-resize], [data-scroll], [data-mutate]"),i=function(e){var i=t(e[0].target);switch(e[0].type){case"attributes":"scroll"===i.attr("data-events")&&"data-events"===e[0].attributeName&&i.triggerHandler("scrollme.zf.trigger",[i,window.pageYOffset]),"resize"===i.attr("data-events")&&"data-events"===e[0].attributeName&&i.triggerHandler("resizeme.zf.trigger",[i]),"style"===e[0].attributeName&&(i.closest("[data-mutate]").attr("data-events","mutate"),i.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger",[i.closest("[data-mutate]")]));break;case"childList":i.closest("[data-mutate]").attr("data-events","mutate"),i.closest("[data-mutate]").triggerHandler("mutateme.zf.trigger",[i.closest("[data-mutate]")]);break;default:return!1}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new r(i);s.observe(e[n],{attributes:!0,childList:!0,characterData:!1,subtree:!0,attributeFilter:["data-events","style"]})}}var r=function(){for(var t=["WebKit","Moz","O","Ms",""],e=0;e<t.length;e++)if(t[e]+"MutationObserver"in window)return window[t[e]+"MutationObserver"];return!1}(),l=function(e,i){e.data(i).split(" ").forEach(function(n){t("#"+n)["close"===i?"trigger":"triggerHandler"](i+".zf.trigger",[e])})};t(document).on("click.zf.trigger","[data-open]",function(){l(t(this),"open")}),t(document).on("click.zf.trigger","[data-close]",function(){var e=t(this).data("close");e?l(t(this),"close"):t(this).trigger("close.zf.trigger")}),t(document).on("click.zf.trigger","[data-toggle]",function(){var e=t(this).data("toggle");e?l(t(this),"toggle"):t(this).trigger("toggle.zf.trigger")}),t(document).on("close.zf.trigger","[data-closable]",function(e){e.stopPropagation();var i=t(this).data("closable");""!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger("closed.zf")}):t(this).fadeOut().trigger("closed.zf")}),t(document).on("focus.zf.trigger blur.zf.trigger","[data-toggle-focus]",function(){var e=t(this).data("toggle-focus");t("#"+e).triggerHandler("toggle.zf.trigger",[t(this)])}),t(window).on("load",function(){e()}),Foundation.IHearYou=e}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Abide")}return _createClass(e,[{key:"_init",value:function(){this.$inputs=this.$element.find("input, textarea, select"),this._events()}},{key:"_events",value:function(){var e=this;this.$element.off(".abide").on("reset.zf.abide",function(){e.resetForm()}).on("submit.zf.abide",function(){return e.validateForm()}),"fieldChange"===this.options.validateOn&&this.$inputs.off("change.zf.abide").on("change.zf.abide",function(i){e.validateInput(t(i.target))}),this.options.liveValidate&&this.$inputs.off("input.zf.abide").on("input.zf.abide",function(i){e.validateInput(t(i.target))}),this.options.validateOnBlur&&this.$inputs.off("blur.zf.abide").on("blur.zf.abide",function(i){e.validateInput(t(i.target))})}},{key:"_reflow",value:function(){this._init()}},{key:"requiredCheck",value:function(t){if(!t.attr("required"))return!0;var e=!0;switch(t[0].type){case"checkbox":e=t[0].checked;break;case"select":case"select-one":case"select-multiple":var i=t.find("option:selected");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1)}return e}},{key:"findFormError",value:function(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e}},{key:"findLabel",value:function(t){var e=t[0].id,i=this.$element.find('label[for="'+e+'"]');return i.length?i:t.closest("label")}},{key:"findRadioLabels",value:function(e){var i=this,n=e.map(function(e,n){var s=n.id,o=i.$element.find('label[for="'+s+'"]');return o.length||(o=t(n).closest("label")),o[0]});return t(n)}},{key:"addErrorClasses",value:function(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr("data-invalid","")}},{key:"removeRadioErrorClasses",value:function(t){var e=this.$element.find(':radio[name="'+t+'"]'),i=this.findRadioLabels(e),n=this.findFormError(e);i.length&&i.removeClass(this.options.labelErrorClass),n.length&&n.removeClass(this.options.formErrorClass),e.removeClass(this.options.inputErrorClass).removeAttr("data-invalid")}},{key:"removeErrorClasses",value:function(t){if("radio"==t[0].type)return this.removeRadioErrorClasses(t.attr("name"));var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr("data-invalid")}},{key:"validateInput",value:function(e){var i=this,n=this.requiredCheck(e),s=!1,o=!0,a=e.attr("data-validator"),r=!0;if(e.is("[data-abide-ignore]")||e.is('[type="hidden"]'))return!0;switch(e[0].type){case"radio":s=this.validateRadio(e.attr("name"));break;case"checkbox":s=n;break;case"select":case"select-one":case"select-multiple":s=n;break;default:s=this.validateText(e)}a&&(o=this.matchValidation(e,a,e.attr("required"))),e.attr("data-equalto")&&(r=this.options.validators.equalTo(e));var l=[n,s,o,r].indexOf(!1)===-1,u=(l?"valid":"invalid")+".zf.abide";if(l){var d=this.$element.find('[data-equalto="'+e.attr("id")+'"]');d.length&&!function(){var e=i;d.each(function(){t(this).val()&&e.validateInput(t(this))})}()}return this[l?"removeErrorClasses":"addErrorClasses"](e),e.trigger(u,[e]),l}},{key:"validateForm",value:function(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)))});var n=e.indexOf(!1)===-1;return this.$element.find("[data-abide-error]").css("display",n?"none":"block"),this.$element.trigger((n?"formvalid":"forminvalid")+".zf.abide",[this.$element]),n}},{key:"validateText",value:function(t,e){e=e||t.attr("pattern")||t.attr("type");var i=t.val(),n=!1;return i.length?n=this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e===t.attr("type")||new RegExp(e).test(i):t.prop("required")||(n=!0),n}},{key:"validateRadio",value:function(e){var i=this.$element.find(':radio[name="'+e+'"]'),n=!1,s=!1;return i.each(function(e,i){t(i).attr("required")&&(s=!0)}),s||(n=!0),n||i.each(function(e,i){t(i).prop("checked")&&(n=!0)}),n}},{key:"matchValidation",value:function(t,e,i){var n=this;i=!!i;var s=e.split(" ").map(function(e){return n.options.validators[e](t,i,t.parent())});return s.indexOf(!1)===-1}},{key:"resetForm",value:function(){var e=this.$element,i=this.options;t("."+i.labelErrorClass,e).not("small").removeClass(i.labelErrorClass),t("."+i.inputErrorClass,e).not("small").removeClass(i.inputErrorClass),t(i.formErrorSelector+"."+i.formErrorClass).removeClass(i.formErrorClass),e.find("[data-abide-error]").css("display","none"),t(":input",e).not(":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]").val("").removeAttr("data-invalid"),t(":input:radio",e).not("[data-abide-ignore]").prop("checked",!1).removeAttr("data-invalid"),t(":input:checkbox",e).not("[data-abide-ignore]").prop("checked",!1).removeAttr("data-invalid"),e.trigger("formreset.zf.abide",[e])}},{key:"destroy",value:function(){var e=this;this.$element.off(".abide").find("[data-abide-error]").css("display","none"),this.$inputs.off(".abide").each(function(){e.removeErrorClasses(t(this))}),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={validateOn:"fieldChange",labelErrorClass:"is-invalid-label",inputErrorClass:"is-invalid-input",formErrorSelector:".form-error",formErrorClass:"is-visible",liveValidate:!1,validateOnBlur:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\d+$/,number:/^[-+]?\d*(?:[\.\,]\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function(e,i,n){return t("#"+e.attr("data-equalto")).val()===e.val()}}},Foundation.plugin(e,"Abide")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Accordion"),Foundation.Keyboard.register("Accordion",{ENTER:"toggle",SPACE:"toggle",ARROW_DOWN:"next",ARROW_UP:"previous"})}return _createClass(e,[{key:"_init",value:function(){this.$element.attr("role","tablist"),this.$tabs=this.$element.children("[data-accordion-item]"),this.$tabs.each(function(e,i){var n=t(i),s=n.children("[data-tab-content]"),o=s[0].id||Foundation.GetYoDigits(6,"accordion"),a=i.id||o+"-label";n.find("a:first").attr({"aria-controls":o,role:"tab",id:a,"aria-expanded":!1,"aria-selected":!1}),s.attr({role:"tabpanel","aria-labelledby":a,"aria-hidden":!0,id:o})});var e=this.$element.find(".is-active").children("[data-tab-content]");e.length&&this.down(e,!0),this._events()}},{key:"_events",value:function(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children("[data-tab-content]");n.length&&i.children("a").off("click.zf.accordion keydown.zf.accordion").on("click.zf.accordion",function(t){t.preventDefault(),e.toggle(n)}).on("keydown.zf.accordion",function(t){Foundation.Keyboard.handleKey(t,"Accordion",{toggle:function(){e.toggle(n)},next:function(){var t=i.next().find("a").focus();e.options.multiExpand||t.trigger("click.zf.accordion")},previous:function(){var t=i.prev().find("a").focus();e.options.multiExpand||t.trigger("click.zf.accordion")},handled:function(){t.preventDefault(),t.stopPropagation()}})})})}},{key:"toggle",value:function(t){t.parent().hasClass("is-active")?this.up(t):this.down(t)}},{key:"down",value:function(e,i){var n=this;if(e.attr("aria-hidden",!1).parent("[data-tab-content]").addBack().parent().addClass("is-active"),!this.options.multiExpand&&!i){var s=this.$element.children(".is-active").children("[data-tab-content]");s.length&&this.up(s.not(e))}e.slideDown(this.options.slideSpeed,function(){n.$element.trigger("down.zf.accordion",[e])}),t("#"+e.attr("aria-labelledby")).attr({"aria-expanded":!0,"aria-selected":!0})}},{key:"up",value:function(e){var i=e.parent().siblings(),n=this;(this.options.allowAllClosed||i.hasClass("is-active"))&&e.parent().hasClass("is-active")&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger("up.zf.accordion",[e])}),e.attr("aria-hidden",!0).parent().removeClass("is-active"),t("#"+e.attr("aria-labelledby")).attr({"aria-expanded":!1,"aria-selected":!1}))}},{key:"destroy",value:function(){this.$element.find("[data-tab-content]").stop(!0).slideUp(0).css("display",""),this.$element.find("a").off(".zf.accordion"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,"Accordion")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){
var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,"accordion"),this._init(),Foundation.registerPlugin(this,"AccordionMenu"),Foundation.Keyboard.register("AccordionMenu",{ENTER:"toggle",SPACE:"toggle",ARROW_RIGHT:"open",ARROW_UP:"up",ARROW_DOWN:"down",ARROW_LEFT:"close",ESCAPE:"closeAll"})}return _createClass(e,[{key:"_init",value:function(){this.$element.find("[data-submenu]").not(".is-active").slideUp(0),this.$element.attr({role:"menu","aria-multiselectable":this.options.multiOpen}),this.$menuLinks=this.$element.find(".is-accordion-submenu-parent"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,"acc-menu-link"),i=t(this),n=i.children("[data-submenu]"),s=n[0].id||Foundation.GetYoDigits(6,"acc-menu"),o=n.hasClass("is-active");i.attr({"aria-controls":s,"aria-expanded":o,role:"menuitem",id:e}),n.attr({"aria-labelledby":e,"aria-hidden":!o,role:"menu",id:s})});var e=this.$element.find(".is-active");if(e.length){var i=this;e.each(function(){i.down(t(this))})}this._events()}},{key:"_events",value:function(){var e=this;this.$element.find("li").each(function(){var i=t(this).children("[data-submenu]");i.length&&t(this).children("a").off("click.zf.accordionMenu").on("click.zf.accordionMenu",function(t){t.preventDefault(),e.toggle(i)})}).on("keydown.zf.accordionmenu",function(i){var n,s,o=t(this),a=o.parent("ul").children("li"),r=o.children("[data-submenu]");a.each(function(e){if(t(this).is(o))return n=a.eq(Math.max(0,e-1)).find("a").first(),s=a.eq(Math.min(e+1,a.length-1)).find("a").first(),t(this).children("[data-submenu]:visible").length&&(s=o.find("li:first-child").find("a").first()),t(this).is(":first-child")?n=o.parents("li").first().find("a").first():n.parents("li").first().children("[data-submenu]:visible").length&&(n=n.parents("li").find("li:last-child").find("a").first()),void(t(this).is(":last-child")&&(s=o.parents("li").first().next("li").find("a").first()))}),Foundation.Keyboard.handleKey(i,"AccordionMenu",{open:function(){r.is(":hidden")&&(e.down(r),r.find("li").first().find("a").first().focus())},close:function(){r.length&&!r.is(":hidden")?e.up(r):o.parent("[data-submenu]").length&&(e.up(o.parent("[data-submenu]")),o.parents("li").first().find("a").first().focus())},up:function(){return n.focus(),!0},down:function(){return s.focus(),!0},toggle:function(){o.children("[data-submenu]").length&&e.toggle(o.children("[data-submenu]"))},closeAll:function(){e.hideAll()},handled:function(t){t&&i.preventDefault(),i.stopImmediatePropagation()}})})}},{key:"hideAll",value:function(){this.up(this.$element.find("[data-submenu]"))}},{key:"showAll",value:function(){this.down(this.$element.find("[data-submenu]"))}},{key:"toggle",value:function(t){t.is(":animated")||(t.is(":hidden")?this.down(t):this.up(t))}},{key:"down",value:function(t){var e=this;this.options.multiOpen||this.up(this.$element.find(".is-active").not(t.parentsUntil(this.$element).add(t))),t.addClass("is-active").attr({"aria-hidden":!1}).parent(".is-accordion-submenu-parent").attr({"aria-expanded":!0}),t.slideDown(e.options.slideSpeed,function(){e.$element.trigger("down.zf.accordionMenu",[t])})}},{key:"up",value:function(t){var e=this;t.slideUp(e.options.slideSpeed,function(){e.$element.trigger("up.zf.accordionMenu",[t])});var i=t.find("[data-submenu]").slideUp(0).addBack().attr("aria-hidden",!0);i.parent(".is-accordion-submenu-parent").attr("aria-expanded",!1)}},{key:"destroy",value:function(){this.$element.find("[data-submenu]").slideDown(0).css("display",""),this.$element.find("a").off("click.zf.accordionMenu"),Foundation.Nest.Burn(this.$element,"accordion"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,"AccordionMenu")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,"drilldown"),this._init(),Foundation.registerPlugin(this,"Drilldown"),Foundation.Keyboard.register("Drilldown",{ENTER:"open",SPACE:"open",ARROW_RIGHT:"next",ARROW_UP:"up",ARROW_DOWN:"down",ARROW_LEFT:"previous",ESCAPE:"close",TAB:"down",SHIFT_TAB:"up"})}return _createClass(e,[{key:"_init",value:function(){this.$submenuAnchors=this.$element.find("li.is-drilldown-submenu-parent").children("a"),this.$submenus=this.$submenuAnchors.parent("li").children("[data-submenu]"),this.$menuItems=this.$element.find("li").not(".js-drilldown-back").attr("role","menuitem").find("a"),this.$element.attr("data-mutate",this.$element.attr("data-drilldown")||Foundation.GetYoDigits(6,"drilldown")),this._prepareMenu(),this._registerEvents(),this._keyboardEvents()}},{key:"_prepareMenu",value:function(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.parent();e.options.parentLink&&i.clone().prependTo(n.children("[data-submenu]")).wrap('<li class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menu-item"></li>'),i.data("savedHref",i.attr("href")).removeAttr("href").attr("tabindex",0),i.children("[data-submenu]").attr({"aria-hidden":!0,tabindex:0,role:"menu"}),e._events(i)}),this.$submenus.each(function(){var i=t(this),n=i.find(".js-drilldown-back");if(!n.length)switch(e.options.backButtonPosition){case"bottom":i.append(e.options.backButton);break;case"top":i.prepend(e.options.backButton);break;default:console.error("Unsupported backButtonPosition value '"+e.options.backButtonPosition+"'")}e._back(i)}),this.options.autoHeight||this.$submenus.addClass("drilldown-submenu-cover-previous"),this.$element.parent().hasClass("is-drilldown")||(this.$wrapper=t(this.options.wrapper).addClass("is-drilldown"),this.options.animateHeight&&this.$wrapper.addClass("animate-height"),this.$wrapper=this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims()))}},{key:"_resize",value:function(){this.$wrapper.css({"max-width":"none","min-height":"none"}),this.$wrapper.css(this._getMaxDims())}},{key:"_events",value:function(e){var i=this;e.off("click.zf.drilldown").on("click.zf.drilldown",function(n){if(t(n.target).parentsUntil("ul","li").hasClass("is-drilldown-submenu-parent")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e.parent("li")),i.options.closeOnClick){var s=t("body");s.off(".zf.drilldown").on("click.zf.drilldown",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||(e.preventDefault(),i._hideAll(),s.off(".zf.drilldown"))})}}),this.$element.on("mutateme.zf.trigger",this._resize.bind(this))}},{key:"_registerEvents",value:function(){this.options.scrollTop&&(this._bindHandler=this._scrollTop.bind(this),this.$element.on("open.zf.drilldown hide.zf.drilldown closed.zf.drilldown",this._bindHandler))}},{key:"_scrollTop",value:function(){var e=this,i=""!=e.options.scrollTopElement?t(e.options.scrollTopElement):e.$element,n=parseInt(i.offset().top+e.options.scrollTopOffset);t("html, body").stop(!0).animate({scrollTop:n},e.options.animationDuration,e.options.animationEasing,function(){this===t("html")[0]&&e.$element.trigger("scrollme.zf.drilldown")})}},{key:"_keyboardEvents",value:function(){var e=this;this.$menuItems.add(this.$element.find(".js-drilldown-back > a, .is-submenu-parent-item > a")).on("keydown.zf.drilldown",function(i){var n,s,o=t(this),a=o.parent("li").parent("ul").children("li").children("a");a.each(function(e){if(t(this).is(o))return n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)))}),Foundation.Keyboard.handleKey(i,"Drilldown",{next:function(){if(o.is(e.$submenuAnchors))return e._show(o.parent("li")),o.parent("li").one(Foundation.transitionend(o),function(){o.parent("li").find("ul li a").filter(e.$menuItems).first().focus()}),!0},previous:function(){return e._hide(o.parent("li").parent("ul")),o.parent("li").parent("ul").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent("li").parent("ul").parent("li").children("a").first().focus()},1)}),!0},up:function(){return n.focus(),!0},down:function(){return s.focus(),!0},close:function(){e._back()},open:function(){return o.is(e.$menuItems)?o.is(e.$submenuAnchors)?(e._show(o.parent("li")),o.parent("li").one(Foundation.transitionend(o),function(){o.parent("li").find("ul li a").filter(e.$menuItems).first().focus()}),!0):void 0:(e._hide(o.parent("li").parent("ul")),o.parent("li").parent("ul").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent("li").parent("ul").parent("li").children("a").first().focus()},1)}),!0)},handled:function(t){t&&i.preventDefault(),i.stopImmediatePropagation()}})})}},{key:"_hideAll",value:function(){var t=this.$element.find(".is-drilldown-submenu.is-active").addClass("is-closing");this.options.autoHeight&&this.$wrapper.css({height:t.parent().closest("ul").data("calcHeight")}),t.one(Foundation.transitionend(t),function(e){t.removeClass("is-active is-closing")}),this.$element.trigger("closed.zf.drilldown")}},{key:"_back",value:function(t){var e=this;t.off("click.zf.drilldown"),t.children(".js-drilldown-back").on("click.zf.drilldown",function(i){i.stopImmediatePropagation(),e._hide(t);var n=t.parent("li").parent("ul").parent("li");n.length&&e._show(n)})}},{key:"_menuLinkEvents",value:function(){var t=this;this.$menuItems.not(".is-drilldown-submenu-parent").off("click.zf.drilldown").on("click.zf.drilldown",function(e){setTimeout(function(){t._hideAll()},0)})}},{key:"_show",value:function(t){this.options.autoHeight&&this.$wrapper.css({height:t.children("[data-submenu]").data("calcHeight")}),t.attr("aria-expanded",!0),t.children("[data-submenu]").addClass("is-active").attr("aria-hidden",!1),this.$element.trigger("open.zf.drilldown",[t])}},{key:"_hide",value:function(t){this.options.autoHeight&&this.$wrapper.css({height:t.parent().closest("ul").data("calcHeight")});t.parent("li").attr("aria-expanded",!1),t.attr("aria-hidden",!0).addClass("is-closing"),t.addClass("is-closing").one(Foundation.transitionend(t),function(){t.removeClass("is-active is-closing"),t.blur()}),t.trigger("hide.zf.drilldown",[t])}},{key:"_getMaxDims",value:function(){var e=0,i={},n=this;return this.$submenus.add(this.$element).each(function(){var s=(t(this).children("li").length,Foundation.Box.GetDimensions(this).height);e=s>e?s:e,n.options.autoHeight&&(t(this).data("calcHeight",s),t(this).hasClass("is-drilldown-submenu")||(i.height=s))}),this.options.autoHeight||(i["min-height"]=e+"px"),i["max-width"]=this.$element[0].getBoundingClientRect().width+"px",i}},{key:"destroy",value:function(){this.options.scrollTop&&this.$element.off(".zf.drilldown",this._bindHandler),this._hideAll(),this.$element.off("mutateme.zf.trigger"),Foundation.Nest.Burn(this.$element,"drilldown"),this.$element.unwrap().find(".js-drilldown-back, .is-submenu-parent-item").remove().end().find(".is-active, .is-closing, .is-drilldown-submenu").removeClass("is-active is-closing is-drilldown-submenu").end().find("[data-submenu]").removeAttr("aria-hidden tabindex role"),this.$submenuAnchors.each(function(){t(this).off(".zf.drilldown")}),this.$submenus.removeClass("drilldown-submenu-cover-previous"),this.$element.find("a").each(function(){var e=t(this);e.removeAttr("tabindex"),e.data("savedHref")&&e.attr("href",e.data("savedHref")).removeData("savedHref")}),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={backButton:'<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',backButtonPosition:"top",wrapper:"<div></div>",parentLink:!1,closeOnClick:!1,autoHeight:!1,animateHeight:!1,scrollTop:!1,scrollTopElement:"",scrollTopOffset:0,animationDuration:500,animationEasing:"swing"},Foundation.plugin(e,"Drilldown")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Dropdown"),Foundation.Keyboard.register("Dropdown",{ENTER:"open",SPACE:"open",ESCAPE:"close"})}return _createClass(e,[{key:"_init",value:function(){var e=this.$element.attr("id");this.$anchor=t(t('[data-toggle="'+e+'"]').length?'[data-toggle="'+e+'"]':'[data-open="'+e+'"]'),this.$anchor.attr({"aria-controls":e,"data-is-focus":!1,"data-yeti-box":e,"aria-haspopup":!0,"aria-expanded":!1}),this.options.parentClass?this.$parent=this.$element.parents("."+this.options.parentClass):this.$parent=null,this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({"aria-hidden":"true","data-yeti-box":e,"data-resize":e,"aria-labelledby":this.$anchor[0].id||Foundation.GetYoDigits(6,"dd-anchor")}),this._events()}},{key:"getPositionClass",value:function(){var t=this.$element[0].className.match(/(top|left|right|bottom)/g);t=t?t[0]:"";var e=/float-(\S+)/.exec(this.$anchor[0].className);e=e?e[1]:"";var i=e?e+" "+t:t;return i}},{key:"_reposition",value:function(t){this.usedPositions.push(t?t:"bottom"),!t&&this.usedPositions.indexOf("top")<0?this.$element.addClass("top"):"top"===t&&this.usedPositions.indexOf("bottom")<0?this.$element.removeClass(t):"left"===t&&this.usedPositions.indexOf("right")<0?this.$element.removeClass(t).addClass("right"):"right"===t&&this.usedPositions.indexOf("left")<0?this.$element.removeClass(t).addClass("left"):!t&&this.usedPositions.indexOf("top")>-1&&this.usedPositions.indexOf("left")<0?this.$element.addClass("left"):"top"===t&&this.usedPositions.indexOf("bottom")>-1&&this.usedPositions.indexOf("left")<0?this.$element.removeClass(t).addClass("left"):"left"===t&&this.usedPositions.indexOf("right")>-1&&this.usedPositions.indexOf("bottom")<0?this.$element.removeClass(t):"right"===t&&this.usedPositions.indexOf("left")>-1&&this.usedPositions.indexOf("bottom")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--}},{key:"_setPosition",value:function(){if("false"===this.$anchor.attr("aria-expanded"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),"left"===t?"left":"right"===t?"left":"top"),n="top"===i?"height":"width";"height"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element,this.$parent)){var s=e.windowDims.width,o=0;if(this.$parent){var a=Foundation.Box.GetDimensions(this.$parent),o=a.offset.left;a.width<s&&(s=a.width)}return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,"center bottom",this.options.vOffset,this.options.hOffset+o,!0)).css({width:s-2*this.options.hOffset,height:"auto"}),this.classChanged=!0,!1}for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element,this.$parent,!0)&&this.counter;)this._reposition(t),this._setPosition()}},{key:"_events",value:function(){var e=this;this.$element.on({"open.zf.trigger":this.open.bind(this),"close.zf.trigger":this.close.bind(this),"toggle.zf.trigger":this.toggle.bind(this),"resizeme.zf.trigger":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown",function(){var i=t("body").data();"undefined"!=typeof i.whatinput&&"mouse"!==i.whatinput||(clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data("hover",!0)},e.options.hoverDelay))}).on("mouseleave.zf.dropdown",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data("hover",!1)},e.options.hoverDelay)}),this.options.hoverPane&&this.$element.off("mouseenter.zf.dropdown mouseleave.zf.dropdown").on("mouseenter.zf.dropdown",function(){clearTimeout(e.timeout)}).on("mouseleave.zf.dropdown",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data("hover",!1)},e.options.hoverDelay)})),this.$anchor.add(this.$element).on("keydown.zf.dropdown",function(i){var n=t(this);Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,"Dropdown",{open:function(){n.is(e.$anchor)&&(e.open(),e.$element.attr("tabindex",-1).focus(),i.preventDefault())},close:function(){e.close(),e.$anchor.focus()}})})}},{key:"_addBodyHandler",value:function(){var e=t(document.body).not(this.$element),i=this;e.off("click.zf.dropdown").on("click.zf.dropdown",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off("click.zf.dropdown"))})}},{key:"open",value:function(){if(this.$element.trigger("closeme.zf.dropdown",this.$element.attr("id")),this.$anchor.addClass("hover").attr({"aria-expanded":!0}),this._setPosition(),this.$element.addClass("is-open").attr({"aria-hidden":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus()}this.options.closeOnClick&&this._addBodyHandler(),this.options.trapFocus&&Foundation.Keyboard.trapFocus(this.$element),this.$element.trigger("show.zf.dropdown",[this.$element])}},{key:"close",value:function(){if(!this.$element.hasClass("is-open"))return!1;if(this.$element.removeClass("is-open").attr({"aria-hidden":!0}),this.$anchor.removeClass("hover").attr("aria-expanded",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:"",width:""}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0}this.$element.trigger("hide.zf.dropdown",[this.$element]),this.options.trapFocus&&Foundation.Keyboard.releaseFocus(this.$element)}},{key:"toggle",value:function(){if(this.$element.hasClass("is-open")){if(this.$anchor.data("hover"))return;this.close()}else this.open()}},{key:"destroy",value:function(){this.$element.off(".zf.trigger").hide(),this.$anchor.off(".zf.dropdown"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={parentClass:null,hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:"",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,"Dropdown")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,"dropdown"),this._init(),Foundation.registerPlugin(this,"DropdownMenu"),Foundation.Keyboard.register("DropdownMenu",{ENTER:"open",SPACE:"open",ARROW_RIGHT:"next",ARROW_UP:"up",ARROW_DOWN:"down",ARROW_LEFT:"previous",ESCAPE:"close"})}return _createClass(e,[{key:"_init",value:function(){var t=this.$element.find("li.is-dropdown-submenu-parent");this.$element.children(".is-dropdown-submenu-parent").children(".is-dropdown-submenu").addClass("first-sub"),this.$menuItems=this.$element.find('[role="menuitem"]'),this.$tabs=this.$element.children('[role="menuitem"]'),this.$tabs.find("ul.is-dropdown-submenu").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||"right"===this.options.alignment||Foundation.rtl()||this.$element.parents(".top-bar-right").is("*")?(this.options.alignment="right",t.addClass("opens-left")):t.addClass("opens-right"),this.changed=!1,this._events()}},{key:"_isVertical",value:function(){return"block"===this.$tabs.css("display")}},{key:"_events",value:function(){var e=this,i="ontouchstart"in window||"undefined"!=typeof window.ontouchstart,n="is-dropdown-submenu-parent",s=function(s){var o=t(s.target).parentsUntil("ul","."+n),a=o.hasClass(n),r="true"===o.attr("data-is-click"),l=o.children(".is-dropdown-submenu");if(a)if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;s.stopImmediatePropagation(),s.preventDefault(),e._hide(o)}else s.preventDefault(),s.stopImmediatePropagation(),e._show(l),o.add(o.parentsUntil(e.$element,"."+n)).attr("data-is-click",!0)};(this.options.clickOpen||i)&&this.$menuItems.on("click.zf.dropdownmenu touchstart.zf.dropdownmenu",s),e.options.closeOnClickInside&&this.$menuItems.on("click.zf.dropdownmenu touchend.zf.dropdownmenu",function(i){var s=t(this),o=s.hasClass(n);o||e._hide()}),this.options.disableHover||this.$menuItems.on("mouseenter.zf.dropdownmenu",function(i){var s=t(this),o=s.hasClass(n);o&&(clearTimeout(s.data("_delay")),s.data("_delay",setTimeout(function(){e._show(s.children(".is-dropdown-submenu"))},e.options.hoverDelay)))}).on("mouseleave.zf.dropdownmenu",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if("true"===s.attr("data-is-click")&&e.options.clickOpen)return!1;clearTimeout(s.data("_delay")),s.data("_delay",setTimeout(function(){e._hide(s)},e.options.closingTime))}}),this.$menuItems.on("keydown.zf.dropdownmenu",function(i){var n,s,o=t(i.target).parentsUntil("ul",'[role="menuitem"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings("li").add(o);r.each(function(e){if(t(this).is(o))return n=r.eq(e-1),void(s=r.eq(e+1))});var l=function(){o.is(":last-child")||(s.children("a:first").focus(),i.preventDefault())},u=function(){n.children("a:first").focus(),i.preventDefault()},d=function(){var t=o.children("ul.is-dropdown-submenu");t.length&&(e._show(t),o.find("li > a:first").focus(),i.preventDefault())},h=function(){var t=o.parent("ul").parent("li");t.children("a:first").focus(),e._hide(t),i.preventDefault()},c={open:d,close:function(){e._hide(e.$element),e.$menuItems.find("a:first").focus(),i.preventDefault()},handled:function(){i.stopImmediatePropagation()}};a?e._isVertical()?Foundation.rtl()?t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{down:l,up:u,next:d,previous:h}):Foundation.rtl()?t.extend(c,{next:u,previous:l,down:d,up:h}):t.extend(c,{next:l,previous:u,down:d,up:h}):Foundation.rtl()?t.extend(c,{next:h,previous:d,down:l,up:u}):t.extend(c,{next:d,previous:h,down:l,up:u}),Foundation.Keyboard.handleKey(i,"DropdownMenu",c)})}},{key:"_addBodyHandler",value:function(){var e=t(document.body),i=this;e.off("mouseup.zf.dropdownmenu touchend.zf.dropdownmenu").on("mouseup.zf.dropdownmenu touchend.zf.dropdownmenu",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off("mouseup.zf.dropdownmenu touchend.zf.dropdownmenu"))})}},{key:"_show",value:function(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0})),n=e.parent("li.is-dropdown-submenu-parent").siblings("li.is-dropdown-submenu-parent");this._hide(n,i),e.css("visibility","hidden").addClass("js-dropdown-active").parent("li.is-dropdown-submenu-parent").addClass("is-active");var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o="left"===this.options.alignment?"-right":"-left",a=e.parent(".is-dropdown-submenu-parent");a.removeClass("opens"+o).addClass("opens-"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass("opens-"+this.options.alignment).addClass("opens-inner"),this.changed=!0}e.css("visibility",""),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger("show.zf.dropdownmenu",[e])}},{key:"_hide",value:function(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e}):this.$element;var n=i.hasClass("is-active")||i.find(".is-active").length>0;if(n){if(i.find("li.is-active").add(i).attr({"data-is-click":!1}).removeClass("is-active"),i.find("ul.js-dropdown-active").removeClass("js-dropdown-active"),this.changed||i.find("opens-inner").length){var s="left"===this.options.alignment?"right":"left";i.find("li.is-dropdown-submenu-parent").add(i).removeClass("opens-inner opens-"+this.options.alignment).addClass("opens-"+s),this.changed=!1}this.$element.trigger("hide.zf.dropdownmenu",[i])}}},{key:"destroy",value:function(){this.$menuItems.off(".zf.dropdownmenu").removeAttr("data-is-click").removeClass("is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner"),t(document.body).off(".zf.dropdownmenu"),Foundation.Nest.Burn(this.$element,"dropdown"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:"left",closeOnClick:!0,closeOnClickInside:!0,verticalClass:"vertical",rightClass:"align-right",forceFollow:!0},Foundation.plugin(e,"DropdownMenu")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Equalizer")}return _createClass(e,[{key:"_init",value:function(){var e=this.$element.attr("data-equalizer")||"",i=this.$element.find('[data-equalizer-watch="'+e+'"]');this.$watched=i.length?i:this.$element.find("[data-equalizer-watch]"),this.$element.attr("data-resize",e||Foundation.GetYoDigits(6,"eq")),this.$element.attr("data-mutate",e||Foundation.GetYoDigits(6,"eq")),this.hasNested=this.$element.find("[data-equalizer]").length>0,this.isNested=this.$element.parentsUntil(document.body,"[data-equalizer]").length>0,this.isOn=!1,this._bindHandler={onResizeMeBound:this._onResizeMe.bind(this),onPostEqualizedBound:this._onPostEqualized.bind(this)};var n,s=this.$element.find("img");this.options.equalizeOn?(n=this._checkMQ(),t(window).on("changed.zf.mediaquery",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow())}},{key:"_pauseEvents",value:function(){this.isOn=!1,this.$element.off({".zf.equalizer":this._bindHandler.onPostEqualizedBound,"resizeme.zf.trigger":this._bindHandler.onResizeMeBound,"mutateme.zf.trigger":this._bindHandler.onResizeMeBound})}},{key:"_onResizeMe",value:function(t){this._reflow()}},{key:"_onPostEqualized",value:function(t){t.target!==this.$element[0]&&this._reflow()}},{key:"_events",value:function(){this._pauseEvents(),this.hasNested?this.$element.on("postequalized.zf.equalizer",this._bindHandler.onPostEqualizedBound):(this.$element.on("resizeme.zf.trigger",this._bindHandler.onResizeMeBound),this.$element.on("mutateme.zf.trigger",this._bindHandler.onResizeMeBound)),this.isOn=!0}},{key:"_checkMQ",value:function(){var t=!Foundation.MediaQuery.is(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css("height","auto")):this.isOn||this._events(),t}},{key:"_killswitch",value:function(){}},{key:"_reflow",value:function(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css("height","auto"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)))}},{key:"_isStacked",value:function(){return!this.$watched[0]||!this.$watched[1]||this.$watched[0].getBoundingClientRect().top!==this.$watched[1].getBoundingClientRect().top}},{key:"getHeights",value:function(t){for(var e=[],i=0,n=this.$watched.length;i<n;i++)this.$watched[i].style.height="auto",e.push(this.$watched[i].offsetHeight);t(e)}},{key:"getHeightsByRow",value:function(e){var i=this.$watched.length?this.$watched.first().offset().top:0,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;o<a;o++){this.$watched[o].style.height="auto";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight])}for(var l=0,u=n.length;l<u;l++){var d=t(n[l]).map(function(){return this[1]}).get(),h=Math.max.apply(null,d);n[l].push(h)}e(n)}},{key:"applyHeight",value:function(t){var e=Math.max.apply(null,t);this.$element.trigger("preequalized.zf.equalizer"),this.$watched.css("height",e),this.$element.trigger("postequalized.zf.equalizer")}},{key:"applyHeightByRow",value:function(e){this.$element.trigger("preequalized.zf.equalizer");for(var i=0,n=e.length;i<n;i++){var s=e[i].length,o=e[i][s-1];if(s<=2)t(e[i][0][0]).css({height:"auto"});else{this.$element.trigger("preequalizedrow.zf.equalizer");for(var a=0,r=s-1;a<r;a++)t(e[i][a][0]).css({height:o});this.$element.trigger("postequalizedrow.zf.equalizer")}}this.$element.trigger("postequalized.zf.equalizer")}},{key:"destroy",value:function(){this._pauseEvents(),this.$watched.css("height","auto"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={equalizeOnStack:!1,equalizeByRow:!1,equalizeOn:""},Foundation.plugin(e,"Equalizer")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath="",this._init(),this._events(),Foundation.registerPlugin(this,"Interchange")}return _createClass(e,[{key:"_init",value:function(){this._addBreakpoints(),this._generateRules(),this._reflow()}},{key:"_events",value:function(){var e=this;t(window).on("resize.zf.interchange",Foundation.util.throttle(function(){e._reflow()},50))}},{key:"_reflow",value:function(){var t;for(var e in this.rules)if(this.rules.hasOwnProperty(e)){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i)}t&&this.replace(t.path)}},{key:"_addBreakpoints",value:function(){for(var t in Foundation.MediaQuery.queries)if(Foundation.MediaQuery.queries.hasOwnProperty(t)){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value}}},{key:"_generateRules",value:function(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data("interchange").match(/\[.*?\]/g);for(var s in i)if(i.hasOwnProperty(s)){var o=i[s].slice(1,-1).split(", "),a=o.slice(0,-1).join(""),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r})}this.rules=n}},{key:"replace",value:function(e){if(this.currentPath!==e){var i=this,n="replaced.zf.interchange";"IMG"===this.$element[0].nodeName?this.$element.attr("src",e).on("load",function(){i.currentPath=e}).trigger(n):e.match(/\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)?this.$element.css({"background-image":"url("+e+")"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e})}}},{key:"destroy",value:function(){}}]),e}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:"screen and (orientation: landscape)",portrait:"screen and (orientation: portrait)",retina:"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)"},Foundation.plugin(e,"Interchange")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this.calcPoints(),Foundation.registerPlugin(this,"Magellan");
}return _createClass(e,[{key:"_init",value:function(){var e=this.$element[0].id||Foundation.GetYoDigits(6,"magellan");this.$targets=t("[data-magellan-target]"),this.$links=this.$element.find("a"),this.$element.attr({"data-resize":e,"data-scroll":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events()}},{key:"calcPoints",value:function(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n)})}},{key:"_events",value:function(){var e=this;t("html, body"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one("load",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive()}),this.$element.on({"resizeme.zf.trigger":this.reflow.bind(this),"scrollme.zf.trigger":this._updateActive.bind(this)}).on("click.zf.magellan",'a[href^="#"]',function(t){t.preventDefault();var i=this.getAttribute("href");e.scrollToLoc(i)}),t(window).on("popstate",function(t){e.options.deepLinking&&e.scrollToLoc(window.location.hash)})}},{key:"scrollToLoc",value:function(e){if(!t(e).length)return!1;this._inTransition=!0;var i=this,n=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t("html, body").stop(!0).animate({scrollTop:n},this.options.animationDuration,this.options.animationEasing,function(){i._inTransition=!1,i._updateActive()})}},{key:"reflow",value:function(){this.calcPoints(),this._updateActive()}},{key:"_updateActive",value:function(){if(!this._inTransition){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=void 0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?t-n.options.barOffset<=e:t-n.options.barOffset-n.options.threshold<=e});t=s.length?s.length-1:0}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.filter('[href="#'+this.$targets.eq(t).data("magellan-target")+'"]').addClass(this.options.activeClass),this.options.deepLinking){var o="";void 0!=t&&(o=this.$active[0].getAttribute("href")),o!==window.location.hash&&(window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o)}this.scrollPos=e,this.$element.trigger("update.zf.magellan",[this.$active])}}},{key:"destroy",value:function(){if(this.$element.off(".zf.trigger .zf.magellan").find("."+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute("href");window.location.hash.replace(t,"")}Foundation.unregisterPlugin(this)}}]),e}();e.defaults={animationDuration:500,animationEasing:"linear",threshold:50,activeClass:"active",deepLinking:!1,barOffset:0},Foundation.plugin(e,"Magellan")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this.$triggers=t(),this._init(),this._events(),Foundation.registerPlugin(this,"OffCanvas"),Foundation.Keyboard.register("OffCanvas",{ESCAPE:"close"})}return _createClass(e,[{key:"_init",value:function(){var e=this.$element.attr("id");if(this.$element.attr("aria-hidden","true"),this.$element.addClass("is-transition-"+this.options.transition),this.$triggers=t(document).find('[data-open="'+e+'"], [data-close="'+e+'"], [data-toggle="'+e+'"]').attr("aria-expanded","false").attr("aria-controls",e),this.options.contentOverlay===!0){var i=document.createElement("div"),n="fixed"===t(this.$element).css("position")?"is-overlay-fixed":"is-overlay-absolute";i.setAttribute("class","js-off-canvas-overlay "+n),this.$overlay=t(i),"is-overlay-fixed"===n?t("body").append(this.$overlay):this.$element.siblings("[data-off-canvas-content]").append(this.$overlay)}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,"g").test(this.$element[0].className),this.options.isRevealed===!0&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split("-")[2],this._setMQChecker()),!this.options.transitionTime==!0&&(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t("[data-off-canvas]")[0]).transitionDuration))}},{key:"_events",value:function(){if(this.$element.off(".zf.trigger .zf.offcanvas").on({"open.zf.trigger":this.open.bind(this),"close.zf.trigger":this.close.bind(this),"toggle.zf.trigger":this.toggle.bind(this),"keydown.zf.offcanvas":this._handleKeyboard.bind(this)}),this.options.closeOnClick===!0){var e=this.options.contentOverlay?this.$overlay:t("[data-off-canvas-content]");e.on({"click.zf.offcanvas":this.close.bind(this)})}}},{key:"_setMQChecker",value:function(){var e=this;t(window).on("changed.zf.mediaquery",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1)}).one("load.zf.offcanvas",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0)})}},{key:"reveal",value:function(t){var e=this.$element.find("[data-close]");t?(this.close(),this.isRevealed=!0,this.$element.attr("aria-hidden","false"),this.$element.off("open.zf.trigger toggle.zf.trigger"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.attr("aria-hidden","true"),this.$element.on({"open.zf.trigger":this.open.bind(this),"toggle.zf.trigger":this.toggle.bind(this)}),e.length&&e.show())}},{key:"_stopScrolling",value:function(t){return!1}},{key:"open",value:function(e,i){if(!this.$element.hasClass("is-open")&&!this.isRevealed){var n=this;i&&(this.$lastTrigger=i),"top"===this.options.forceTo?window.scrollTo(0,0):"bottom"===this.options.forceTo&&window.scrollTo(0,document.body.scrollHeight),n.$element.addClass("is-open"),this.$triggers.attr("aria-expanded","true"),this.$element.attr("aria-hidden","false").trigger("opened.zf.offcanvas"),this.options.contentScroll===!1&&t("body").addClass("is-off-canvas-open").on("touchmove",this._stopScrolling),this.options.contentOverlay===!0&&this.$overlay.addClass("is-visible"),this.options.closeOnClick===!0&&this.options.contentOverlay===!0&&this.$overlay.addClass("is-closable"),this.options.autoFocus===!0&&this.$element.one(Foundation.transitionend(this.$element),function(){n.$element.find("a, button").eq(0).focus()}),this.options.trapFocus===!0&&(this.$element.siblings("[data-off-canvas-content]").attr("tabindex","-1"),Foundation.Keyboard.trapFocus(this.$element))}}},{key:"close",value:function(e){if(this.$element.hasClass("is-open")&&!this.isRevealed){var i=this;i.$element.removeClass("is-open"),this.$element.attr("aria-hidden","true").trigger("closed.zf.offcanvas"),this.options.contentScroll===!1&&t("body").removeClass("is-off-canvas-open").off("touchmove",this._stopScrolling),this.options.contentOverlay===!0&&this.$overlay.removeClass("is-visible"),this.options.closeOnClick===!0&&this.options.contentOverlay===!0&&this.$overlay.removeClass("is-closable"),this.$triggers.attr("aria-expanded","false"),this.options.trapFocus===!0&&(this.$element.siblings("[data-off-canvas-content]").removeAttr("tabindex"),Foundation.Keyboard.releaseFocus(this.$element))}}},{key:"toggle",value:function(t,e){this.$element.hasClass("is-open")?this.close(t,e):this.open(t,e)}},{key:"_handleKeyboard",value:function(t){var e=this;Foundation.Keyboard.handleKey(t,"OffCanvas",{close:function(){return e.close(),e.$lastTrigger.focus(),!0},handled:function(){t.stopPropagation(),t.preventDefault()}})}},{key:"destroy",value:function(){this.close(),this.$element.off(".zf.trigger .zf.offcanvas"),this.$overlay.off(".zf.offcanvas"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={closeOnClick:!0,contentOverlay:!0,contentScroll:!0,transitionTime:0,transition:"push",forceTo:null,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:"reveal-for-",trapFocus:!1},Foundation.plugin(e,"OffCanvas")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Orbit"),Foundation.Keyboard.register("Orbit",{ltr:{ARROW_RIGHT:"next",ARROW_LEFT:"previous"},rtl:{ARROW_LEFT:"next",ARROW_RIGHT:"previous"}})}return _createClass(e,[{key:"_init",value:function(){this._reset(),this.$wrapper=this.$element.find("."+this.options.containerClass),this.$slides=this.$element.find("."+this.options.slideClass);var t=this.$element.find("img"),e=this.$slides.filter(".is-active"),i=this.$element[0].id||Foundation.GetYoDigits(6,"orbit");this.$element.attr({"data-resize":i,id:i}),e.length||this.$slides.eq(0).addClass("is-active"),this.options.useMUI||this.$slides.addClass("no-motionui"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr("tabindex",0)}},{key:"_loadBullets",value:function(){this.$bullets=this.$element.find("."+this.options.boxOfBullets).find("button")}},{key:"geoSync",value:function(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0)}),this.timer.start()}},{key:"_prepareForOrbit",value:function(){this._setWrapperHeight()}},{key:"_setWrapperHeight",value:function(e){var i,n=0,s=0,o=this;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr("data-slide",s),o.$slides.filter(".is-active")[0]!==o.$slides.eq(s)[0]&&t(this).css({position:"relative",display:"none"}),n=i>n?i:n,s++}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e&&e(n))}},{key:"_setSlideHeight",value:function(e){this.$slides.each(function(){t(this).css("max-height",e)})}},{key:"_events",value:function(){var e=this;if(this.$element.off(".resizeme.zf.trigger").on({"resizeme.zf.trigger":this._prepareForOrbit.bind(this)}),this.$slides.length>1){if(this.options.swipe&&this.$slides.off("swipeleft.zf.orbit swiperight.zf.orbit").on("swipeleft.zf.orbit",function(t){t.preventDefault(),e.changeSlide(!0)}).on("swiperight.zf.orbit",function(t){t.preventDefault(),e.changeSlide(!1)}),this.options.autoPlay&&(this.$slides.on("click.zf.orbit",function(){e.$element.data("clickedOn",!e.$element.data("clickedOn")),e.timer[e.$element.data("clickedOn")?"pause":"start"]()}),this.options.pauseOnHover&&this.$element.on("mouseenter.zf.orbit",function(){e.timer.pause()}).on("mouseleave.zf.orbit",function(){e.$element.data("clickedOn")||e.timer.start()})),this.options.navButtons){var i=this.$element.find("."+this.options.nextClass+", ."+this.options.prevClass);i.attr("tabindex",0).on("click.zf.orbit touchend.zf.orbit",function(i){i.preventDefault(),e.changeSlide(t(this).hasClass(e.options.nextClass))})}this.options.bullets&&this.$bullets.on("click.zf.orbit touchend.zf.orbit",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data("slide"),n=i>e.$slides.filter(".is-active").data("slide"),s=e.$slides.eq(i);e.changeSlide(n,s,i)}),this.options.accessible&&this.$wrapper.add(this.$bullets).on("keydown.zf.orbit",function(i){Foundation.Keyboard.handleKey(i,"Orbit",{next:function(){e.changeSlide(!0)},previous:function(){e.changeSlide(!1)},handled:function(){t(i.target).is(e.$bullets)&&e.$bullets.filter(".is-active").focus()}})})}}},{key:"_reset",value:function(){"undefined"!=typeof this.$slides&&this.$slides.length>1&&(this.$element.off(".zf.orbit").find("*").off(".zf.orbit"),this.options.autoPlay&&this.timer.restart(),this.$slides.each(function(e){t(e).removeClass("is-active is-active is-in").removeAttr("aria-live").hide()}),this.$slides.first().addClass("is-active").show(),this.$element.trigger("slidechange.zf.orbit",[this.$slides.first()]),this.options.bullets&&this._updateBullets(0))}},{key:"changeSlide",value:function(t,e,i){if(this.$slides){var n=this.$slides.filter(".is-active").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?"Right":"Left",l=t?"Left":"Right",u=this;s=e?e:t?this.options.infiniteWrap?n.next("."+this.options.slideClass).length?n.next("."+this.options.slideClass):o:n.next("."+this.options.slideClass):this.options.infiniteWrap?n.prev("."+this.options.slideClass).length?n.prev("."+this.options.slideClass):a:n.prev("."+this.options.slideClass),s.length&&(this.$element.trigger("beforeslidechange.zf.orbit",[n,s]),this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI&&!this.$element.is(":hidden")?(Foundation.Motion.animateIn(s.addClass("is-active").css({position:"absolute",top:0}),this.options["animInFrom"+r],function(){s.css({position:"relative",display:"block"}).attr("aria-live","polite")}),Foundation.Motion.animateOut(n.removeClass("is-active"),this.options["animOutTo"+l],function(){n.removeAttr("aria-live"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart()})):(n.removeClass("is-active is-in").removeAttr("aria-live").hide(),s.addClass("is-active is-in").attr("aria-live","polite").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger("slidechange.zf.orbit",[s]))}}},{key:"_updateBullets",value:function(t){var e=this.$element.find("."+this.options.boxOfBullets).find(".is-active").removeClass("is-active").blur(),i=e.find("span:last").detach();this.$bullets.eq(t).addClass("is-active").append(i)}},{key:"destroy",value:function(){this.$element.off(".zf.orbit").find("*").off(".zf.orbit").end().hide(),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:"slide-in-right",animOutToRight:"slide-out-right",animInFromLeft:"slide-in-left",animOutToLeft:"slide-out-left",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:"orbit-container",slideClass:"orbit-slide",boxOfBullets:"orbit-bullets",nextClass:"orbit-next",prevClass:"orbit-previous",useMUI:!0},Foundation.plugin(e,"Orbit")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data("responsive-menu"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,"ResponsiveMenu")}return _createClass(e,[{key:"_init",value:function(){if("string"==typeof this.rules){for(var e={},n=this.rules.split(" "),s=0;s<n.length;s++){var o=n[s].split("-"),a=o.length>1?o[0]:"small",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r])}this.rules=e}t.isEmptyObject(this.rules)||this._checkMediaQueries(),this.$element.attr("data-mutate",this.$element.attr("data-mutate")||Foundation.GetYoDigits(6,"responsive-menu"))}},{key:"_events",value:function(){var e=this;t(window).on("changed.zf.mediaquery",function(){e._checkMediaQueries()})}},{key:"_checkMediaQueries",value:function(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t)}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass)}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})))}},{key:"destroy",value:function(){this.currentPlugin.destroy(),t(window).off(".zf.ResponsiveMenu"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={};var i={dropdown:{cssClass:"dropdown",plugin:Foundation._plugins["dropdown-menu"]||null},drilldown:{cssClass:"drilldown",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:"accordion-menu",plugin:Foundation._plugins["accordion-menu"]||null}};Foundation.plugin(e,"ResponsiveMenu")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,"ResponsiveToggle")}return _createClass(e,[{key:"_init",value:function(){var e=this.$element.data("responsive-toggle");if(e||console.error("Your tab bar needs an ID of a Menu as the value of data-tab-bar."),this.$targetMenu=t("#"+e),this.$toggler=this.$element.find("[data-toggle]"),this.options=t.extend({},this.options,this.$targetMenu.data()),this.options.animate){var i=this.options.animate.split(" ");this.animationIn=i[0],this.animationOut=i[1]||null}this._update()}},{key:"_events",value:function(){this._updateMqHandler=this._update.bind(this),t(window).on("changed.zf.mediaquery",this._updateMqHandler),this.$toggler.on("click.zf.responsiveToggle",this.toggleMenu.bind(this))}},{key:"_update",value:function(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide())}},{key:"toggleMenu",value:function(){var t=this;Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.options.animate?this.$targetMenu.is(":hidden")?Foundation.Motion.animateIn(this.$targetMenu,this.animationIn,function(){t.$element.trigger("toggled.zf.responsiveToggle"),t.$targetMenu.find("[data-mutate]").triggerHandler("mutateme.zf.trigger")}):Foundation.Motion.animateOut(this.$targetMenu,this.animationOut,function(){t.$element.trigger("toggled.zf.responsiveToggle")}):(this.$targetMenu.toggle(0),this.$targetMenu.find("[data-mutate]").trigger("mutateme.zf.trigger"),this.$element.trigger("toggled.zf.responsiveToggle")))}},{key:"destroy",value:function(){this.$element.off(".zf.responsiveToggle"),this.$toggler.off(".zf.responsiveToggle"),t(window).off("changed.zf.mediaquery",this._updateMqHandler),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={hideFor:"medium",animate:!1},Foundation.plugin(e,"ResponsiveToggle")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){function e(){return/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)}function i(){return/Android/.test(window.navigator.userAgent)}function n(){return e()||i()}var s=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Reveal"),Foundation.Keyboard.register("Reveal",{ENTER:"open",SPACE:"open",ESCAPE:"close"})}return _createClass(e,[{key:"_init",value:function(){this.id=this.$element.attr("id"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isMobile=n(),this.$anchor=t(t('[data-open="'+this.id+'"]').length?'[data-open="'+this.id+'"]':'[data-toggle="'+this.id+'"]'),this.$anchor.attr({"aria-controls":this.id,"aria-haspopup":!0,tabindex:0}),(this.options.fullScreen||this.$element.hasClass("full"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:"dialog","aria-hidden":!0,"data-yeti-box":this.id,"data-resize":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(this.options.appendTo)),this.$element.addClass("without-overlay")),this._events(),this.options.deepLink&&window.location.hash==="#"+this.id&&t(window).one("load.zf.reveal",this.open.bind(this))}},{key:"_makeOverlay",value:function(){return t("<div></div>").addClass("reveal-overlay").appendTo(this.options.appendTo)}},{key:"_updatePosition",value:function(){var e,i,n=this.$element.outerWidth(),s=t(window).width(),o=this.$element.outerHeight(),a=t(window).height();e="auto"===this.options.hOffset?parseInt((s-n)/2,10):parseInt(this.options.hOffset,10),i="auto"===this.options.vOffset?o>a?parseInt(Math.min(100,a/10),10):parseInt((a-o)/4,10):parseInt(this.options.vOffset,10),this.$element.css({top:i+"px"}),this.$overlay&&"auto"===this.options.hOffset||(this.$element.css({left:e+"px"}),this.$element.css({margin:"0px"}))}},{key:"_events",value:function(){var e=this,i=this;this.$element.on({"open.zf.trigger":this.open.bind(this),"close.zf.trigger":function(n,s){if(n.target===i.$element[0]||t(n.target).parents("[data-closable]")[0]===s)return e.close.apply(e)},"toggle.zf.trigger":this.toggle.bind(this),"resizeme.zf.trigger":function(){i._updatePosition()}}),this.$anchor.length&&this.$anchor.on("keydown.zf.reveal",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),i.open())}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(".zf.reveal").on("click.zf.reveal",function(e){e.target!==i.$element[0]&&!t.contains(i.$element[0],e.target)&&t.contains(document,e.target)&&i.close()}),this.options.deepLink&&t(window).on("popstate.zf.reveal:"+this.id,this._handleState.bind(this))}},{key:"_handleState",value:function(t){window.location.hash!=="#"+this.id||this.isActive?this.close():this.open()}},{key:"open",value:function(){function e(){s.isMobile?(s.originalScrollPos||(s.originalScrollPos=window.pageYOffset),t("html, body").addClass("is-reveal-open")):t("body").addClass("is-reveal-open")}var i=this;if(this.options.deepLink){var n="#"+this.id;window.history.pushState?window.history.pushState(null,null,n):window.location.hash=n}this.isActive=!0,this.$element.css({visibility:"hidden"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:"hidden"}).show(),this._updatePosition(),this.$element.hide().css({visibility:""}),this.$overlay&&(this.$overlay.css({visibility:""}).hide(),this.$element.hasClass("fast")?this.$overlay.addClass("fast"):this.$element.hasClass("slow")&&this.$overlay.addClass("slow")),this.options.multipleOpened||this.$element.trigger("closeme.zf.reveal",this.id);var s=this;this.options.animationIn?!function(){var t=function(){s.$element.attr({"aria-hidden":!1,tabindex:-1}).focus(),e(),Foundation.Keyboard.trapFocus(s.$element)};i.options.overlay&&Foundation.Motion.animateIn(i.$overlay,"fade-in"),Foundation.Motion.animateIn(i.$element,i.options.animationIn,function(){i.$element&&(i.focusableElements=Foundation.Keyboard.findFocusable(i.$element),t())})}():(this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay)),this.$element.attr({"aria-hidden":!1,tabindex:-1}).focus(),Foundation.Keyboard.trapFocus(this.$element),this.$element.trigger("open.zf.reveal"),e(),setTimeout(function(){i._extraHandlers()},0)}},{key:"_extraHandlers",value:function(){var e=this;this.$element&&(this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t("body").on("click.zf.reveal",function(i){i.target!==e.$element[0]&&!t.contains(e.$element[0],i.target)&&t.contains(document,i.target)&&e.close()}),this.options.closeOnEsc&&t(window).on("keydown.zf.reveal",function(t){Foundation.Keyboard.handleKey(t,"Reveal",{close:function(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus())}})}),this.$element.on("keydown.zf.reveal",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,"Reveal",{open:function(){e.$element.find(":focus").is(e.$element.find("[data-close]"))?setTimeout(function(){e.$anchor.focus()},1):n.is(e.focusableElements)&&e.open()},close:function(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus())},handled:function(t){t&&i.preventDefault()}})}))}},{key:"close",value:function(){function e(){i.isMobile?(t("html, body").removeClass("is-reveal-open"),i.originalScrollPos&&(t("body").scrollTop(i.originalScrollPos),i.originalScrollPos=null)):t("body").removeClass("is-reveal-open"),Foundation.Keyboard.releaseFocus(i.$element),i.$element.attr("aria-hidden",!0),i.$element.trigger("closed.zf.reveal")}if(!this.isActive||!this.$element.is(":visible"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,"fade-out",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off("keydown.zf.reveal"),!this.options.overlay&&this.options.closeOnClick&&t("body").off("click.zf.reveal"),this.$element.off("keydown.zf.reveal"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState("",document.title,window.location.href.replace("#"+this.id,"")):window.location.hash="")}},{key:"toggle",value:function(){this.isActive?this.close():this.open()}},{key:"destroy",value:function(){this.options.overlay&&(this.$element.appendTo(t(this.options.appendTo)),this.$overlay.hide().off().remove()),this.$element.hide().off(),this.$anchor.off(".zf"),t(window).off(".zf.reveal:"+this.id),Foundation.unregisterPlugin(this)}}]),e}();s.defaults={animationIn:"",animationOut:"",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:"auto",hOffset:"auto",fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1,appendTo:"body"},Foundation.plugin(s,"Reveal")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){function e(t,e){return t/e}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i)}function n(t,e){return Math.log(e)/Math.log(t)}var s=function(){function s(e,i){_classCallCheck(this,s),this.$element=e,this.options=t.extend({},s.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,"Slider"),Foundation.Keyboard.register("Slider",{ltr:{ARROW_RIGHT:"increase",ARROW_UP:"increase",ARROW_DOWN:"decrease",ARROW_LEFT:"decrease",SHIFT_ARROW_RIGHT:"increase_fast",SHIFT_ARROW_UP:"increase_fast",SHIFT_ARROW_DOWN:"decrease_fast",SHIFT_ARROW_LEFT:"decrease_fast"},rtl:{ARROW_LEFT:"increase",ARROW_RIGHT:"decrease",SHIFT_ARROW_LEFT:"increase_fast",SHIFT_ARROW_RIGHT:"decrease_fast"}})}return _createClass(s,[{key:"_init",value:function(){this.inputs=this.$element.find("input"),this.handles=this.$element.find("[data-slider-handle]"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t("#"+this.$handle.attr("aria-controls")),this.$fill=this.$element.find("[data-slider-fill]").css(this.options.vertical?"height":"width",0);var e=!1;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t("#"+this.$handle2.attr("aria-controls")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setInitAttr(1)),this.setHandles(),this._events()}},{key:"setHandles",value:function(){var t=this;this.handles[1]?this._setHandlePos(this.$handle,this.inputs.eq(0).val(),!0,function(){t._setHandlePos(t.$handle2,t.inputs.eq(1).val(),!0)}):this._setHandlePos(this.$handle,this.inputs.eq(0).val(),!0)}},{key:"_reflow",value:function(){this.setHandles()}},{key:"_pctOfBar",value:function(t){var i=e(t-this.options.start,this.options.end-this.options.start);switch(this.options.positionValueFunction){case"pow":i=this._logTransform(i);break;case"log":i=this._powTransform(i)}return i.toFixed(2)}},{key:"_value",value:function(t){switch(this.options.positionValueFunction){case"pow":t=this._powTransform(t);break;case"log":t=this._logTransform(t)}var e=(this.options.end-this.options.start)*t+this.options.start;return e}},{key:"_logTransform",value:function(t){return n(this.options.nonLinearBase,t*(this.options.nonLinearBase-1)+1)}},{key:"_powTransform",value:function(t){return(Math.pow(this.options.nonLinearBase,t)-1)/(this.options.nonLinearBase-1)}},{key:"_setHandlePos",value:function(t,i,n,s){if(!this.$element.hasClass(this.options.disabledClass)){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr("aria-valuenow"));i=i>=a?a-this.options.step:i}else{var r=parseFloat(this.$handle.attr("aria-valuenow"));i=i<=r?r+this.options.step:i}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?"height":"width",h=u?"top":"left",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=this._pctOfBar(i),m=(f-c)*p,g=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var v={};if(this._setValues(t,i),o){var y,w=0===this.handles.index(t),b=~~(100*e(c,f));if(w)v[h]=g+"%",y=parseFloat(this.$handle2[0].style[h])-g+b,s&&"function"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);y=g-(isNaN($)?(this.options.initialStart-this.options.start)/((this.options.end-this.options.start)/100):$)+b}v["min-"+d]=y+"%"}this.$element.one("finished.zf.animate",function(){l.$element.trigger("moved.zf.slider",[t])});var C=this.$element.data("dragging")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){isNaN(g)?t.css(h,100*p+"%"):t.css(h,g+"%"),l.options.doubleSided?l.$fill.css(v):l.$fill.css(d,100*p+"%")}),clearTimeout(l.timeout),l.timeout=setTimeout(function(){l.$element.trigger("changed.zf.slider",[t])},l.options.changedDelay)}}},{key:"_setInitAttr",value:function(t){var e=0===t?this.options.initialStart:this.options.initialEnd,i=this.inputs.eq(t).attr("id")||Foundation.GetYoDigits(6,"slider");this.inputs.eq(t).attr({id:i,max:this.options.end,min:this.options.start,step:this.options.step}),this.inputs.eq(t).val(e),this.handles.eq(t).attr({role:"slider","aria-controls":i,"aria-valuemax":this.options.end,"aria-valuemin":this.options.start,"aria-valuenow":e,"aria-orientation":this.options.vertical?"vertical":"horizontal",tabindex:0})}},{key:"_setValues",value:function(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr("aria-valuenow",e)}},{key:"_handleEvent",value:function(n,s,o){var a,r;if(o)a=this._adjustValue(null,o),r=!0;else{n.preventDefault();var l=this,u=this.options.vertical,d=u?"height":"width",h=u?"top":"left",c=u?n.pageY:n.pageX,f=(this.$handle[0].getBoundingClientRect()[d]/2,this.$element[0].getBoundingClientRect()[d]),p=u?t(window).scrollTop():t(window).scrollLeft(),m=this.$element.offset()[h];n.clientY===n.pageY&&(c+=p);var g,v=c-m;g=v<0?0:v>f?f:v;var y=e(g,f);if(a=this._value(y),Foundation.rtl()&&!this.options.vertical&&(a=this.options.end-a),a=l._adjustValue(null,a),r=!1,!s){var w=i(this.$handle,h,g,d),b=i(this.$handle2,h,g,d);
s=w<=b?this.$handle:this.$handle2}}this._setHandlePos(s,a,r)}},{key:"_adjustValue",value:function(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr("aria-valuenow")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s}},{key:"_events",value:function(){this._eventsForHandle(this.$handle),this.handles[1]&&this._eventsForHandle(this.$handle2)}},{key:"_eventsForHandle",value:function(e){var i,n=this;if(this.inputs.off("change.zf.slider").on("change.zf.slider",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val())}),this.options.clickSelect&&this.$element.off("click.zf.slider").on("click.zf.slider",function(e){return!n.$element.data("dragging")&&void(t(e.target).is("[data-slider-handle]")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)))}),this.options.draggable){this.handles.addTouch();var s=t("body");e.off("mousedown.zf.slider").on("mousedown.zf.slider",function(o){e.addClass("is-dragging"),n.$fill.addClass("is-dragging"),n.$element.data("dragging",!0),i=t(o.currentTarget),s.on("mousemove.zf.slider",function(t){t.preventDefault(),n._handleEvent(t,i)}).on("mouseup.zf.slider",function(t){n._handleEvent(t,i),e.removeClass("is-dragging"),n.$fill.removeClass("is-dragging"),n.$element.data("dragging",!1),s.off("mousemove.zf.slider mouseup.zf.slider")})}).on("selectstart.zf.slider touchmove.zf.slider",function(t){t.preventDefault()})}e.off("keydown.zf.slider").on("keydown.zf.slider",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,"Slider",{decrease:function(){i=a-n.options.step},increase:function(){i=a+n.options.step},decrease_fast:function(){i=a-10*n.options.step},increase_fast:function(){i=a+10*n.options.step},handled:function(){e.preventDefault(),n._setHandlePos(s,i,!0)}})})}},{key:"destroy",value:function(){this.handles.off(".zf.slider"),this.inputs.off(".zf.slider"),this.$element.off(".zf.slider"),clearTimeout(this.timeout),Foundation.unregisterPlugin(this)}}]),s}();s.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:"disabled",invertVertical:!1,changedDelay:500,nonLinearBase:5,positionValueFunction:"linear"},Foundation.plugin(s,"Slider")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Sticky")}return _createClass(i,[{key:"_init",value:function(){var e=this.$element.parent("[data-sticky-container]"),i=this.$element[0].id||Foundation.GetYoDigits(6,"sticky"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({"data-resize":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one("load.zf.sticky",function(){n.containerHeight="none"==n.$element.css("display")?0:n.$element[0].getBoundingClientRect().height,n.$container.css("height",n.containerHeight),n.elemHeight=n.containerHeight,""!==n.options.anchor?n.$anchor=t("#"+n.options.anchor):n._parsePoints(),n._setSizes(function(){var t=window.pageYOffset;n._calc(!1,t),n.isStuck||n._removeSticky(!(t>=n.topPoint))}),n._events(i.split("-").reverse().join("-"))})}},{key:"_parsePoints",value:function(){for(var e=""==this.options.topAnchor?1:this.options.topAnchor,i=""==this.options.btmAnchor?document.documentElement.scrollHeight:this.options.btmAnchor,n=[e,i],s={},o=0,a=n.length;o<a&&n[o];o++){var r;if("number"==typeof n[o])r=n[o];else{var l=n[o].split(":"),u=t("#"+l[0]);r=u.offset().top,l[1]&&"bottom"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height)}s[o]=r}this.points=s}},{key:"_events",value:function(e){var i=this,n=this.scrollListener="scroll.zf."+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset)})):(i.scrollCount--,i._calc(!1,window.pageYOffset))})),this.$element.off("resizeme.zf.trigger").on("resizeme.zf.trigger",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n)})}))}},{key:"_pauseListeners",value:function(e){this.isOn=!1,t(window).off(e),this.$element.trigger("pause.zf.sticky")}},{key:"_calc",value:function(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1)}},{key:"_setSticky",value:function(){var t=this,e=this.options.stickTo,i="top"===e?"marginTop":"marginBottom",n="top"===e?"bottom":"top",s={};s[i]=this.options[i]+"em",s[e]=0,s[n]="auto",this.isStuck=!0,this.$element.removeClass("is-anchored is-at-"+n).addClass("is-stuck is-at-"+e).css(s).trigger("sticky.zf.stuckto:"+e),this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd",function(){t._setSizes()})}},{key:"_removeSticky",value:function(t){var e=this.options.stickTo,i="top"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?"marginTop":"marginBottom",a=t?"top":"bottom";n[o]=0,n.bottom="auto",t?n.top=0:n.top=s,this.isStuck=!1,this.$element.removeClass("is-stuck is-at-"+e).addClass("is-anchored is-at-"+a).css(n).trigger("sticky.zf.unstuckfrom:"+a)}},{key:"_setSizes",value:function(t){this.canStick=Foundation.MediaQuery.is(this.options.stickyOn),this.canStick||t&&"function"==typeof t&&t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i["padding-left"],10),s=parseInt(i["padding-right"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({"max-width":e-n-s+"px"});var o=this.$element[0].getBoundingClientRect().height||this.containerHeight;if("none"==this.$element.css("display")&&(o=0),this.containerHeight=o,this.$container.css({height:o}),this.elemHeight=o,!this.isStuck&&this.$element.hasClass("is-at-bottom")){var a=(this.points?this.points[1]-this.$container.offset().top:this.anchorHeight)-this.elemHeight;this.$element.css("top",a)}this._setBreakPoints(o,function(){t&&"function"==typeof t&&t()})}},{key:"_setBreakPoints",value:function(t,i){if(!this.canStick){if(!i||"function"!=typeof i)return!1;i()}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;"top"===this.options.stickTo?(o-=n,a-=t+n):"bottom"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&"function"==typeof i&&i()}},{key:"destroy",value:function(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+" is-anchored is-at-top").css({height:"",top:"",bottom:"","max-width":""}).off("resizeme.zf.trigger"),this.$anchor&&this.$anchor.length&&this.$anchor.off("change.zf.sticky"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:""}),Foundation.unregisterPlugin(this)}}]),i}();i.defaults={container:"<div data-sticky-container></div>",stickTo:"top",anchor:"",topAnchor:"",btmAnchor:"",marginTop:1,marginBottom:1,stickyOn:"medium",stickyClass:"sticky",containerClass:"sticky-container",checkEvery:-1},Foundation.plugin(i,"Sticky")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,"Tabs"),Foundation.Keyboard.register("Tabs",{ENTER:"open",SPACE:"open",ARROW_RIGHT:"next",ARROW_UP:"previous",ARROW_DOWN:"next",ARROW_LEFT:"previous"})}return _createClass(e,[{key:"_init",value:function(){var e=this;if(this.$element.attr({role:"tablist"}),this.$tabTitles=this.$element.find("."+this.options.linkClass),this.$tabContent=t('[data-tabs-content="'+this.$element[0].id+'"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find("a"),s=i.hasClass(""+e.options.linkActiveClass),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+"-label",r=t("#"+o);if(i.attr({role:"presentation"}),n.attr({role:"tab","aria-controls":o,"aria-selected":s,id:a}),r.attr({role:"tabpanel","aria-hidden":!s,"aria-labelledby":a}),s&&e.options.autoFocus&&t(window).load(function(){t("html, body").animate({scrollTop:i.offset().top},e.options.deepLinkSmudgeDelay,function(){n.focus()})}),e.options.deepLink){var l=window.location.hash;if(l.length){var n=i.find('[href="'+l+'"]');n.length&&(e.selectTab(t(l)),e.options.deepLinkSmudge&&t(window).load(function(){var n=i.offset();t("html, body").animate({scrollTop:n.top},e.options.deepLinkSmudgeDelay)}),i.trigger("deeplink.zf.tabs",[n,t(l)]))}}}),this.options.matchHeight){var i=this.$tabContent.find("img");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight()}this._events()}},{key:"_events",value:function(){this._addKeyHandler(),this._addClickHandler(),this._setHeightMqHandler=null,this.options.matchHeight&&(this._setHeightMqHandler=this._setHeight.bind(this),t(window).on("changed.zf.mediaquery",this._setHeightMqHandler))}},{key:"_addClickHandler",value:function(){var e=this;this.$element.off("click.zf.tabs").on("click.zf.tabs","."+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),e._handleTabChange(t(this))})}},{key:"_addKeyHandler",value:function(){var e=this;this.$tabTitles.off("keydown.zf.tabs").on("keydown.zf.tabs",function(i){if(9!==i.which){var n,s,o=t(this),a=o.parent("ul").children("li");a.each(function(i){if(t(this).is(o))return void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1))))}),Foundation.Keyboard.handleKey(i,"Tabs",{open:function(){o.find('[role="tab"]').focus(),e._handleTabChange(o)},previous:function(){n.find('[role="tab"]').focus(),e._handleTabChange(n)},next:function(){s.find('[role="tab"]').focus(),e._handleTabChange(s)},handled:function(){i.stopPropagation(),i.preventDefault()}})}})}},{key:"_handleTabChange",value:function(t){if(t.hasClass(""+this.options.linkActiveClass))return void(this.options.activeCollapse&&(this._collapseTab(t),this.$element.trigger("collapse.zf.tabs",[t])));var e=this.$element.find("."+this.options.linkClass+"."+this.options.linkActiveClass),i=t.find('[role="tab"]'),n=i[0].hash,s=this.$tabContent.find(n);if(this._collapseTab(e),this._openTab(t),this.options.deepLink){var o=t.find("a").attr("href");this.options.updateHistory?history.pushState({},"",o):history.replaceState({},"",o)}this.$element.trigger("change.zf.tabs",[t,s]),s.find("[data-mutate]").trigger("mutateme.zf.trigger")}},{key:"_openTab",value:function(t){var e=t.find('[role="tab"]'),i=e[0].hash,n=this.$tabContent.find(i);t.addClass(""+this.options.linkActiveClass),e.attr({"aria-selected":"true"}),n.addClass(""+this.options.panelActiveClass).attr({"aria-hidden":"false"})}},{key:"_collapseTab",value:function(e){var i=e.removeClass(""+this.options.linkActiveClass).find('[role="tab"]').attr({"aria-selected":"false"});t("#"+i.attr("aria-controls")).removeClass(""+this.options.panelActiveClass).attr({"aria-hidden":"true"})}},{key:"selectTab",value:function(t){var e;e="object"==typeof t?t[0].id:t,e.indexOf("#")<0&&(e="#"+e);var i=this.$tabTitles.find('[href="'+e+'"]').parent("."+this.options.linkClass);this._handleTabChange(i)}},{key:"_setHeight",value:function(){var e=0;this.$tabContent.find("."+this.options.panelClass).css("height","").each(function(){var i=t(this),n=i.hasClass(""+this.options.panelActiveClass);n||i.css({visibility:"hidden",display:"block"});var s=this.getBoundingClientRect().height;n||i.css({visibility:"",display:""}),e=s>e?s:e}).css("height",e+"px")}},{key:"destroy",value:function(){this.$element.find("."+this.options.linkClass).off(".zf.tabs").hide().end().find("."+this.options.panelClass).hide(),this.options.matchHeight&&null!=this._setHeightMqHandler&&t(window).off("changed.zf.mediaquery",this._setHeightMqHandler),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={deepLink:!1,deepLinkSmudge:!1,deepLinkSmudgeDelay:300,updateHistory:!1,autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,activeCollapse:!1,linkClass:"tabs-title",linkActiveClass:"is-active",panelClass:"tabs-panel",panelActiveClass:"is-active"},Foundation.plugin(e,"Tabs")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className="",this._init(),this._events(),Foundation.registerPlugin(this,"Toggler")}return _createClass(e,[{key:"_init",value:function(){var e;this.options.animate?(e=this.options.animate.split(" "),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data("toggler"),this.className="."===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open="'+i+'"], [data-close="'+i+'"], [data-toggle="'+i+'"]').attr("aria-controls",i),this.$element.attr("aria-expanded",!this.$element.is(":hidden"))}},{key:"_events",value:function(){this.$element.off("toggle.zf.trigger").on("toggle.zf.trigger",this.toggle.bind(this))}},{key:"toggle",value:function(){this[this.options.animate?"_toggleAnimate":"_toggleClass"]()}},{key:"_toggleClass",value:function(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger("on.zf.toggler"):this.$element.trigger("off.zf.toggler"),this._updateARIA(t),this.$element.find("[data-mutate]").trigger("mutateme.zf.trigger")}},{key:"_toggleAnimate",value:function(){var t=this;this.$element.is(":hidden")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){t._updateARIA(!0),this.trigger("on.zf.toggler"),this.find("[data-mutate]").trigger("mutateme.zf.trigger")}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){t._updateARIA(!1),this.trigger("off.zf.toggler"),this.find("[data-mutate]").trigger("mutateme.zf.trigger")})}},{key:"_updateARIA",value:function(t){this.$element.attr("aria-expanded",!!t)}},{key:"destroy",value:function(){this.$element.off(".zf.toggler"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={animate:!1},Foundation.plugin(e,"Toggler")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,"Tooltip")}return _createClass(e,[{key:"_init",value:function(){var e=this.$element.attr("aria-describedby")||Foundation.GetYoDigits(6,"tooltip");this.options.positionClass=this.options.positionClass||this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr("title"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.options.allowHtml?this.template.appendTo(document.body).html(this.options.tipText).hide():this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:"","aria-describedby":e,"data-yeti-box":e,"data-toggle":e,"data-resize":e}).addClass(this.options.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events()}},{key:"_getPositionClass",value:function(t){if(!t)return"";var e=t[0].className.match(/\b(top|left|right)\b/g);return e=e?e[0]:""}},{key:"_buildTemplate",value:function(e){var i=(this.options.tooltipClass+" "+this.options.positionClass+" "+this.options.templateClasses).trim(),n=t("<div></div>").addClass(i).attr({role:"tooltip","aria-hidden":!0,"data-is-active":!1,"data-is-focus":!1,id:e});return n}},{key:"_reposition",value:function(t){this.usedPositions.push(t?t:"bottom"),!t&&this.usedPositions.indexOf("top")<0?this.template.addClass("top"):"top"===t&&this.usedPositions.indexOf("bottom")<0?this.template.removeClass(t):"left"===t&&this.usedPositions.indexOf("right")<0?this.template.removeClass(t).addClass("right"):"right"===t&&this.usedPositions.indexOf("left")<0?this.template.removeClass(t).addClass("left"):!t&&this.usedPositions.indexOf("top")>-1&&this.usedPositions.indexOf("left")<0?this.template.addClass("left"):"top"===t&&this.usedPositions.indexOf("bottom")>-1&&this.usedPositions.indexOf("left")<0?this.template.removeClass(t).addClass("left"):"left"===t&&this.usedPositions.indexOf("right")>-1&&this.usedPositions.indexOf("bottom")<0?this.template.removeClass(t):"right"===t&&this.usedPositions.indexOf("left")>-1&&this.usedPositions.indexOf("bottom")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--}},{key:"_setPosition",value:function(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n="left"===t?"left":"right"===t?"left":"top",s="top"===n?"height":"width";"height"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,"center bottom",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:"auto"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,"center "+(t||"bottom"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;)this._reposition(t),this._setPosition()}},{key:"show",value:function(){if("all"!==this.options.showOn&&!Foundation.MediaQuery.is(this.options.showOn))return!1;var t=this;this.template.css("visibility","hidden").show(),this._setPosition(),this.$element.trigger("closeme.zf.tooltip",this.template.attr("id")),this.template.attr({"data-is-active":!0,"aria-hidden":!1}),t.isActive=!0,this.template.stop().hide().css("visibility","").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger("show.zf.tooltip")}},{key:"hide",value:function(){var t=this;this.template.stop().attr({"aria-hidden":!0,"data-is-active":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1)}),this.$element.trigger("hide.zf.tooltip")}},{key:"_events",value:function(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on("mouseenter.zf.tooltip",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show()},t.options.hoverDelay))}).on("mouseleave.zf.tooltip",function(i){clearTimeout(t.timeout),(!e||t.isClick&&!t.options.clickOpen)&&t.hide()}),this.options.clickOpen?this.$element.on("mousedown.zf.tooltip",function(e){e.stopImmediatePropagation(),t.isClick||(t.isClick=!0,!t.options.disableHover&&t.$element.attr("tabindex")||t.isActive||t.show())}):this.$element.on("mousedown.zf.tooltip",function(e){e.stopImmediatePropagation(),t.isClick=!0}),this.options.disableForTouch||this.$element.on("tap.zf.tooltip touchend.zf.tooltip",function(e){t.isActive?t.hide():t.show()}),this.$element.on({"close.zf.trigger":this.hide.bind(this)}),this.$element.on("focus.zf.tooltip",function(i){return e=!0,t.isClick?(t.options.clickOpen||(e=!1),!1):void t.show()}).on("focusout.zf.tooltip",function(i){e=!1,t.isClick=!1,t.hide()}).on("resizeme.zf.trigger",function(){t.isActive&&t._setPosition()})}},{key:"toggle",value:function(){this.isActive?this.hide():this.show()}},{key:"destroy",value:function(){this.$element.attr("title",this.template.text()).off(".zf.trigger .zf.tooltip").removeClass("has-tip top right left").removeAttr("aria-describedby aria-haspopup data-disable-hover data-resize data-toggle data-tooltip data-yeti-box"),this.template.remove(),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:"",tooltipClass:"tooltip",triggerClass:"has-tip",showOn:"small",template:"",tipText:"",touchCloseText:"Tap to close.",clickOpen:!0,positionClass:"",vOffset:10,hOffset:12,allowHtml:!1},Foundation.plugin(e,"Tooltip")}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},this.$element.data(),n),this.rules=this.$element.data("responsive-accordion-tabs"),this.currentMq=null,this.currentPlugin=null,this.$element.attr("id")||this.$element.attr("id",Foundation.GetYoDigits(6,"responsiveaccordiontabs")),this._init(),this._events(),Foundation.registerPlugin(this,"ResponsiveAccordionTabs")}return _createClass(e,[{key:"_init",value:function(){if("string"==typeof this.rules){for(var e={},n=this.rules.split(" "),s=0;s<n.length;s++){var o=n[s].split("-"),a=o.length>1?o[0]:"small",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r])}this.rules=e}this._getAllOptions(),t.isEmptyObject(this.rules)||this._checkMediaQueries()}},{key:"_getAllOptions",value:function(){var e=this;e.allOptions={};for(var n in i)if(i.hasOwnProperty(n)){var s=i[n];try{var o=t("<ul></ul>"),a=new s.plugin(o,e.options);for(var r in a.options)if(a.options.hasOwnProperty(r)&&"zfPlugin"!==r){var l=a.options[r];e.allOptions[r]=l}a.destroy()}catch(t){}}}},{key:"_events",value:function(){var e=this;t(window).on("changed.zf.mediaquery",function(){e._checkMediaQueries()})}},{key:"_checkMediaQueries",value:function(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t)}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass)}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&(!this.currentPlugin.$element.data("zfPlugin")&&this.storezfData&&this.currentPlugin.$element.data("zfPlugin",this.storezfData),this.currentPlugin.destroy()),this._handleMarkup(this.rules[e].cssClass),this.currentPlugin=new this.rules[e].plugin(this.$element,{}),this.storezfData=this.currentPlugin.$element.data("zfPlugin")))}},{key:"_handleMarkup",value:function(e){var i=this,n="accordion",s=t("[data-tabs-content="+this.$element.attr("id")+"]");if(s.length&&(n="tabs"),n!==e){var o=i.allOptions.linkClass?i.allOptions.linkClass:"tabs-title",a=i.allOptions.panelClass?i.allOptions.panelClass:"tabs-panel";this.$element.removeAttr("role");var r=this.$element.children("."+o+",[data-accordion-item]").removeClass(o).removeClass("accordion-item").removeAttr("data-accordion-item"),l=r.children("a").removeClass("accordion-title");if("tabs"===n?(s=s.children("."+a).removeClass(a).removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby"),s.children("a").removeAttr("role").removeAttr("aria-controls").removeAttr("aria-selected")):s=r.children("[data-tab-content]").removeClass("accordion-content"),s.css({display:"",visibility:""}),r.css({display:"",visibility:""}),"accordion"===e)s.each(function(e,n){t(n).appendTo(r.get(e)).addClass("accordion-content").attr("data-tab-content","").removeClass("is-active").css({height:""}),t("[data-tabs-content="+i.$element.attr("id")+"]").after('<div id="tabs-placeholder-'+i.$element.attr("id")+'"></div>').remove(),r.addClass("accordion-item").attr("data-accordion-item",""),l.addClass("accordion-title")});else if("tabs"===e){var u=t("[data-tabs-content="+i.$element.attr("id")+"]"),d=t("#tabs-placeholder-"+i.$element.attr("id"));d.length?(u=t('<div class="tabs-content"></div>').insertAfter(d).attr("data-tabs-content",i.$element.attr("id")),d.remove()):u=t('<div class="tabs-content"></div>').insertAfter(i.$element).attr("data-tabs-content",i.$element.attr("id")),s.each(function(e,i){var n=t(i).appendTo(u).addClass(a),s=l.get(e).hash.slice(1),o=t(i).attr("id")||Foundation.GetYoDigits(6,"accordion");s!==o&&(""!==s?t(i).attr("id",s):(s=o,t(i).attr("id",s),t(l.get(e)).attr("href",t(l.get(e)).attr("href").replace("#","")+"#"+s)));var d=t(r.get(e)).hasClass("is-active");d&&n.addClass("is-active")}),r.addClass(o)}}}},{key:"destroy",value:function(){this.currentPlugin&&this.currentPlugin.destroy(),t(window).off(".zf.ResponsiveAccordionTabs"),Foundation.unregisterPlugin(this)}}]),e}();e.defaults={};var i={tabs:{cssClass:"tabs",plugin:Foundation._plugins.tabs||null},accordion:{cssClass:"accordion",plugin:Foundation._plugins.accordion||null}};Foundation.plugin(e,"ResponsiveAccordionTabs")}(jQuery);

/***/ },
/* 4 */
/***/ function(module, exports) {

module.exports = "/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n"

/***/ },
/* 5 */
/***/ function(module, exports) {

module.exports = "/**\n * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).\n * @version v4.0.4\n * @link https://github.com/ten1seven/what-input\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"whatInput\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"whatInput\"] = factory();\n\telse\n\t\troot[\"whatInput\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\tmodule.exports = (function() {\n\n\t  /*\n\t    ---------------\n\t    Variables\n\t    ---------------\n\t  */\n\n\t  // cache document.documentElement\n\t  var docElem = document.documentElement;\n\n\t  // last used input type\n\t  var currentInput = 'initial';\n\n\t  // last used input intent\n\t  var currentIntent = null;\n\n\t  // form input types\n\t  var formInputs = [\n\t    'input',\n\t    'select',\n\t    'textarea'\n\t  ];\n\n\t  // list of modifier keys commonly used with the mouse and\n\t  // can be safely ignored to prevent false keyboard detection\n\t  var ignoreMap = [\n\t    16, // shift\n\t    17, // control\n\t    18, // alt\n\t    91, // Windows key / left Apple cmd\n\t    93  // Windows menu / right Apple cmd\n\t  ];\n\n\t  // mapping of events to input types\n\t  var inputMap = {\n\t    'keyup': 'keyboard',\n\t    'mousedown': 'mouse',\n\t    'mousemove': 'mouse',\n\t    'MSPointerDown': 'pointer',\n\t    'MSPointerMove': 'pointer',\n\t    'pointerdown': 'pointer',\n\t    'pointermove': 'pointer',\n\t    'touchstart': 'touch'\n\t  };\n\n\t  // array of all used input types\n\t  var inputTypes = [];\n\n\t  // boolean: true if touch buffer timer is running\n\t  var isBuffering = false;\n\n\t  // map of IE 10 pointer events\n\t  var pointerMap = {\n\t    2: 'touch',\n\t    3: 'touch', // treat pen like touch\n\t    4: 'mouse'\n\t  };\n\n\t  // touch buffer timer\n\t  var touchTimer = null;\n\n\n\t  /*\n\t    ---------------\n\t    Set up\n\t    ---------------\n\t  */\n\n\t  var setUp = function() {\n\n\t    // add correct mouse wheel event mapping to `inputMap`\n\t    inputMap[detectWheel()] = 'mouse';\n\n\t    addListeners();\n\t    setInput();\n\t  };\n\n\n\t  /*\n\t    ---------------\n\t    Events\n\t    ---------------\n\t  */\n\n\t  var addListeners = function() {\n\n\t    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding\n\t    // can only demonstrate potential, but not actual, interaction\n\t    // and are treated separately\n\n\t    // pointer events (mouse, pen, touch)\n\t    if (window.PointerEvent) {\n\t      docElem.addEventListener('pointerdown', updateInput);\n\t      docElem.addEventListener('pointermove', setIntent);\n\t    } else if (window.MSPointerEvent) {\n\t      docElem.addEventListener('MSPointerDown', updateInput);\n\t      docElem.addEventListener('MSPointerMove', setIntent);\n\t    } else {\n\n\t      // mouse events\n\t      docElem.addEventListener('mousedown', updateInput);\n\t      docElem.addEventListener('mousemove', setIntent);\n\n\t      // touch events\n\t      if ('ontouchstart' in window) {\n\t        docElem.addEventListener('touchstart', touchBuffer);\n\t      }\n\t    }\n\n\t    // mouse wheel\n\t    docElem.addEventListener(detectWheel(), setIntent);\n\n\t    // keyboard events\n\t    docElem.addEventListener('keydown', updateInput);\n\t    docElem.addEventListener('keyup', updateInput);\n\t  };\n\n\t  // checks conditions before updating new input\n\t  var updateInput = function(event) {\n\n\t    // only execute if the touch buffer timer isn't running\n\t    if (!isBuffering) {\n\t      var eventKey = event.which;\n\t      var value = inputMap[event.type];\n\t      if (value === 'pointer') value = pointerType(event);\n\n\t      if (\n\t        currentInput !== value ||\n\t        currentIntent !== value\n\t      ) {\n\n\t        var activeInput = (\n\t          document.activeElement &&\n\t          formInputs.indexOf(document.activeElement.nodeName.toLowerCase()) === -1\n\t        ) ? true : false;\n\n\t        if (\n\t          value === 'touch' ||\n\n\t          // ignore mouse modifier keys\n\t          (value === 'mouse' && ignoreMap.indexOf(eventKey) === -1) ||\n\n\t          // don't switch if the current element is a form input\n\t          (value === 'keyboard' && activeInput)\n\t        ) {\n\n\t          // set the current and catch-all variable\n\t          currentInput = currentIntent = value;\n\n\t          setInput();\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  // updates the doc and `inputTypes` array with new input\n\t  var setInput = function() {\n\t    docElem.setAttribute('data-whatinput', currentInput);\n\t    docElem.setAttribute('data-whatintent', currentInput);\n\n\t    if (inputTypes.indexOf(currentInput) === -1) {\n\t      inputTypes.push(currentInput);\n\t      docElem.className += ' whatinput-types-' + currentInput;\n\t    }\n\t  };\n\n\t  // updates input intent for `mousemove` and `pointermove`\n\t  var setIntent = function(event) {\n\n\t    // only execute if the touch buffer timer isn't running\n\t    if (!isBuffering) {\n\t      var value = inputMap[event.type];\n\t      if (value === 'pointer') value = pointerType(event);\n\n\t      if (currentIntent !== value) {\n\t        currentIntent = value;\n\n\t        docElem.setAttribute('data-whatintent', currentIntent);\n\t      }\n\t    }\n\t  };\n\n\t  // buffers touch events because they frequently also fire mouse events\n\t  var touchBuffer = function(event) {\n\n\t    // clear the timer if it happens to be running\n\t    window.clearTimeout(touchTimer);\n\n\t    // set the current input\n\t    updateInput(event);\n\n\t    // set the isBuffering to `true`\n\t    isBuffering = true;\n\n\t    // run the timer\n\t    touchTimer = window.setTimeout(function() {\n\n\t      // if the timer runs out, set isBuffering back to `false`\n\t      isBuffering = false;\n\t    }, 200);\n\t  };\n\n\n\t  /*\n\t    ---------------\n\t    Utilities\n\t    ---------------\n\t  */\n\n\t  var pointerType = function(event) {\n\t   if (typeof event.pointerType === 'number') {\n\t      return pointerMap[event.pointerType];\n\t   } else {\n\t      return (event.pointerType === 'pen') ? 'touch' : event.pointerType; // treat pen like touch\n\t   }\n\t  };\n\n\t  // detect version of mouse wheel event to use\n\t  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n\t  var detectWheel = function() {\n\t    return 'onwheel' in document.createElement('div') ?\n\t      'wheel' : // Modern browsers support \"wheel\"\n\n\t      document.onmousewheel !== undefined ?\n\t        'mousewheel' : // Webkit and IE support at least \"mousewheel\"\n\t        'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox\n\t  };\n\n\n\t  /*\n\t    ---------------\n\t    Init\n\n\t    don't start script unless browser cuts the mustard\n\t    (also passes if polyfills are used)\n\t    ---------------\n\t  */\n\n\t  if (\n\t    'addEventListener' in window &&\n\t    Array.prototype.indexOf\n\t  ) {\n\t    setUp();\n\t  }\n\n\n\t  /*\n\t    ---------------\n\t    API\n\t    ---------------\n\t  */\n\n\t  return {\n\n\t    // returns string: the current input type\n\t    // opt: 'loose'|'strict'\n\t    // 'strict' (default): returns the same value as the `data-whatinput` attribute\n\t    // 'loose': includes `data-whatintent` value if it's more current than `data-whatinput`\n\t    ask: function(opt) { return (opt === 'loose') ? currentIntent : currentInput; },\n\n\t    // returns array: all the detected input types\n\t    types: function() { return inputTypes; }\n\n\t  };\n\n\t}());\n\n\n/***/ }\n/******/ ])\n});\n;"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(0)(__webpack_require__(4))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(0)(__webpack_require__(5))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(2);


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmMxNjViZTk5OGYzZTgxMDUyMzkiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzIiwid2VicGFjazovLy8uL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP2I1ZDkiLCJ3ZWJwYWNrOi8vLy4vfi93aGF0LWlucHV0L2Rpc3Qvd2hhdC1pbnB1dC5qcz8zNzJhIl0sIm5hbWVzIjpbInJlcXVpcmUiLCIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImZvdW5kYXRpb24iXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7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QUFZLHNJQUFzSSxvQ0FBb0MsdUtBQXVLLGtFQUFrRSxnRUFBZ0UsOEdBQThHLHNUQUFzVCxpRUFBaUUsbVFBQW1RLGtFQUFrRSx1RkFBdUYsOERBQThELHdGQUF3Rix5REFBeUQsZ0hBQWdILDBHQUEwRyx5QkFBeUIsbUJBQW1CLFFBQVEsdUhBQXVILGtSQUFrUiwrREFBK0QsNkRBQTZELFNBQVMsa0NBQWtDLGlFQUFpRSwrREFBK0QsU0FBUyxPQUFPLHdGQUF3RiwyREFBMkQsb0VBQW9FLGdFQUFnRSxXQUFXLFNBQVMsbUZBQW1GLHFGQUFxRix1REFBdUQsUUFBUSwrRkFBK0YsNEZBQTRGLHFDQUFxQywyQ0FBMkMsOERBQThELHFHQUFxRywyTEFBMkwsbVRBQW1ULDRHQUE0RywyQkFBMkIsYUFBYSxXQUFXLFNBQVMsUUFBUSxpR0FBaUcsNkRBQTZELDhEQUE4RCx3REFBd0Qsd0NBQXdDLGtFQUFrRSxTQUFTLFFBQVEsd0dBQXdHLDRGQUE0RiwyQ0FBMkMsOERBQThELDBDQUEwQyxrQ0FBa0MscUVBQXFFLFdBQVcsU0FBUyxRQUFRLHVIQUF1SCxnR0FBZ0csNkRBQTZELHFFQUFxRSw2RUFBNkUsbUdBQW1HLFNBQVMsT0FBTyxRQUFRLDhIQUE4SCxtREFBbUQsK0NBQStDLFFBQVEsT0FBTyw2RUFBNkUsZ0NBQWdDLFFBQVEsK0pBQStKLDRRQUE0USxrRUFBa0UsZ1JBQWdSLGdCQUFnQixPQUFPLDZGQUE2RixxU0FBcVMseURBQXlELEVBQUUsb0ZBQW9GLG1CQUFtQixFQUFFLFVBQVUsT0FBTyxJQUFJLGFBQWEsZ0JBQWdCLEVBQUUsR0FBRyxDOzs7Ozs7QUNBM2tTLDhDOzs7Ozs7QUNBQSw4QyIsImZpbGUiOiJwdWJsaWMvanMvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi4vXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZmMxNjViZTk5OGYzZTgxMDUyMzkiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWpxdWVyeSc7XG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhd2hhdC1pbnB1dCc7XG5yZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL2ZvdW5kYXRpb24ubWluJyk7XG5cbiQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcbiAgJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbWFpbi5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY3NzL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9IWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCl7aWYodm9pZCAwPT09RnVuY3Rpb24ucHJvdG90eXBlLm5hbWUpe3ZhciBlPS9mdW5jdGlvblxccyhbXihdezEsfSlcXCgvLGk9ZS5leGVjKHQudG9TdHJpbmcoKSk7cmV0dXJuIGkmJmkubGVuZ3RoPjE/aVsxXS50cmltKCk6XCJcIn1yZXR1cm4gdm9pZCAwPT09dC5wcm90b3R5cGU/dC5jb25zdHJ1Y3Rvci5uYW1lOnQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9ZnVuY3Rpb24gaSh0KXtyZXR1cm5cInRydWVcIj09PXR8fFwiZmFsc2VcIiE9PXQmJihpc05hTigxKnQpP3Q6cGFyc2VGbG9hdCh0KSl9ZnVuY3Rpb24gbih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKX12YXIgcz1cIjYuMy4wXCIsbz17dmVyc2lvbjpzLF9wbHVnaW5zOnt9LF91dWlkczpbXSxydGw6ZnVuY3Rpb24oKXtyZXR1cm5cInJ0bFwiPT09dChcImh0bWxcIikuYXR0cihcImRpclwiKX0scGx1Z2luOmZ1bmN0aW9uKHQsaSl7dmFyIHM9aXx8ZSh0KSxvPW4ocyk7dGhpcy5fcGx1Z2luc1tvXT10aGlzW3NdPXR9LHJlZ2lzdGVyUGx1Z2luOmZ1bmN0aW9uKHQsaSl7dmFyIHM9aT9uKGkpOmUodC5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTt0LnV1aWQ9dGhpcy5HZXRZb0RpZ2l0cyg2LHMpLHQuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIrcyl8fHQuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIrcyx0LnV1aWQpLHQuJGVsZW1lbnQuZGF0YShcInpmUGx1Z2luXCIpfHx0LiRlbGVtZW50LmRhdGEoXCJ6ZlBsdWdpblwiLHQpLHQuJGVsZW1lbnQudHJpZ2dlcihcImluaXQuemYuXCIrcyksdGhpcy5fdXVpZHMucHVzaCh0LnV1aWQpfSx1bnJlZ2lzdGVyUGx1Z2luOmZ1bmN0aW9uKHQpe3ZhciBpPW4oZSh0LiRlbGVtZW50LmRhdGEoXCJ6ZlBsdWdpblwiKS5jb25zdHJ1Y3RvcikpO3RoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHQudXVpZCksMSksdC4kZWxlbWVudC5yZW1vdmVBdHRyKFwiZGF0YS1cIitpKS5yZW1vdmVEYXRhKFwiemZQbHVnaW5cIikudHJpZ2dlcihcImRlc3Ryb3llZC56Zi5cIitpKTtmb3IodmFyIHMgaW4gdCl0W3NdPW51bGx9LHJlSW5pdDpmdW5jdGlvbihlKXt2YXIgaT1lIGluc3RhbmNlb2YgdDt0cnl7aWYoaSllLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmRhdGEoXCJ6ZlBsdWdpblwiKS5faW5pdCgpfSk7ZWxzZXt2YXIgcz10eXBlb2YgZSxvPXRoaXMsYT17b2JqZWN0OmZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlPW4oZSksdChcIltkYXRhLVwiK2UrXCJdXCIpLmZvdW5kYXRpb24oXCJfaW5pdFwiKX0pfSxzdHJpbmc6ZnVuY3Rpb24oKXtlPW4oZSksdChcIltkYXRhLVwiK2UrXCJdXCIpLmZvdW5kYXRpb24oXCJfaW5pdFwiKX0sdW5kZWZpbmVkOmZ1bmN0aW9uKCl7dGhpcy5vYmplY3QoT2JqZWN0LmtleXMoby5fcGx1Z2lucykpfX07YVtzXShlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KX1maW5hbGx5e3JldHVybiBlfX0sR2V0WW9EaWdpdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD10fHw2LE1hdGgucm91bmQoTWF0aC5wb3coMzYsdCsxKS1NYXRoLnJhbmRvbSgpKk1hdGgucG93KDM2LHQpKS50b1N0cmluZygzNikuc2xpY2UoMSkrKGU/XCItXCIrZTpcIlwiKX0scmVmbG93OmZ1bmN0aW9uKGUsbil7XCJ1bmRlZmluZWRcIj09dHlwZW9mIG4/bj1PYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTpcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49W25dKTt2YXIgcz10aGlzO3QuZWFjaChuLGZ1bmN0aW9uKG4sbyl7dmFyIGE9cy5fcGx1Z2luc1tvXSxyPXQoZSkuZmluZChcIltkYXRhLVwiK28rXCJdXCIpLmFkZEJhY2soXCJbZGF0YS1cIitvK1wiXVwiKTtyLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLG49e307aWYoZS5kYXRhKFwiemZQbHVnaW5cIikpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcIitvK1wiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtpZihlLmF0dHIoXCJkYXRhLW9wdGlvbnNcIikpe2UuYXR0cihcImRhdGEtb3B0aW9uc1wiKS5zcGxpdChcIjtcIikuZm9yRWFjaChmdW5jdGlvbih0LGUpe3ZhciBzPXQuc3BsaXQoXCI6XCIpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCl9KTtzWzBdJiYobltzWzBdXT1pKHNbMV0pKX0pfXRyeXtlLmRhdGEoXCJ6ZlBsdWdpblwiLG5ldyBhKHQodGhpcyksbikpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IodCl9ZmluYWxseXtyZXR1cm59fSl9KX0sZ2V0Rm5OYW1lOmUsdHJhbnNpdGlvbmVuZDpmdW5jdGlvbih0KXt2YXIgZSxpPXt0cmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwiLFdlYmtpdFRyYW5zaXRpb246XCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm90cmFuc2l0aW9uZW5kXCJ9LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IodmFyIHMgaW4gaSlcInVuZGVmaW5lZFwiIT10eXBlb2Ygbi5zdHlsZVtzXSYmKGU9aVtzXSk7cmV0dXJuIGU/ZTooZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC50cmlnZ2VySGFuZGxlcihcInRyYW5zaXRpb25lbmRcIixbdF0pfSwxKSxcInRyYW5zaXRpb25lbmRcIil9fTtvLnV0aWw9e3Rocm90dGxlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bnVsbDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzLHM9YXJndW1lbnRzO251bGw9PT1pJiYoaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5hcHBseShuLHMpLGk9bnVsbH0sZSkpfX19O3ZhciBhPWZ1bmN0aW9uKGkpe3ZhciBuPXR5cGVvZiBpLHM9dChcIm1ldGEuZm91bmRhdGlvbi1tcVwiKSxhPXQoXCIubm8tanNcIik7aWYocy5sZW5ndGh8fHQoJzxtZXRhIGNsYXNzPVwiZm91bmRhdGlvbi1tcVwiPicpLmFwcGVuZFRvKGRvY3VtZW50LmhlYWQpLGEubGVuZ3RoJiZhLnJlbW92ZUNsYXNzKFwibm8tanNcIiksXCJ1bmRlZmluZWRcIj09PW4pby5NZWRpYVF1ZXJ5Ll9pbml0KCksby5yZWZsb3codGhpcyk7ZWxzZXtpZihcInN0cmluZ1wiIT09bil0aHJvdyBuZXcgVHlwZUVycm9yKFwiV2UncmUgc29ycnksIFwiK24rXCIgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLlwiKTt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbD10aGlzLmRhdGEoXCJ6ZlBsdWdpblwiKTtpZih2b2lkIDA9PT1sfHx2b2lkIDA9PT1sW2ldKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIldlJ3JlIHNvcnJ5LCAnXCIraStcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFwiKyhsP2UobCk6XCJ0aGlzIGVsZW1lbnRcIikrXCIuXCIpOzE9PT10aGlzLmxlbmd0aD9sW2ldLmFwcGx5KGwscik6dGhpcy5lYWNoKGZ1bmN0aW9uKGUsbil7bFtpXS5hcHBseSh0KG4pLmRhdGEoXCJ6ZlBsdWdpblwiKSxyKX0pfXJldHVybiB0aGlzfTt3aW5kb3cuRm91bmRhdGlvbj1vLHQuZm4uZm91bmRhdGlvbj1hLGZ1bmN0aW9uKCl7RGF0ZS5ub3cmJndpbmRvdy5EYXRlLm5vd3x8KHdpbmRvdy5EYXRlLm5vdz1EYXRlLm5vdz1mdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfSk7Zm9yKHZhciB0PVtcIndlYmtpdFwiLFwibW96XCJdLGU9MDtlPHQubGVuZ3RoJiYhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsrK2Upe3ZhciBpPXRbZV07d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT13aW5kb3dbaStcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9d2luZG93W2krXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXXx8d2luZG93W2krXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl19aWYoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KXx8IXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpe3ZhciBuPTA7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbih0KXt2YXIgZT1EYXRlLm5vdygpLGk9TWF0aC5tYXgobisxNixlKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3Qobj1pKX0saS1lKX0sd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lPWNsZWFyVGltZW91dH13aW5kb3cucGVyZm9ybWFuY2UmJndpbmRvdy5wZXJmb3JtYW5jZS5ub3d8fCh3aW5kb3cucGVyZm9ybWFuY2U9e3N0YXJ0OkRhdGUubm93KCksbm93OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCktdGhpcy5zdGFydH19KX0oKSxGdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxpPXRoaXMsbj1mdW5jdGlvbigpe30scz1mdW5jdGlvbigpe3JldHVybiBpLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBuP3RoaXM6dCxlLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O3JldHVybiB0aGlzLnByb3RvdHlwZSYmKG4ucHJvdG90eXBlPXRoaXMucHJvdG90eXBlKSxzLnByb3RvdHlwZT1uZXcgbixzfSl9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLG4scyl7dmFyIG8sYSxyLGwsdT1pKHQpO2lmKGUpe3ZhciBkPWkoZSk7YT11Lm9mZnNldC50b3ArdS5oZWlnaHQ8PWQuaGVpZ2h0K2Qub2Zmc2V0LnRvcCxvPXUub2Zmc2V0LnRvcD49ZC5vZmZzZXQudG9wLHI9dS5vZmZzZXQubGVmdD49ZC5vZmZzZXQubGVmdCxsPXUub2Zmc2V0LmxlZnQrdS53aWR0aDw9ZC53aWR0aCtkLm9mZnNldC5sZWZ0fWVsc2UgYT11Lm9mZnNldC50b3ArdS5oZWlnaHQ8PXUud2luZG93RGltcy5oZWlnaHQrdS53aW5kb3dEaW1zLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PXUud2luZG93RGltcy5vZmZzZXQudG9wLHI9dS5vZmZzZXQubGVmdD49dS53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD11LndpbmRvd0RpbXMud2lkdGg7dmFyIGg9W2EsbyxyLGxdO3JldHVybiBuP3I9PT1sPT0hMDpzP289PT1hPT0hMDpoLmluZGV4T2YoITEpPT09LTF9ZnVuY3Rpb24gaSh0LGUpe2lmKHQ9dC5sZW5ndGg/dFswXTp0LHQ9PT13aW5kb3d8fHQ9PT1kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlwiKTt2YXIgaT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49dC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9ZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxvPXdpbmRvdy5wYWdlWU9mZnNldCxhPXdpbmRvdy5wYWdlWE9mZnNldDtyZXR1cm57d2lkdGg6aS53aWR0aCxoZWlnaHQ6aS5oZWlnaHQsb2Zmc2V0Ont0b3A6aS50b3ArbyxsZWZ0OmkubGVmdCthfSxwYXJlbnREaW1zOnt3aWR0aDpuLndpZHRoLGhlaWdodDpuLmhlaWdodCxvZmZzZXQ6e3RvcDpuLnRvcCtvLGxlZnQ6bi5sZWZ0K2F9fSx3aW5kb3dEaW1zOnt3aWR0aDpzLndpZHRoLGhlaWdodDpzLmhlaWdodCxvZmZzZXQ6e3RvcDpvLGxlZnQ6YX19fX1mdW5jdGlvbiBuKHQsZSxuLHMsbyxhKXt2YXIgcj1pKHQpLGw9ZT9pKGUpOm51bGw7c3dpdGNoKG4pe2Nhc2VcInRvcFwiOnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/bC5vZmZzZXQubGVmdC1yLndpZHRoK2wud2lkdGg6bC5vZmZzZXQubGVmdCx0b3A6bC5vZmZzZXQudG9wLShyLmhlaWdodCtzKX07Y2FzZVwibGVmdFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQtKHIud2lkdGgrbyksdG9wOmwub2Zmc2V0LnRvcH07Y2FzZVwicmlnaHRcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrbyx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXCJjZW50ZXIgdG9wXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoLzItci53aWR0aC8yLHRvcDpsLm9mZnNldC50b3AtKHIuaGVpZ2h0K3MpfTtjYXNlXCJjZW50ZXIgYm90dG9tXCI6cmV0dXJue2xlZnQ6YT9vOmwub2Zmc2V0LmxlZnQrbC53aWR0aC8yLXIud2lkdGgvMix0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0K3N9O2Nhc2VcImNlbnRlciBsZWZ0XCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVwiY2VudGVyIHJpZ2h0XCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoK28rMSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVwiY2VudGVyXCI6cmV0dXJue2xlZnQ6ci53aW5kb3dEaW1zLm9mZnNldC5sZWZ0K3Iud2luZG93RGltcy53aWR0aC8yLXIud2lkdGgvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arci53aW5kb3dEaW1zLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcInJldmVhbFwiOnJldHVybntsZWZ0OihyLndpbmRvd0RpbXMud2lkdGgtci53aWR0aCkvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arc307Y2FzZVwicmV2ZWFsIGZ1bGxcIjpyZXR1cm57bGVmdDpyLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsdG9wOnIud2luZG93RGltcy5vZmZzZXQudG9wfTtjYXNlXCJsZWZ0IGJvdHRvbVwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodCtzfTtjYXNlXCJyaWdodCBib3R0b21cIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrby1yLndpZHRoLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307ZGVmYXVsdDpyZXR1cm57bGVmdDpGb3VuZGF0aW9uLnJ0bCgpP2wub2Zmc2V0LmxlZnQtci53aWR0aCtsLndpZHRoOmwub2Zmc2V0LmxlZnQrbyx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0K3N9fX1Gb3VuZGF0aW9uLkJveD17SW1Ob3RUb3VjaGluZ1lvdTplLEdldERpbWVuc2lvbnM6aSxHZXRPZmZzZXRzOm59fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciBlPXt9O2Zvcih2YXIgaSBpbiB0KWVbdFtpXV09dFtpXTtyZXR1cm4gZX12YXIgaT17OTpcIlRBQlwiLDEzOlwiRU5URVJcIiwyNzpcIkVTQ0FQRVwiLDMyOlwiU1BBQ0VcIiwzNzpcIkFSUk9XX0xFRlRcIiwzODpcIkFSUk9XX1VQXCIsMzk6XCJBUlJPV19SSUdIVFwiLDQwOlwiQVJST1dfRE9XTlwifSxuPXt9LHM9e2tleXM6ZShpKSxwYXJzZUtleTpmdW5jdGlvbih0KXt2YXIgZT1pW3Qud2hpY2h8fHQua2V5Q29kZV18fFN0cmluZy5mcm9tQ2hhckNvZGUodC53aGljaCkudG9VcHBlckNhc2UoKTtyZXR1cm4gZT1lLnJlcGxhY2UoL1xcVysvLFwiXCIpLHQuc2hpZnRLZXkmJihlPVwiU0hJRlRfXCIrZSksdC5jdHJsS2V5JiYoZT1cIkNUUkxfXCIrZSksdC5hbHRLZXkmJihlPVwiQUxUX1wiK2UpLGU9ZS5yZXBsYWNlKC9fJC8sXCJcIil9LGhhbmRsZUtleTpmdW5jdGlvbihlLGkscyl7dmFyIG8sYSxyLGw9bltpXSx1PXRoaXMucGFyc2VLZXkoZSk7aWYoIWwpcmV0dXJuIGNvbnNvbGUud2FybihcIkNvbXBvbmVudCBub3QgZGVmaW5lZCFcIik7aWYobz1cInVuZGVmaW5lZFwiPT10eXBlb2YgbC5sdHI/bDpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKHt9LGwubHRyLGwucnRsKTp0LmV4dGVuZCh7fSxsLnJ0bCxsLmx0ciksYT1vW3VdLHI9c1thXSxyJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByKXt2YXIgZD1yLmFwcGx5KCk7KHMuaGFuZGxlZHx8XCJmdW5jdGlvblwiPT10eXBlb2Ygcy5oYW5kbGVkKSYmcy5oYW5kbGVkKGQpfWVsc2Uocy51bmhhbmRsZWR8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHMudW5oYW5kbGVkKSYmcy51bmhhbmRsZWQoKX0sZmluZEZvY3VzYWJsZTpmdW5jdGlvbihlKXtyZXR1cm4hIWUmJmUuZmluZChcImFbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV1cIikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuISghdCh0aGlzKS5pcyhcIjp2aXNpYmxlXCIpfHx0KHRoaXMpLmF0dHIoXCJ0YWJpbmRleFwiKTwwKX0pfSxyZWdpc3RlcjpmdW5jdGlvbih0LGUpe25bdF09ZX0sdHJhcEZvY3VzOmZ1bmN0aW9uKHQpe3ZhciBlPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0KSxpPWUuZXEoMCksbj1lLmVxKC0xKTt0Lm9uKFwia2V5ZG93bi56Zi50cmFwZm9jdXNcIixmdW5jdGlvbih0KXt0LnRhcmdldD09PW5bMF0mJlwiVEFCXCI9PT1Gb3VuZGF0aW9uLktleWJvYXJkLnBhcnNlS2V5KHQpPyh0LnByZXZlbnREZWZhdWx0KCksaS5mb2N1cygpKTp0LnRhcmdldD09PWlbMF0mJlwiU0hJRlRfVEFCXCI9PT1Gb3VuZGF0aW9uLktleWJvYXJkLnBhcnNlS2V5KHQpJiYodC5wcmV2ZW50RGVmYXVsdCgpLG4uZm9jdXMoKSl9KX0scmVsZWFzZUZvY3VzOmZ1bmN0aW9uKHQpe3Qub2ZmKFwia2V5ZG93bi56Zi50cmFwZm9jdXNcIil9fTtGb3VuZGF0aW9uLktleWJvYXJkPXN9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9e307cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIHQ/ZToodD10LnRyaW0oKS5zbGljZSgxLC0xKSk/ZT10LnNwbGl0KFwiJlwiKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgaT1lLnJlcGxhY2UoL1xcKy9nLFwiIFwiKS5zcGxpdChcIj1cIiksbj1pWzBdLHM9aVsxXTtyZXR1cm4gbj1kZWNvZGVVUklDb21wb25lbnQobikscz12b2lkIDA9PT1zP251bGw6ZGVjb2RlVVJJQ29tcG9uZW50KHMpLHQuaGFzT3duUHJvcGVydHkobik/QXJyYXkuaXNBcnJheSh0W25dKT90W25dLnB1c2gocyk6dFtuXT1bdFtuXSxzXTp0W25dPXMsdH0se30pOmV9dmFyIGk9e3F1ZXJpZXM6W10sY3VycmVudDpcIlwiLF9pbml0OmZ1bmN0aW9uKCl7dmFyIGksbj10aGlzLHM9dChcIi5mb3VuZGF0aW9uLW1xXCIpLmNzcyhcImZvbnQtZmFtaWx5XCIpO2k9ZShzKTtmb3IodmFyIG8gaW4gaSlpLmhhc093blByb3BlcnR5KG8pJiZuLnF1ZXJpZXMucHVzaCh7bmFtZTpvLHZhbHVlOlwib25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IFwiK2lbb10rXCIpXCJ9KTt0aGlzLmN1cnJlbnQ9dGhpcy5fZ2V0Q3VycmVudFNpemUoKSx0aGlzLl93YXRjaGVyKCl9LGF0TGVhc3Q6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXQodCk7cmV0dXJuISFlJiZ3aW5kb3cubWF0Y2hNZWRpYShlKS5tYXRjaGVzfSxpczpmdW5jdGlvbih0KXtyZXR1cm4gdD10LnRyaW0oKS5zcGxpdChcIiBcIiksdC5sZW5ndGg+MSYmXCJvbmx5XCI9PT10WzFdP3RbMF09PT10aGlzLl9nZXRDdXJyZW50U2l6ZSgpOnRoaXMuYXRMZWFzdCh0WzBdKX0sZ2V0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0aGlzLnF1ZXJpZXMpaWYodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGUpKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07aWYodD09PWkubmFtZSlyZXR1cm4gaS52YWx1ZX1yZXR1cm4gbnVsbH0sX2dldEN1cnJlbnRTaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGU9MDtlPHRoaXMucXVlcmllcy5sZW5ndGg7ZSsrKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS52YWx1ZSkubWF0Y2hlcyYmKHQ9aSl9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/dC5uYW1lOnR9LF93YXRjaGVyOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0KHdpbmRvdykub24oXCJyZXNpemUuemYubWVkaWFxdWVyeVwiLGZ1bmN0aW9uKCl7dmFyIGk9ZS5fZ2V0Q3VycmVudFNpemUoKSxuPWUuY3VycmVudDtpIT09biYmKGUuY3VycmVudD1pLHQod2luZG93KS50cmlnZ2VyKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsW2ksbl0pKX0pfX07Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5PWksd2luZG93Lm1hdGNoTWVkaWF8fCh3aW5kb3cubWF0Y2hNZWRpYT1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PXdpbmRvdy5zdHlsZU1lZGlhfHx3aW5kb3cubWVkaWE7aWYoIXQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxpPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpWzBdLG49bnVsbDtlLnR5cGU9XCJ0ZXh0L2Nzc1wiLGUuaWQ9XCJtYXRjaG1lZGlhanMtdGVzdFwiLGkmJmkucGFyZW50Tm9kZSYmaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGkpLG49XCJnZXRDb21wdXRlZFN0eWxlXCJpbiB3aW5kb3cmJndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCl8fGUuY3VycmVudFN0eWxlLHQ9e21hdGNoTWVkaXVtOmZ1bmN0aW9uKHQpe3ZhciBpPVwiQG1lZGlhIFwiK3QrXCJ7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfVwiO3JldHVybiBlLnN0eWxlU2hlZXQ/ZS5zdHlsZVNoZWV0LmNzc1RleHQ9aTplLnRleHRDb250ZW50PWksXCIxcHhcIj09PW4ud2lkdGh9fX1yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue21hdGNoZXM6dC5tYXRjaE1lZGl1bShlfHxcImFsbFwiKSxtZWRpYTplfHxcImFsbFwifX19KCkpLEZvdW5kYXRpb24uTWVkaWFRdWVyeT1pfShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxpKXtmdW5jdGlvbiBuKHIpe2F8fChhPXIpLG89ci1hLGkuYXBwbHkoZSksbzx0P3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuLGUpOih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocyksZS50cmlnZ2VyKFwiZmluaXNoZWQuemYuYW5pbWF0ZVwiLFtlXSkudHJpZ2dlckhhbmRsZXIoXCJmaW5pc2hlZC56Zi5hbmltYXRlXCIsW2VdKSl9dmFyIHMsbyxhPW51bGw7cmV0dXJuIDA9PT10PyhpLmFwcGx5KGUpLHZvaWQgZS50cmlnZ2VyKFwiZmluaXNoZWQuemYuYW5pbWF0ZVwiLFtlXSkudHJpZ2dlckhhbmRsZXIoXCJmaW5pc2hlZC56Zi5hbmltYXRlXCIsW2VdKSk6dm9pZChzPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobikpfWZ1bmN0aW9uIGkoZSxpLG8sYSl7ZnVuY3Rpb24gcigpe2V8fGkuaGlkZSgpLGwoKSxhJiZhLmFwcGx5KGkpfWZ1bmN0aW9uIGwoKXtpWzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj0wLGkucmVtb3ZlQ2xhc3ModStcIiBcIitkK1wiIFwiK28pfWlmKGk9dChpKS5lcSgwKSxpLmxlbmd0aCl7dmFyIHU9ZT9uWzBdOm5bMV0sZD1lP3NbMF06c1sxXTtsKCksaS5hZGRDbGFzcyhvKS5jc3MoXCJ0cmFuc2l0aW9uXCIsXCJub25lXCIpLHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2kuYWRkQ2xhc3ModSksZSYmaS5zaG93KCl9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpWzBdLm9mZnNldFdpZHRoLGkuY3NzKFwidHJhbnNpdGlvblwiLFwiXCIpLmFkZENsYXNzKGQpfSksaS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGkpLHIpfX12YXIgbj1bXCJtdWktZW50ZXJcIixcIm11aS1sZWF2ZVwiXSxzPVtcIm11aS1lbnRlci1hY3RpdmVcIixcIm11aS1sZWF2ZS1hY3RpdmVcIl0sbz17YW5pbWF0ZUluOmZ1bmN0aW9uKHQsZSxuKXtpKCEwLHQsZSxuKX0sYW5pbWF0ZU91dDpmdW5jdGlvbih0LGUsbil7aSghMSx0LGUsbil9fTtGb3VuZGF0aW9uLk1vdmU9ZSxGb3VuZGF0aW9uLk1vdGlvbj1vfShqUXVlcnkpLCFmdW5jdGlvbih0KXt2YXIgZT17RmVhdGhlcjpmdW5jdGlvbihlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJ6ZlwiO2UuYXR0cihcInJvbGVcIixcIm1lbnViYXJcIik7dmFyIG49ZS5maW5kKFwibGlcIikuYXR0cih7cm9sZTpcIm1lbnVpdGVtXCJ9KSxzPVwiaXMtXCIraStcIi1zdWJtZW51XCIsbz1zK1wiLWl0ZW1cIixhPVwiaXMtXCIraStcIi1zdWJtZW51LXBhcmVudFwiO24uZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksbj1lLmNoaWxkcmVuKFwidWxcIik7bi5sZW5ndGgmJihlLmFkZENsYXNzKGEpLmF0dHIoe1wiYXJpYS1oYXNwb3B1cFwiOiEwLFwiYXJpYS1sYWJlbFwiOmUuY2hpbGRyZW4oXCJhOmZpcnN0XCIpLnRleHQoKX0pLFwiZHJpbGxkb3duXCI9PT1pJiZlLmF0dHIoe1wiYXJpYS1leHBhbmRlZFwiOiExfSksbi5hZGRDbGFzcyhcInN1Ym1lbnUgXCIrcykuYXR0cih7XCJkYXRhLXN1Ym1lbnVcIjpcIlwiLHJvbGU6XCJtZW51XCJ9KSxcImRyaWxsZG93blwiPT09aSYmbi5hdHRyKHtcImFyaWEtaGlkZGVuXCI6ITB9KSksZS5wYXJlbnQoXCJbZGF0YS1zdWJtZW51XVwiKS5sZW5ndGgmJmUuYWRkQ2xhc3MoXCJpcy1zdWJtZW51LWl0ZW0gXCIrbyl9KX0sQnVybjpmdW5jdGlvbih0LGUpe3ZhciBpPVwiaXMtXCIrZStcIi1zdWJtZW51XCIsbj1pK1wiLWl0ZW1cIixzPVwiaXMtXCIrZStcIi1zdWJtZW51LXBhcmVudFwiO3QuZmluZChcIj5saSwgLm1lbnUsIC5tZW51ID4gbGlcIikucmVtb3ZlQ2xhc3MoaStcIiBcIituK1wiIFwiK3MrXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXN1Ym1lbnVcIikuY3NzKFwiZGlzcGxheVwiLFwiXCIpfX07Rm91bmRhdGlvbi5OZXN0PWV9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLGkpe3ZhciBuLHMsbz10aGlzLGE9ZS5kdXJhdGlvbixyPU9iamVjdC5rZXlzKHQuZGF0YSgpKVswXXx8XCJ0aW1lclwiLGw9LTE7dGhpcy5pc1BhdXNlZD0hMSx0aGlzLnJlc3RhcnQ9ZnVuY3Rpb24oKXtsPS0xLGNsZWFyVGltZW91dChzKSx0aGlzLnN0YXJ0KCl9LHRoaXMuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSExLGNsZWFyVGltZW91dChzKSxsPWw8PTA/YTpsLHQuZGF0YShcInBhdXNlZFwiLCExKSxuPURhdGUubm93KCkscz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5pbmZpbml0ZSYmby5yZXN0YXJ0KCksaSYmXCJmdW5jdGlvblwiPT10eXBlb2YgaSYmaSgpfSxsKSx0LnRyaWdnZXIoXCJ0aW1lcnN0YXJ0LnpmLlwiK3IpfSx0aGlzLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZD0hMCxjbGVhclRpbWVvdXQocyksdC5kYXRhKFwicGF1c2VkXCIsITApO3ZhciBlPURhdGUubm93KCk7bC09ZS1uLHQudHJpZ2dlcihcInRpbWVycGF1c2VkLnpmLlwiK3IpfX1mdW5jdGlvbiBpKGUsaSl7ZnVuY3Rpb24gbigpe3MtLSwwPT09cyYmaSgpfXZhciBzPWUubGVuZ3RoOzA9PT1zJiZpKCksZS5lYWNoKGZ1bmN0aW9uKCl7aWYodGhpcy5jb21wbGV0ZXx8ND09PXRoaXMucmVhZHlTdGF0ZXx8XCJjb21wbGV0ZVwiPT09dGhpcy5yZWFkeVN0YXRlKW4oKTtlbHNle3ZhciBlPXQodGhpcykuYXR0cihcInNyY1wiKTt0KHRoaXMpLmF0dHIoXCJzcmNcIixlK1wiP1wiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpKSx0KHRoaXMpLm9uZShcImxvYWRcIixmdW5jdGlvbigpe24oKX0pfX0pfUZvdW5kYXRpb24uVGltZXI9ZSxGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkPWl9KGpRdWVyeSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGkpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsZSksdT0hMX1mdW5jdGlvbiBpKGkpe2lmKHQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0JiZpLnByZXZlbnREZWZhdWx0KCksdSl7dmFyIG4scz1pLnRvdWNoZXNbMF0ucGFnZVgsYT0oaS50b3VjaGVzWzBdLnBhZ2VZLG8tcyk7bD0obmV3IERhdGUpLmdldFRpbWUoKS1yLE1hdGguYWJzKGEpPj10LnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkJiZsPD10LnNwb3RTd2lwZS50aW1lVGhyZXNob2xkJiYobj1hPjA/XCJsZWZ0XCI6XCJyaWdodFwiKSxuJiYoaS5wcmV2ZW50RGVmYXVsdCgpLGUuY2FsbCh0aGlzKSx0KHRoaXMpLnRyaWdnZXIoXCJzd2lwZVwiLG4pLnRyaWdnZXIoXCJzd2lwZVwiK24pKX19ZnVuY3Rpb24gbih0KXsxPT10LnRvdWNoZXMubGVuZ3RoJiYobz10LnRvdWNoZXNbMF0ucGFnZVgsYT10LnRvdWNoZXNbMF0ucGFnZVksdT0hMCxyPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGksITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsZSwhMSkpfWZ1bmN0aW9uIHMoKXt0aGlzLmFkZEV2ZW50TGlzdGVuZXImJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixuLCExKX10LnNwb3RTd2lwZT17dmVyc2lvbjpcIjEuMC4wXCIsZW5hYmxlZDpcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHByZXZlbnREZWZhdWx0OiExLG1vdmVUaHJlc2hvbGQ6NzUsdGltZVRocmVzaG9sZDoyMDB9O3ZhciBvLGEscixsLHU9ITE7dC5ldmVudC5zcGVjaWFsLnN3aXBlPXtzZXR1cDpzfSx0LmVhY2goW1wibGVmdFwiLFwidXBcIixcImRvd25cIixcInJpZ2h0XCJdLGZ1bmN0aW9uKCl7dC5ldmVudC5zcGVjaWFsW1wic3dpcGVcIit0aGlzXT17c2V0dXA6ZnVuY3Rpb24oKXt0KHRoaXMpLm9uKFwic3dpcGVcIix0Lm5vb3ApfX19KX0oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dC5mbi5hZGRUb3VjaD1mdW5jdGlvbigpe3RoaXMuZWFjaChmdW5jdGlvbihpLG4pe3QobikuYmluZChcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsXCIsZnVuY3Rpb24oKXtlKGV2ZW50KX0pfSk7dmFyIGU9ZnVuY3Rpb24odCl7dmFyIGUsaT10LmNoYW5nZWRUb3VjaGVzLG49aVswXSxzPXt0b3VjaHN0YXJ0OlwibW91c2Vkb3duXCIsdG91Y2htb3ZlOlwibW91c2Vtb3ZlXCIsdG91Y2hlbmQ6XCJtb3VzZXVwXCJ9LG89c1t0LnR5cGVdO1wiTW91c2VFdmVudFwiaW4gd2luZG93JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB3aW5kb3cuTW91c2VFdmVudD9lPW5ldyB3aW5kb3cuTW91c2VFdmVudChvLHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsc2NyZWVuWDpuLnNjcmVlblgsc2NyZWVuWTpuLnNjcmVlblksY2xpZW50WDpuLmNsaWVudFgsY2xpZW50WTpuLmNsaWVudFl9KTooZT1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIiksZS5pbml0TW91c2VFdmVudChvLCEwLCEwLHdpbmRvdywxLG4uc2NyZWVuWCxuLnNjcmVlblksbi5jbGllbnRYLG4uY2xpZW50WSwhMSwhMSwhMSwhMSwwLG51bGwpKSxuLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpfX19KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXthKCksbigpLHMoKSxvKCksaSgpfWZ1bmN0aW9uIGkoZSl7dmFyIGk9dChcIltkYXRhLXlldGktYm94XVwiKSxuPVtcImRyb3Bkb3duXCIsXCJ0b29sdGlwXCIsXCJyZXZlYWxcIl07aWYoZSYmKFwic3RyaW5nXCI9PXR5cGVvZiBlP24ucHVzaChlKTpcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJzdHJpbmdcIj09dHlwZW9mIGVbMF0/bi5jb25jYXQoZSk6Y29uc29sZS5lcnJvcihcIlBsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3NcIikpLGkubGVuZ3RoKXt2YXIgcz1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNsb3NlbWUuemYuXCIrdH0pLmpvaW4oXCIgXCIpO3Qod2luZG93KS5vZmYocykub24ocyxmdW5jdGlvbihlLGkpe3ZhciBuPWUubmFtZXNwYWNlLnNwbGl0KFwiLlwiKVswXSxzPXQoXCJbZGF0YS1cIituK1wiXVwiKS5ub3QoJ1tkYXRhLXlldGktYm94PVwiJytpKydcIl0nKTtzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpO2UudHJpZ2dlckhhbmRsZXIoXCJjbG9zZS56Zi50cmlnZ2VyXCIsW2VdKX0pfSl9fWZ1bmN0aW9uIG4oZSl7dmFyIGk9dm9pZCAwLG49dChcIltkYXRhLXJlc2l6ZV1cIik7bi5sZW5ndGgmJnQod2luZG93KS5vZmYoXCJyZXNpemUuemYudHJpZ2dlclwiKS5vbihcInJlc2l6ZS56Zi50cmlnZ2VyXCIsZnVuY3Rpb24ocyl7aSYmY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChmdW5jdGlvbigpe3J8fG4uZWFjaChmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlckhhbmRsZXIoXCJyZXNpemVtZS56Zi50cmlnZ2VyXCIpfSksbi5hdHRyKFwiZGF0YS1ldmVudHNcIixcInJlc2l6ZVwiKX0sZXx8MTApfSl9ZnVuY3Rpb24gcyhlKXt2YXIgaT12b2lkIDAsbj10KFwiW2RhdGEtc2Nyb2xsXVwiKTtuLmxlbmd0aCYmdCh3aW5kb3cpLm9mZihcInNjcm9sbC56Zi50cmlnZ2VyXCIpLm9uKFwic2Nyb2xsLnpmLnRyaWdnZXJcIixmdW5jdGlvbihzKXtpJiZjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cnx8bi5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VySGFuZGxlcihcInNjcm9sbG1lLnpmLnRyaWdnZXJcIil9KSxuLmF0dHIoXCJkYXRhLWV2ZW50c1wiLFwic2Nyb2xsXCIpfSxlfHwxMCl9KX1mdW5jdGlvbiBvKGUpe3ZhciBpPXQoXCJbZGF0YS1tdXRhdGVdXCIpO2kubGVuZ3RoJiZyJiZpLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLnRyaWdnZXJIYW5kbGVyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKX0pfWZ1bmN0aW9uIGEoKXtpZighcilyZXR1cm4hMTt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXVwiKSxpPWZ1bmN0aW9uKGUpe3ZhciBpPXQoZVswXS50YXJnZXQpO3N3aXRjaChlWzBdLnR5cGUpe2Nhc2VcImF0dHJpYnV0ZXNcIjpcInNjcm9sbFwiPT09aS5hdHRyKFwiZGF0YS1ldmVudHNcIikmJlwiZGF0YS1ldmVudHNcIj09PWVbMF0uYXR0cmlidXRlTmFtZSYmaS50cmlnZ2VySGFuZGxlcihcInNjcm9sbG1lLnpmLnRyaWdnZXJcIixbaSx3aW5kb3cucGFnZVlPZmZzZXRdKSxcInJlc2l6ZVwiPT09aS5hdHRyKFwiZGF0YS1ldmVudHNcIikmJlwiZGF0YS1ldmVudHNcIj09PWVbMF0uYXR0cmlidXRlTmFtZSYmaS50cmlnZ2VySGFuZGxlcihcInJlc2l6ZW1lLnpmLnRyaWdnZXJcIixbaV0pLFwic3R5bGVcIj09PWVbMF0uYXR0cmlidXRlTmFtZSYmKGkuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikuYXR0cihcImRhdGEtZXZlbnRzXCIsXCJtdXRhdGVcIiksaS5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VySGFuZGxlcihcIm11dGF0ZW1lLnpmLnRyaWdnZXJcIixbaS5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKV0pKTticmVhaztjYXNlXCJjaGlsZExpc3RcIjppLmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpLmF0dHIoXCJkYXRhLWV2ZW50c1wiLFwibXV0YXRlXCIpLGkuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikudHJpZ2dlckhhbmRsZXIoXCJtdXRhdGVtZS56Zi50cmlnZ2VyXCIsW2kuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIildKTticmVhaztkZWZhdWx0OnJldHVybiExfX07aWYoZS5sZW5ndGgpZm9yKHZhciBuPTA7bjw9ZS5sZW5ndGgtMTtuKyspe3ZhciBzPW5ldyByKGkpO3Mub2JzZXJ2ZShlW25dLHthdHRyaWJ1dGVzOiEwLGNoaWxkTGlzdDohMCxjaGFyYWN0ZXJEYXRhOiExLHN1YnRyZWU6ITAsYXR0cmlidXRlRmlsdGVyOltcImRhdGEtZXZlbnRzXCIsXCJzdHlsZVwiXX0pfX12YXIgcj1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXCJXZWJLaXRcIixcIk1velwiLFwiT1wiLFwiTXNcIixcIlwiXSxlPTA7ZTx0Lmxlbmd0aDtlKyspaWYodFtlXStcIk11dGF0aW9uT2JzZXJ2ZXJcImluIHdpbmRvdylyZXR1cm4gd2luZG93W3RbZV0rXCJNdXRhdGlvbk9ic2VydmVyXCJdO3JldHVybiExfSgpLGw9ZnVuY3Rpb24oZSxpKXtlLmRhdGEoaSkuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24obil7dChcIiNcIituKVtcImNsb3NlXCI9PT1pP1widHJpZ2dlclwiOlwidHJpZ2dlckhhbmRsZXJcIl0oaStcIi56Zi50cmlnZ2VyXCIsW2VdKX0pfTt0KGRvY3VtZW50KS5vbihcImNsaWNrLnpmLnRyaWdnZXJcIixcIltkYXRhLW9wZW5dXCIsZnVuY3Rpb24oKXtsKHQodGhpcyksXCJvcGVuXCIpfSksdChkb2N1bWVudCkub24oXCJjbGljay56Zi50cmlnZ2VyXCIsXCJbZGF0YS1jbG9zZV1cIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcImNsb3NlXCIpO2U/bCh0KHRoaXMpLFwiY2xvc2VcIik6dCh0aGlzKS50cmlnZ2VyKFwiY2xvc2UuemYudHJpZ2dlclwiKX0pLHQoZG9jdW1lbnQpLm9uKFwiY2xpY2suemYudHJpZ2dlclwiLFwiW2RhdGEtdG9nZ2xlXVwiLGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKS5kYXRhKFwidG9nZ2xlXCIpO2U/bCh0KHRoaXMpLFwidG9nZ2xlXCIpOnQodGhpcykudHJpZ2dlcihcInRvZ2dsZS56Zi50cmlnZ2VyXCIpfSksdChkb2N1bWVudCkub24oXCJjbG9zZS56Zi50cmlnZ2VyXCIsXCJbZGF0YS1jbG9zYWJsZV1cIixmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpO3ZhciBpPXQodGhpcykuZGF0YShcImNsb3NhYmxlXCIpO1wiXCIhPT1pP0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodCh0aGlzKSxpLGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VyKFwiY2xvc2VkLnpmXCIpfSk6dCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcihcImNsb3NlZC56ZlwiKX0pLHQoZG9jdW1lbnQpLm9uKFwiZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXJcIixcIltkYXRhLXRvZ2dsZS1mb2N1c11cIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcInRvZ2dsZS1mb2N1c1wiKTt0KFwiI1wiK2UpLnRyaWdnZXJIYW5kbGVyKFwidG9nZ2xlLnpmLnRyaWdnZXJcIixbdCh0aGlzKV0pfSksdCh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7ZSgpfSksRm91bmRhdGlvbi5JSGVhcllvdT1lfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGkpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIkFiaWRlXCIpfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRpbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIiksdGhpcy5fZXZlbnRzKCl9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcIi5hYmlkZVwiKS5vbihcInJlc2V0LnpmLmFiaWRlXCIsZnVuY3Rpb24oKXtlLnJlc2V0Rm9ybSgpfSkub24oXCJzdWJtaXQuemYuYWJpZGVcIixmdW5jdGlvbigpe3JldHVybiBlLnZhbGlkYXRlRm9ybSgpfSksXCJmaWVsZENoYW5nZVwiPT09dGhpcy5vcHRpb25zLnZhbGlkYXRlT24mJnRoaXMuJGlucHV0cy5vZmYoXCJjaGFuZ2UuemYuYWJpZGVcIikub24oXCJjaGFuZ2UuemYuYWJpZGVcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpfSksdGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSYmdGhpcy4kaW5wdXRzLm9mZihcImlucHV0LnpmLmFiaWRlXCIpLm9uKFwiaW5wdXQuemYuYWJpZGVcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpfSksdGhpcy5vcHRpb25zLnZhbGlkYXRlT25CbHVyJiZ0aGlzLiRpbnB1dHMub2ZmKFwiYmx1ci56Zi5hYmlkZVwiKS5vbihcImJsdXIuemYuYWJpZGVcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpfSl9fSx7a2V5OlwiX3JlZmxvd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faW5pdCgpfX0se2tleTpcInJlcXVpcmVkQ2hlY2tcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdC5hdHRyKFwicmVxdWlyZWRcIikpcmV0dXJuITA7dmFyIGU9ITA7c3dpdGNoKHRbMF0udHlwZSl7Y2FzZVwiY2hlY2tib3hcIjplPXRbMF0uY2hlY2tlZDticmVhaztjYXNlXCJzZWxlY3RcIjpjYXNlXCJzZWxlY3Qtb25lXCI6Y2FzZVwic2VsZWN0LW11bHRpcGxlXCI6dmFyIGk9dC5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpO2kubGVuZ3RoJiZpLnZhbCgpfHwoZT0hMSk7YnJlYWs7ZGVmYXVsdDp0LnZhbCgpJiZ0LnZhbCgpLmxlbmd0aHx8KGU9ITEpfXJldHVybiBlfX0se2tleTpcImZpbmRGb3JtRXJyb3JcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7cmV0dXJuIGUubGVuZ3RofHwoZT10LnBhcmVudCgpLmZpbmQodGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKSksZX19LHtrZXk6XCJmaW5kTGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10WzBdLmlkLGk9dGhpcy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XCInK2UrJ1wiXScpO3JldHVybiBpLmxlbmd0aD9pOnQuY2xvc2VzdChcImxhYmVsXCIpfX0se2tleTpcImZpbmRSYWRpb0xhYmVsc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpPXRoaXMsbj1lLm1hcChmdW5jdGlvbihlLG4pe3ZhciBzPW4uaWQsbz1pLiRlbGVtZW50LmZpbmQoJ2xhYmVsW2Zvcj1cIicrcysnXCJdJyk7cmV0dXJuIG8ubGVuZ3RofHwobz10KG4pLmNsb3Nlc3QoXCJsYWJlbFwiKSksb1swXX0pO3JldHVybiB0KG4pfX0se2tleTpcImFkZEVycm9yQ2xhc3Nlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZExhYmVsKHQpLGk9dGhpcy5maW5kRm9ybUVycm9yKHQpO2UubGVuZ3RoJiZlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLGkubGVuZ3RoJiZpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5hdHRyKFwiZGF0YS1pbnZhbGlkXCIsXCJcIil9fSx7a2V5OlwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVwiJyt0KydcIl0nKSxpPXRoaXMuZmluZFJhZGlvTGFiZWxzKGUpLG49dGhpcy5maW5kRm9ybUVycm9yKGUpO2kubGVuZ3RoJiZpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLG4ubGVuZ3RoJiZuLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKFwiZGF0YS1pbnZhbGlkXCIpfX0se2tleTpcInJlbW92ZUVycm9yQ2xhc3Nlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwicmFkaW9cIj09dFswXS50eXBlKXJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKHQuYXR0cihcIm5hbWVcIikpO3ZhciBlPXRoaXMuZmluZExhYmVsKHQpLGk9dGhpcy5maW5kRm9ybUVycm9yKHQpO2UubGVuZ3RoJiZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLGkubGVuZ3RoJiZpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKFwiZGF0YS1pbnZhbGlkXCIpfX0se2tleTpcInZhbGlkYXRlSW5wdXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLG49dGhpcy5yZXF1aXJlZENoZWNrKGUpLHM9ITEsbz0hMCxhPWUuYXR0cihcImRhdGEtdmFsaWRhdG9yXCIpLHI9ITA7aWYoZS5pcyhcIltkYXRhLWFiaWRlLWlnbm9yZV1cIil8fGUuaXMoJ1t0eXBlPVwiaGlkZGVuXCJdJykpcmV0dXJuITA7c3dpdGNoKGVbMF0udHlwZSl7Y2FzZVwicmFkaW9cIjpzPXRoaXMudmFsaWRhdGVSYWRpbyhlLmF0dHIoXCJuYW1lXCIpKTticmVhaztjYXNlXCJjaGVja2JveFwiOnM9bjticmVhaztjYXNlXCJzZWxlY3RcIjpjYXNlXCJzZWxlY3Qtb25lXCI6Y2FzZVwic2VsZWN0LW11bHRpcGxlXCI6cz1uO2JyZWFrO2RlZmF1bHQ6cz10aGlzLnZhbGlkYXRlVGV4dChlKX1hJiYobz10aGlzLm1hdGNoVmFsaWRhdGlvbihlLGEsZS5hdHRyKFwicmVxdWlyZWRcIikpKSxlLmF0dHIoXCJkYXRhLWVxdWFsdG9cIikmJihyPXRoaXMub3B0aW9ucy52YWxpZGF0b3JzLmVxdWFsVG8oZSkpO3ZhciBsPVtuLHMsbyxyXS5pbmRleE9mKCExKT09PS0xLHU9KGw/XCJ2YWxpZFwiOlwiaW52YWxpZFwiKStcIi56Zi5hYmlkZVwiO2lmKGwpe3ZhciBkPXRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWx0bz1cIicrZS5hdHRyKFwiaWRcIikrJ1wiXScpO2QubGVuZ3RoJiYhZnVuY3Rpb24oKXt2YXIgZT1pO2QuZWFjaChmdW5jdGlvbigpe3QodGhpcykudmFsKCkmJmUudmFsaWRhdGVJbnB1dCh0KHRoaXMpKX0pfSgpfXJldHVybiB0aGlzW2w/XCJyZW1vdmVFcnJvckNsYXNzZXNcIjpcImFkZEVycm9yQ2xhc3Nlc1wiXShlKSxlLnRyaWdnZXIodSxbZV0pLGx9fSx7a2V5OlwidmFsaWRhdGVGb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1bXSxpPXRoaXM7dGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24oKXtlLnB1c2goaS52YWxpZGF0ZUlucHV0KHQodGhpcykpKX0pO3ZhciBuPWUuaW5kZXhPZighMSk9PT0tMTtyZXR1cm4gdGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtYWJpZGUtZXJyb3JdXCIpLmNzcyhcImRpc3BsYXlcIixuP1wibm9uZVwiOlwiYmxvY2tcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKChuP1wiZm9ybXZhbGlkXCI6XCJmb3JtaW52YWxpZFwiKStcIi56Zi5hYmlkZVwiLFt0aGlzLiRlbGVtZW50XSksbn19LHtrZXk6XCJ2YWxpZGF0ZVRleHRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2U9ZXx8dC5hdHRyKFwicGF0dGVyblwiKXx8dC5hdHRyKFwidHlwZVwiKTt2YXIgaT10LnZhbCgpLG49ITE7cmV0dXJuIGkubGVuZ3RoP249dGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KGUpP3RoaXMub3B0aW9ucy5wYXR0ZXJuc1tlXS50ZXN0KGkpOmU9PT10LmF0dHIoXCJ0eXBlXCIpfHxuZXcgUmVnRXhwKGUpLnRlc3QoaSk6dC5wcm9wKFwicmVxdWlyZWRcIil8fChuPSEwKSxufX0se2tleTpcInZhbGlkYXRlUmFkaW9cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVwiJytlKydcIl0nKSxuPSExLHM9ITE7cmV0dXJuIGkuZWFjaChmdW5jdGlvbihlLGkpe3QoaSkuYXR0cihcInJlcXVpcmVkXCIpJiYocz0hMCl9KSxzfHwobj0hMCksbnx8aS5lYWNoKGZ1bmN0aW9uKGUsaSl7dChpKS5wcm9wKFwiY2hlY2tlZFwiKSYmKG49ITApfSksbn19LHtrZXk6XCJtYXRjaFZhbGlkYXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG49dGhpcztpPSEhaTt2YXIgcz1lLnNwbGl0KFwiIFwiKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG4ub3B0aW9ucy52YWxpZGF0b3JzW2VdKHQsaSx0LnBhcmVudCgpKX0pO3JldHVybiBzLmluZGV4T2YoITEpPT09LTF9fSx7a2V5OlwicmVzZXRGb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLiRlbGVtZW50LGk9dGhpcy5vcHRpb25zO3QoXCIuXCIraS5sYWJlbEVycm9yQ2xhc3MsZSkubm90KFwic21hbGxcIikucmVtb3ZlQ2xhc3MoaS5sYWJlbEVycm9yQ2xhc3MpLHQoXCIuXCIraS5pbnB1dEVycm9yQ2xhc3MsZSkubm90KFwic21hbGxcIikucmVtb3ZlQ2xhc3MoaS5pbnB1dEVycm9yQ2xhc3MpLHQoaS5mb3JtRXJyb3JTZWxlY3RvcitcIi5cIitpLmZvcm1FcnJvckNsYXNzKS5yZW1vdmVDbGFzcyhpLmZvcm1FcnJvckNsYXNzKSxlLmZpbmQoXCJbZGF0YS1hYmlkZS1lcnJvcl1cIikuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKSx0KFwiOmlucHV0XCIsZSkubm90KFwiOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXVwiKS52YWwoXCJcIikucmVtb3ZlQXR0cihcImRhdGEtaW52YWxpZFwiKSx0KFwiOmlucHV0OnJhZGlvXCIsZSkubm90KFwiW2RhdGEtYWJpZGUtaWdub3JlXVwiKS5wcm9wKFwiY2hlY2tlZFwiLCExKS5yZW1vdmVBdHRyKFwiZGF0YS1pbnZhbGlkXCIpLHQoXCI6aW5wdXQ6Y2hlY2tib3hcIixlKS5ub3QoXCJbZGF0YS1hYmlkZS1pZ25vcmVdXCIpLnByb3AoXCJjaGVja2VkXCIsITEpLnJlbW92ZUF0dHIoXCJkYXRhLWludmFsaWRcIiksZS50cmlnZ2VyKFwiZm9ybXJlc2V0LnpmLmFiaWRlXCIsW2VdKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFwiLmFiaWRlXCIpLmZpbmQoXCJbZGF0YS1hYmlkZS1lcnJvcl1cIikuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKSx0aGlzLiRpbnB1dHMub2ZmKFwiLmFiaWRlXCIpLmVhY2goZnVuY3Rpb24oKXtlLnJlbW92ZUVycm9yQ2xhc3Nlcyh0KHRoaXMpKX0pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKX19XSksZX0oKTtlLmRlZmF1bHRzPXt2YWxpZGF0ZU9uOlwiZmllbGRDaGFuZ2VcIixsYWJlbEVycm9yQ2xhc3M6XCJpcy1pbnZhbGlkLWxhYmVsXCIsaW5wdXRFcnJvckNsYXNzOlwiaXMtaW52YWxpZC1pbnB1dFwiLGZvcm1FcnJvclNlbGVjdG9yOlwiLmZvcm0tZXJyb3JcIixmb3JtRXJyb3JDbGFzczpcImlzLXZpc2libGVcIixsaXZlVmFsaWRhdGU6ITEsdmFsaWRhdGVPbkJsdXI6ITEscGF0dGVybnM6e2FscGhhOi9eW2EtekEtWl0rJC8sYWxwaGFfbnVtZXJpYzovXlthLXpBLVowLTldKyQvLGludGVnZXI6L15bLStdP1xcZCskLyxudW1iZXI6L15bLStdP1xcZCooPzpbXFwuXFwsXVxcZCspPyQvLGNhcmQ6L14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQvLGN2djovXihbMC05XSl7Myw0fSQvLGVtYWlsOi9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLHVybDovXihodHRwcz98ZnRwfGZpbGV8c3NoKTpcXC9cXC8oKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvLGRvbWFpbjovXihbYS16QS1aMC05XShbYS16QS1aMC05XFwtXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsOH0kLyxkYXRldGltZTovXihbMC0yXVswLTldezN9KVxcLShbMC0xXVswLTldKVxcLShbMC0zXVswLTldKVQoWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSkoWnwoW1xcLVxcK10oWzAtMV1bMC05XSlcXDowMCkpJC8sZGF0ZTovKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyx0aW1lOi9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxkYXRlSVNPOi9eXFxkezR9W1xcL1xcLV1cXGR7MSwyfVtcXC9cXC1dXFxkezEsMn0kLyxtb250aF9kYXlfeWVhcjovXigwWzEtOV18MVswMTJdKVstIFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl1cXGR7NH0kLyxkYXlfbW9udGhfeWVhcjovXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFwvLl1cXGR7NH0kLyxjb2xvcjovXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvfSx2YWxpZGF0b3JzOntlcXVhbFRvOmZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gdChcIiNcIitlLmF0dHIoXCJkYXRhLWVxdWFsdG9cIikpLnZhbCgpPT09ZS52YWwoKX19fSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiQWJpZGVcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIkFjY29yZGlvblwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFwiQWNjb3JkaW9uXCIse0VOVEVSOlwidG9nZ2xlXCIsU1BBQ0U6XCJ0b2dnbGVcIixBUlJPV19ET1dOOlwibmV4dFwiLEFSUk9XX1VQOlwicHJldmlvdXNcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LmF0dHIoXCJyb2xlXCIsXCJ0YWJsaXN0XCIpLHRoaXMuJHRhYnM9dGhpcy4kZWxlbWVudC5jaGlsZHJlbihcIltkYXRhLWFjY29yZGlvbi1pdGVtXVwiKSx0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oZSxpKXt2YXIgbj10KGkpLHM9bi5jaGlsZHJlbihcIltkYXRhLXRhYi1jb250ZW50XVwiKSxvPXNbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcImFjY29yZGlvblwiKSxhPWkuaWR8fG8rXCItbGFiZWxcIjtuLmZpbmQoXCJhOmZpcnN0XCIpLmF0dHIoe1wiYXJpYS1jb250cm9sc1wiOm8scm9sZTpcInRhYlwiLGlkOmEsXCJhcmlhLWV4cGFuZGVkXCI6ITEsXCJhcmlhLXNlbGVjdGVkXCI6ITF9KSxzLmF0dHIoe3JvbGU6XCJ0YWJwYW5lbFwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6YSxcImFyaWEtaGlkZGVuXCI6ITAsaWQ6b30pfSk7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFwiLmlzLWFjdGl2ZVwiKS5jaGlsZHJlbihcIltkYXRhLXRhYi1jb250ZW50XVwiKTtlLmxlbmd0aCYmdGhpcy5kb3duKGUsITApLHRoaXMuX2V2ZW50cygpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuY2hpbGRyZW4oXCJbZGF0YS10YWItY29udGVudF1cIik7bi5sZW5ndGgmJmkuY2hpbGRyZW4oXCJhXCIpLm9mZihcImNsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvblwiKS5vbihcImNsaWNrLnpmLmFjY29yZGlvblwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLnRvZ2dsZShuKX0pLm9uKFwia2V5ZG93bi56Zi5hY2NvcmRpb25cIixmdW5jdGlvbih0KXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LFwiQWNjb3JkaW9uXCIse3RvZ2dsZTpmdW5jdGlvbigpe2UudG9nZ2xlKG4pfSxuZXh0OmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCkuZmluZChcImFcIikuZm9jdXMoKTtlLm9wdGlvbnMubXVsdGlFeHBhbmR8fHQudHJpZ2dlcihcImNsaWNrLnpmLmFjY29yZGlvblwiKX0scHJldmlvdXM6ZnVuY3Rpb24oKXt2YXIgdD1pLnByZXYoKS5maW5kKFwiYVwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZHx8dC50cmlnZ2VyKFwiY2xpY2suemYuYWNjb3JkaW9uXCIpfSxoYW5kbGVkOmZ1bmN0aW9uKCl7dC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCl9fSl9KX0pfX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QucGFyZW50KCkuaGFzQ2xhc3MoXCJpcy1hY3RpdmVcIik/dGhpcy51cCh0KTp0aGlzLmRvd24odCl9fSx7a2V5OlwiZG93blwiLHZhbHVlOmZ1bmN0aW9uKGUsaSl7dmFyIG49dGhpcztpZihlLmF0dHIoXCJhcmlhLWhpZGRlblwiLCExKS5wYXJlbnQoXCJbZGF0YS10YWItY29udGVudF1cIikuYWRkQmFjaygpLnBhcmVudCgpLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpLCF0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQmJiFpKXt2YXIgcz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFwiLmlzLWFjdGl2ZVwiKS5jaGlsZHJlbihcIltkYXRhLXRhYi1jb250ZW50XVwiKTtzLmxlbmd0aCYmdGhpcy51cChzLm5vdChlKSl9ZS5zbGlkZURvd24odGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXCJkb3duLnpmLmFjY29yZGlvblwiLFtlXSl9KSx0KFwiI1wiK2UuYXR0cihcImFyaWEtbGFiZWxsZWRieVwiKSkuYXR0cih7XCJhcmlhLWV4cGFuZGVkXCI6ITAsXCJhcmlhLXNlbGVjdGVkXCI6ITB9KX19LHtrZXk6XCJ1cFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpPWUucGFyZW50KCkuc2libGluZ3MoKSxuPXRoaXM7KHRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZHx8aS5oYXNDbGFzcyhcImlzLWFjdGl2ZVwiKSkmJmUucGFyZW50KCkuaGFzQ2xhc3MoXCJpcy1hY3RpdmVcIikmJihlLnNsaWRlVXAobi5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXCJ1cC56Zi5hY2NvcmRpb25cIixbZV0pfSksZS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwhMCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIiksdChcIiNcIitlLmF0dHIoXCJhcmlhLWxhYmVsbGVkYnlcIikpLmF0dHIoe1wiYXJpYS1leHBhbmRlZFwiOiExLFwiYXJpYS1zZWxlY3RlZFwiOiExfSkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLXRhYi1jb250ZW50XVwiKS5zdG9wKCEwKS5zbGlkZVVwKDApLmNzcyhcImRpc3BsYXlcIixcIlwiKSx0aGlzLiRlbGVtZW50LmZpbmQoXCJhXCIpLm9mZihcIi56Zi5hY2NvcmRpb25cIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO2UuZGVmYXVsdHM9e3NsaWRlU3BlZWQ6MjUwLG11bHRpRXhwYW5kOiExLGFsbG93QWxsQ2xvc2VkOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiQWNjb3JkaW9uXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7XG52YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcImFjY29yZGlvblwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiQWNjb3JkaW9uTWVudVwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFwiQWNjb3JkaW9uTWVudVwiLHtFTlRFUjpcInRvZ2dsZVwiLFNQQUNFOlwidG9nZ2xlXCIsQVJST1dfUklHSFQ6XCJvcGVuXCIsQVJST1dfVVA6XCJ1cFwiLEFSUk9XX0RPV046XCJkb3duXCIsQVJST1dfTEVGVDpcImNsb3NlXCIsRVNDQVBFOlwiY2xvc2VBbGxcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LmZpbmQoXCJbZGF0YS1zdWJtZW51XVwiKS5ub3QoXCIuaXMtYWN0aXZlXCIpLnNsaWRlVXAoMCksdGhpcy4kZWxlbWVudC5hdHRyKHtyb2xlOlwibWVudVwiLFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjp0aGlzLm9wdGlvbnMubXVsdGlPcGVufSksdGhpcy4kbWVudUxpbmtzPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcIiksdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXCJhY2MtbWVudS1saW5rXCIpLGk9dCh0aGlzKSxuPWkuY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKSxzPW5bMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcImFjYy1tZW51XCIpLG89bi5oYXNDbGFzcyhcImlzLWFjdGl2ZVwiKTtpLmF0dHIoe1wiYXJpYS1jb250cm9sc1wiOnMsXCJhcmlhLWV4cGFuZGVkXCI6byxyb2xlOlwibWVudWl0ZW1cIixpZDplfSksbi5hdHRyKHtcImFyaWEtbGFiZWxsZWRieVwiOmUsXCJhcmlhLWhpZGRlblwiOiFvLHJvbGU6XCJtZW51XCIsaWQ6c30pfSk7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFwiLmlzLWFjdGl2ZVwiKTtpZihlLmxlbmd0aCl7dmFyIGk9dGhpcztlLmVhY2goZnVuY3Rpb24oKXtpLmRvd24odCh0aGlzKSl9KX10aGlzLl9ldmVudHMoKX19LHtrZXk6XCJfZXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLmNoaWxkcmVuKFwiW2RhdGEtc3VibWVudV1cIik7aS5sZW5ndGgmJnQodGhpcykuY2hpbGRyZW4oXCJhXCIpLm9mZihcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcIikub24oXCJjbGljay56Zi5hY2NvcmRpb25NZW51XCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUudG9nZ2xlKGkpfSl9KS5vbihcImtleWRvd24uemYuYWNjb3JkaW9ubWVudVwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpLHI9by5jaGlsZHJlbihcIltkYXRhLXN1Ym1lbnVdXCIpO2EuZWFjaChmdW5jdGlvbihlKXtpZih0KHRoaXMpLmlzKG8pKXJldHVybiBuPWEuZXEoTWF0aC5tYXgoMCxlLTEpKS5maW5kKFwiYVwiKS5maXJzdCgpLHM9YS5lcShNYXRoLm1pbihlKzEsYS5sZW5ndGgtMSkpLmZpbmQoXCJhXCIpLmZpcnN0KCksdCh0aGlzKS5jaGlsZHJlbihcIltkYXRhLXN1Ym1lbnVdOnZpc2libGVcIikubGVuZ3RoJiYocz1vLmZpbmQoXCJsaTpmaXJzdC1jaGlsZFwiKS5maW5kKFwiYVwiKS5maXJzdCgpKSx0KHRoaXMpLmlzKFwiOmZpcnN0LWNoaWxkXCIpP249by5wYXJlbnRzKFwibGlcIikuZmlyc3QoKS5maW5kKFwiYVwiKS5maXJzdCgpOm4ucGFyZW50cyhcImxpXCIpLmZpcnN0KCkuY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XTp2aXNpYmxlXCIpLmxlbmd0aCYmKG49bi5wYXJlbnRzKFwibGlcIikuZmluZChcImxpOmxhc3QtY2hpbGRcIikuZmluZChcImFcIikuZmlyc3QoKSksdm9pZCh0KHRoaXMpLmlzKFwiOmxhc3QtY2hpbGRcIikmJihzPW8ucGFyZW50cyhcImxpXCIpLmZpcnN0KCkubmV4dChcImxpXCIpLmZpbmQoXCJhXCIpLmZpcnN0KCkpKX0pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXCJBY2NvcmRpb25NZW51XCIse29wZW46ZnVuY3Rpb24oKXtyLmlzKFwiOmhpZGRlblwiKSYmKGUuZG93bihyKSxyLmZpbmQoXCJsaVwiKS5maXJzdCgpLmZpbmQoXCJhXCIpLmZpcnN0KCkuZm9jdXMoKSl9LGNsb3NlOmZ1bmN0aW9uKCl7ci5sZW5ndGgmJiFyLmlzKFwiOmhpZGRlblwiKT9lLnVwKHIpOm8ucGFyZW50KFwiW2RhdGEtc3VibWVudV1cIikubGVuZ3RoJiYoZS51cChvLnBhcmVudChcIltkYXRhLXN1Ym1lbnVdXCIpKSxvLnBhcmVudHMoXCJsaVwiKS5maXJzdCgpLmZpbmQoXCJhXCIpLmZpcnN0KCkuZm9jdXMoKSl9LHVwOmZ1bmN0aW9uKCl7cmV0dXJuIG4uZm9jdXMoKSwhMH0sZG93bjpmdW5jdGlvbigpe3JldHVybiBzLmZvY3VzKCksITB9LHRvZ2dsZTpmdW5jdGlvbigpe28uY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKS5sZW5ndGgmJmUudG9nZ2xlKG8uY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKSl9LGNsb3NlQWxsOmZ1bmN0aW9uKCl7ZS5oaWRlQWxsKCl9LGhhbmRsZWQ6ZnVuY3Rpb24odCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9fSl9KX19LHtrZXk6XCJoaWRlQWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLXN1Ym1lbnVdXCIpKX19LHtrZXk6XCJzaG93QWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmRvd24odGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtc3VibWVudV1cIikpfX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QuaXMoXCI6YW5pbWF0ZWRcIil8fCh0LmlzKFwiOmhpZGRlblwiKT90aGlzLmRvd24odCk6dGhpcy51cCh0KSl9fSx7a2V5OlwiZG93blwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5vcHRpb25zLm11bHRpT3Blbnx8dGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoXCIuaXMtYWN0aXZlXCIpLm5vdCh0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KS5hZGQodCkpKSx0LmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjohMX0pLnBhcmVudChcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcIikuYXR0cih7XCJhcmlhLWV4cGFuZGVkXCI6ITB9KSx0LnNsaWRlRG93bihlLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe2UuJGVsZW1lbnQudHJpZ2dlcihcImRvd24uemYuYWNjb3JkaW9uTWVudVwiLFt0XSl9KX19LHtrZXk6XCJ1cFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dC5zbGlkZVVwKGUub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC50cmlnZ2VyKFwidXAuemYuYWNjb3JkaW9uTWVudVwiLFt0XSl9KTt2YXIgaT10LmZpbmQoXCJbZGF0YS1zdWJtZW51XVwiKS5zbGlkZVVwKDApLmFkZEJhY2soKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwhMCk7aS5wYXJlbnQoXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLXN1Ym1lbnVdXCIpLnNsaWRlRG93bigwKS5jc3MoXCJkaXNwbGF5XCIsXCJcIiksdGhpcy4kZWxlbWVudC5maW5kKFwiYVwiKS5vZmYoXCJjbGljay56Zi5hY2NvcmRpb25NZW51XCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXCJhY2NvcmRpb25cIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO2UuZGVmYXVsdHM9e3NsaWRlU3BlZWQ6MjUwLG11bHRpT3BlbjohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIkFjY29yZGlvbk1lbnVcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcImRyaWxsZG93blwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiRHJpbGxkb3duXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXCJEcmlsbGRvd25cIix7RU5URVI6XCJvcGVuXCIsU1BBQ0U6XCJvcGVuXCIsQVJST1dfUklHSFQ6XCJuZXh0XCIsQVJST1dfVVA6XCJ1cFwiLEFSUk9XX0RPV046XCJkb3duXCIsQVJST1dfTEVGVDpcInByZXZpb3VzXCIsRVNDQVBFOlwiY2xvc2VcIixUQUI6XCJkb3duXCIsU0hJRlRfVEFCOlwidXBcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRzdWJtZW51QW5jaG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXCJsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcIikuY2hpbGRyZW4oXCJhXCIpLHRoaXMuJHN1Ym1lbnVzPXRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudChcImxpXCIpLmNoaWxkcmVuKFwiW2RhdGEtc3VibWVudV1cIiksdGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZChcImxpXCIpLm5vdChcIi5qcy1kcmlsbGRvd24tYmFja1wiKS5hdHRyKFwicm9sZVwiLFwibWVudWl0ZW1cIikuZmluZChcImFcIiksdGhpcy4kZWxlbWVudC5hdHRyKFwiZGF0YS1tdXRhdGVcIix0aGlzLiRlbGVtZW50LmF0dHIoXCJkYXRhLWRyaWxsZG93blwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFwiZHJpbGxkb3duXCIpKSx0aGlzLl9wcmVwYXJlTWVudSgpLHRoaXMuX3JlZ2lzdGVyRXZlbnRzKCksdGhpcy5fa2V5Ym9hcmRFdmVudHMoKX19LHtrZXk6XCJfcHJlcGFyZU1lbnVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLnBhcmVudCgpO2Uub3B0aW9ucy5wYXJlbnRMaW5rJiZpLmNsb25lKCkucHJlcGVuZFRvKG4uY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKSkud3JhcCgnPGxpIGNsYXNzPVwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtZHJpbGxkb3duLXN1Ym1lbnUtaXRlbVwiIHJvbGU9XCJtZW51LWl0ZW1cIj48L2xpPicpLGkuZGF0YShcInNhdmVkSHJlZlwiLGkuYXR0cihcImhyZWZcIikpLnJlbW92ZUF0dHIoXCJocmVmXCIpLmF0dHIoXCJ0YWJpbmRleFwiLDApLGkuY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKS5hdHRyKHtcImFyaWEtaGlkZGVuXCI6ITAsdGFiaW5kZXg6MCxyb2xlOlwibWVudVwifSksZS5fZXZlbnRzKGkpfSksdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXCIuanMtZHJpbGxkb3duLWJhY2tcIik7aWYoIW4ubGVuZ3RoKXN3aXRjaChlLm9wdGlvbnMuYmFja0J1dHRvblBvc2l0aW9uKXtjYXNlXCJib3R0b21cIjppLmFwcGVuZChlLm9wdGlvbnMuYmFja0J1dHRvbik7YnJlYWs7Y2FzZVwidG9wXCI6aS5wcmVwZW5kKGUub3B0aW9ucy5iYWNrQnV0dG9uKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrQnV0dG9uUG9zaXRpb24gdmFsdWUgJ1wiK2Uub3B0aW9ucy5iYWNrQnV0dG9uUG9zaXRpb24rXCInXCIpfWUuX2JhY2soaSl9KSx0aGlzLm9wdGlvbnMuYXV0b0hlaWdodHx8dGhpcy4kc3VibWVudXMuYWRkQ2xhc3MoXCJkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91c1wiKSx0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFwiaXMtZHJpbGxkb3duXCIpfHwodGhpcy4kd3JhcHBlcj10KHRoaXMub3B0aW9ucy53cmFwcGVyKS5hZGRDbGFzcyhcImlzLWRyaWxsZG93blwiKSx0aGlzLm9wdGlvbnMuYW5pbWF0ZUhlaWdodCYmdGhpcy4kd3JhcHBlci5hZGRDbGFzcyhcImFuaW1hdGUtaGVpZ2h0XCIpLHRoaXMuJHdyYXBwZXI9dGhpcy4kZWxlbWVudC53cmFwKHRoaXMuJHdyYXBwZXIpLnBhcmVudCgpLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpKX19LHtrZXk6XCJfcmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiR3cmFwcGVyLmNzcyh7XCJtYXgtd2lkdGhcIjpcIm5vbmVcIixcIm1pbi1oZWlnaHRcIjpcIm5vbmVcIn0pLHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSl9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpPXRoaXM7ZS5vZmYoXCJjbGljay56Zi5kcmlsbGRvd25cIikub24oXCJjbGljay56Zi5kcmlsbGRvd25cIixmdW5jdGlvbihuKXtpZih0KG4udGFyZ2V0KS5wYXJlbnRzVW50aWwoXCJ1bFwiLFwibGlcIikuaGFzQ2xhc3MoXCJpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcIikmJihuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSksaS5fc2hvdyhlLnBhcmVudChcImxpXCIpKSxpLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXt2YXIgcz10KFwiYm9keVwiKTtzLm9mZihcIi56Zi5kcmlsbGRvd25cIikub24oXCJjbGljay56Zi5kcmlsbGRvd25cIixmdW5jdGlvbihlKXtlLnRhcmdldD09PWkuJGVsZW1lbnRbMF18fHQuY29udGFpbnMoaS4kZWxlbWVudFswXSxlLnRhcmdldCl8fChlLnByZXZlbnREZWZhdWx0KCksaS5faGlkZUFsbCgpLHMub2ZmKFwiLnpmLmRyaWxsZG93blwiKSl9KX19KSx0aGlzLiRlbGVtZW50Lm9uKFwibXV0YXRlbWUuemYudHJpZ2dlclwiLHRoaXMuX3Jlc2l6ZS5iaW5kKHRoaXMpKX19LHtrZXk6XCJfcmVnaXN0ZXJFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5zY3JvbGxUb3AmJih0aGlzLl9iaW5kSGFuZGxlcj10aGlzLl9zY3JvbGxUb3AuYmluZCh0aGlzKSx0aGlzLiRlbGVtZW50Lm9uKFwib3Blbi56Zi5kcmlsbGRvd24gaGlkZS56Zi5kcmlsbGRvd24gY2xvc2VkLnpmLmRyaWxsZG93blwiLHRoaXMuX2JpbmRIYW5kbGVyKSl9fSx7a2V5OlwiX3Njcm9sbFRvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxpPVwiXCIhPWUub3B0aW9ucy5zY3JvbGxUb3BFbGVtZW50P3QoZS5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQpOmUuJGVsZW1lbnQsbj1wYXJzZUludChpLm9mZnNldCgpLnRvcCtlLm9wdGlvbnMuc2Nyb2xsVG9wT2Zmc2V0KTt0KFwiaHRtbCwgYm9keVwiKS5zdG9wKCEwKS5hbmltYXRlKHtzY3JvbGxUb3A6bn0sZS5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLGUub3B0aW9ucy5hbmltYXRpb25FYXNpbmcsZnVuY3Rpb24oKXt0aGlzPT09dChcImh0bWxcIilbMF0mJmUuJGVsZW1lbnQudHJpZ2dlcihcInNjcm9sbG1lLnpmLmRyaWxsZG93blwiKX0pfX0se2tleTpcIl9rZXlib2FyZEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLiRtZW51SXRlbXMuYWRkKHRoaXMuJGVsZW1lbnQuZmluZChcIi5qcy1kcmlsbGRvd24tYmFjayA+IGEsIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtID4gYVwiKSkub24oXCJrZXlkb3duLnpmLmRyaWxsZG93blwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXCJsaVwiKS5wYXJlbnQoXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpLmNoaWxkcmVuKFwiYVwiKTthLmVhY2goZnVuY3Rpb24oZSl7aWYodCh0aGlzKS5pcyhvKSlyZXR1cm4gbj1hLmVxKE1hdGgubWF4KDAsZS0xKSksdm9pZChzPWEuZXEoTWF0aC5taW4oZSsxLGEubGVuZ3RoLTEpKSl9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFwiRHJpbGxkb3duXCIse25leHQ6ZnVuY3Rpb24oKXtpZihvLmlzKGUuJHN1Ym1lbnVBbmNob3JzKSlyZXR1cm4gZS5fc2hvdyhvLnBhcmVudChcImxpXCIpKSxvLnBhcmVudChcImxpXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtvLnBhcmVudChcImxpXCIpLmZpbmQoXCJ1bCBsaSBhXCIpLmZpbHRlcihlLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKX0pLCEwfSxwcmV2aW91czpmdW5jdGlvbigpe3JldHVybiBlLl9oaWRlKG8ucGFyZW50KFwibGlcIikucGFyZW50KFwidWxcIikpLG8ucGFyZW50KFwibGlcIikucGFyZW50KFwidWxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChvKSxmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvLnBhcmVudChcImxpXCIpLnBhcmVudChcInVsXCIpLnBhcmVudChcImxpXCIpLmNoaWxkcmVuKFwiYVwiKS5maXJzdCgpLmZvY3VzKCl9LDEpfSksITB9LHVwOmZ1bmN0aW9uKCl7cmV0dXJuIG4uZm9jdXMoKSwhMH0sZG93bjpmdW5jdGlvbigpe3JldHVybiBzLmZvY3VzKCksITB9LGNsb3NlOmZ1bmN0aW9uKCl7ZS5fYmFjaygpfSxvcGVuOmZ1bmN0aW9uKCl7cmV0dXJuIG8uaXMoZS4kbWVudUl0ZW1zKT9vLmlzKGUuJHN1Ym1lbnVBbmNob3JzKT8oZS5fc2hvdyhvLnBhcmVudChcImxpXCIpKSxvLnBhcmVudChcImxpXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtvLnBhcmVudChcImxpXCIpLmZpbmQoXCJ1bCBsaSBhXCIpLmZpbHRlcihlLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKX0pLCEwKTp2b2lkIDA6KGUuX2hpZGUoby5wYXJlbnQoXCJsaVwiKS5wYXJlbnQoXCJ1bFwiKSksby5wYXJlbnQoXCJsaVwiKS5wYXJlbnQoXCJ1bFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFwibGlcIikucGFyZW50KFwidWxcIikucGFyZW50KFwibGlcIikuY2hpbGRyZW4oXCJhXCIpLmZpcnN0KCkuZm9jdXMoKX0sMSl9KSwhMCl9LGhhbmRsZWQ6ZnVuY3Rpb24odCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9fSl9KX19LHtrZXk6XCJfaGlkZUFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFwiLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZVwiKS5hZGRDbGFzcyhcImlzLWNsb3NpbmdcIik7dGhpcy5vcHRpb25zLmF1dG9IZWlnaHQmJnRoaXMuJHdyYXBwZXIuY3NzKHtoZWlnaHQ6dC5wYXJlbnQoKS5jbG9zZXN0KFwidWxcIikuZGF0YShcImNhbGNIZWlnaHRcIil9KSx0Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodCksZnVuY3Rpb24oZSl7dC5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXCIpfSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiY2xvc2VkLnpmLmRyaWxsZG93blwiKX19LHtrZXk6XCJfYmFja1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dC5vZmYoXCJjbGljay56Zi5kcmlsbGRvd25cIiksdC5jaGlsZHJlbihcIi5qcy1kcmlsbGRvd24tYmFja1wiKS5vbihcImNsaWNrLnpmLmRyaWxsZG93blwiLGZ1bmN0aW9uKGkpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5faGlkZSh0KTt2YXIgbj10LnBhcmVudChcImxpXCIpLnBhcmVudChcInVsXCIpLnBhcmVudChcImxpXCIpO24ubGVuZ3RoJiZlLl9zaG93KG4pfSl9fSx7a2V5OlwiX21lbnVMaW5rRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuJG1lbnVJdGVtcy5ub3QoXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XCIpLm9mZihcImNsaWNrLnpmLmRyaWxsZG93blwiKS5vbihcImNsaWNrLnpmLmRyaWxsZG93blwiLGZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0Ll9oaWRlQWxsKCl9LDApfSl9fSx7a2V5OlwiX3Nob3dcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCYmdGhpcy4kd3JhcHBlci5jc3Moe2hlaWdodDp0LmNoaWxkcmVuKFwiW2RhdGEtc3VibWVudV1cIikuZGF0YShcImNhbGNIZWlnaHRcIil9KSx0LmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLHQuY2hpbGRyZW4oXCJbZGF0YS1zdWJtZW51XVwiKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwhMSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwib3Blbi56Zi5kcmlsbGRvd25cIixbdF0pfX0se2tleTpcIl9oaWRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zLmF1dG9IZWlnaHQmJnRoaXMuJHdyYXBwZXIuY3NzKHtoZWlnaHQ6dC5wYXJlbnQoKS5jbG9zZXN0KFwidWxcIikuZGF0YShcImNhbGNIZWlnaHRcIil9KTt0LnBhcmVudChcImxpXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHQuYXR0cihcImFyaWEtaGlkZGVuXCIsITApLmFkZENsYXNzKFwiaXMtY2xvc2luZ1wiKSx0LmFkZENsYXNzKFwiaXMtY2xvc2luZ1wiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKCl7dC5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXCIpLHQuYmx1cigpfSksdC50cmlnZ2VyKFwiaGlkZS56Zi5kcmlsbGRvd25cIixbdF0pfX0se2tleTpcIl9nZXRNYXhEaW1zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT0wLGk9e30sbj10aGlzO3JldHVybiB0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbigpe3ZhciBzPSh0KHRoaXMpLmNoaWxkcmVuKFwibGlcIikubGVuZ3RoLEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcykuaGVpZ2h0KTtlPXM+ZT9zOmUsbi5vcHRpb25zLmF1dG9IZWlnaHQmJih0KHRoaXMpLmRhdGEoXCJjYWxjSGVpZ2h0XCIscyksdCh0aGlzKS5oYXNDbGFzcyhcImlzLWRyaWxsZG93bi1zdWJtZW51XCIpfHwoaS5oZWlnaHQ9cykpfSksdGhpcy5vcHRpb25zLmF1dG9IZWlnaHR8fChpW1wibWluLWhlaWdodFwiXT1lK1wicHhcIiksaVtcIm1heC13aWR0aFwiXT10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoK1wicHhcIixpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5zY3JvbGxUb3AmJnRoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLmRyaWxsZG93blwiLHRoaXMuX2JpbmRIYW5kbGVyKSx0aGlzLl9oaWRlQWxsKCksdGhpcy4kZWxlbWVudC5vZmYoXCJtdXRhdGVtZS56Zi50cmlnZ2VyXCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXCJkcmlsbGRvd25cIiksdGhpcy4kZWxlbWVudC51bndyYXAoKS5maW5kKFwiLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbVwiKS5yZW1vdmUoKS5lbmQoKS5maW5kKFwiLmlzLWFjdGl2ZSwgLmlzLWNsb3NpbmcsIC5pcy1kcmlsbGRvd24tc3VibWVudVwiKS5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51XCIpLmVuZCgpLmZpbmQoXCJbZGF0YS1zdWJtZW51XVwiKS5yZW1vdmVBdHRyKFwiYXJpYS1oaWRkZW4gdGFiaW5kZXggcm9sZVwiKSx0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS5vZmYoXCIuemYuZHJpbGxkb3duXCIpfSksdGhpcy4kc3VibWVudXMucmVtb3ZlQ2xhc3MoXCJkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91c1wiKSx0aGlzLiRlbGVtZW50LmZpbmQoXCJhXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpO2UucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpLGUuZGF0YShcInNhdmVkSHJlZlwiKSYmZS5hdHRyKFwiaHJlZlwiLGUuZGF0YShcInNhdmVkSHJlZlwiKSkucmVtb3ZlRGF0YShcInNhdmVkSHJlZlwiKX0pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKX19XSksZX0oKTtlLmRlZmF1bHRzPXtiYWNrQnV0dG9uOic8bGkgY2xhc3M9XCJqcy1kcmlsbGRvd24tYmFja1wiPjxhIHRhYmluZGV4PVwiMFwiPkJhY2s8L2E+PC9saT4nLGJhY2tCdXR0b25Qb3NpdGlvbjpcInRvcFwiLHdyYXBwZXI6XCI8ZGl2PjwvZGl2PlwiLHBhcmVudExpbms6ITEsY2xvc2VPbkNsaWNrOiExLGF1dG9IZWlnaHQ6ITEsYW5pbWF0ZUhlaWdodDohMSxzY3JvbGxUb3A6ITEsc2Nyb2xsVG9wRWxlbWVudDpcIlwiLHNjcm9sbFRvcE9mZnNldDowLGFuaW1hdGlvbkR1cmF0aW9uOjUwMCxhbmltYXRpb25FYXNpbmc6XCJzd2luZ1wifSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiRHJpbGxkb3duXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXCJEcm9wZG93blwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFwiRHJvcGRvd25cIix7RU5URVI6XCJvcGVuXCIsU1BBQ0U6XCJvcGVuXCIsRVNDQVBFOlwiY2xvc2VcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXCJpZFwiKTt0aGlzLiRhbmNob3I9dCh0KCdbZGF0YS10b2dnbGU9XCInK2UrJ1wiXScpLmxlbmd0aD8nW2RhdGEtdG9nZ2xlPVwiJytlKydcIl0nOidbZGF0YS1vcGVuPVwiJytlKydcIl0nKSx0aGlzLiRhbmNob3IuYXR0cih7XCJhcmlhLWNvbnRyb2xzXCI6ZSxcImRhdGEtaXMtZm9jdXNcIjohMSxcImRhdGEteWV0aS1ib3hcIjplLFwiYXJpYS1oYXNwb3B1cFwiOiEwLFwiYXJpYS1leHBhbmRlZFwiOiExfSksdGhpcy5vcHRpb25zLnBhcmVudENsYXNzP3RoaXMuJHBhcmVudD10aGlzLiRlbGVtZW50LnBhcmVudHMoXCIuXCIrdGhpcy5vcHRpb25zLnBhcmVudENsYXNzKTp0aGlzLiRwYXJlbnQ9bnVsbCx0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnM9W10sdGhpcy4kZWxlbWVudC5hdHRyKHtcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCIsXCJkYXRhLXlldGktYm94XCI6ZSxcImRhdGEtcmVzaXplXCI6ZSxcImFyaWEtbGFiZWxsZWRieVwiOnRoaXMuJGFuY2hvclswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFwiZGQtYW5jaG9yXCIpfSksdGhpcy5fZXZlbnRzKCl9fSx7a2V5OlwiZ2V0UG9zaXRpb25DbGFzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyh0b3B8bGVmdHxyaWdodHxib3R0b20pL2cpO3Q9dD90WzBdOlwiXCI7dmFyIGU9L2Zsb2F0LShcXFMrKS8uZXhlYyh0aGlzLiRhbmNob3JbMF0uY2xhc3NOYW1lKTtlPWU/ZVsxXTpcIlwiO3ZhciBpPWU/ZStcIiBcIit0OnQ7cmV0dXJuIGl9fSx7a2V5OlwiX3JlcG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0P3Q6XCJib3R0b21cIiksIXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwidG9wXCIpPDA/dGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcInRvcFwiKTpcInRvcFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJib3R0b21cIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpOlwibGVmdFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJyaWdodFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXCJyaWdodFwiKTpcInJpZ2h0XCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImxlZnRcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFwibGVmdFwiKTohdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJ0b3BcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwibGVmdFwiKTwwP3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJsZWZ0XCIpOlwidG9wXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImJvdHRvbVwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJsZWZ0XCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcImxlZnRcIik6XCJsZWZ0XCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcInJpZ2h0XCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImJvdHRvbVwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6XCJyaWdodFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJsZWZ0XCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImJvdHRvbVwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCx0aGlzLmNvdW50ZXItLX19LHtrZXk6XCJfc2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe2lmKFwiZmFsc2VcIj09PXRoaXMuJGFuY2hvci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiKSlyZXR1cm4hMTt2YXIgdD10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksaT0oRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRhbmNob3IpLFwibGVmdFwiPT09dD9cImxlZnRcIjpcInJpZ2h0XCI9PT10P1wibGVmdFwiOlwidG9wXCIpLG49XCJ0b3BcIj09PWk/XCJoZWlnaHRcIjpcIndpZHRoXCI7XCJoZWlnaHRcIj09PW4/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYoZS53aWR0aD49ZS53aW5kb3dEaW1zLndpZHRofHwhdGhpcy5jb3VudGVyJiYhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LHRoaXMuJHBhcmVudCkpe3ZhciBzPWUud2luZG93RGltcy53aWR0aCxvPTA7aWYodGhpcy4kcGFyZW50KXt2YXIgYT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJHBhcmVudCksbz1hLm9mZnNldC5sZWZ0O2Eud2lkdGg8cyYmKHM9YS53aWR0aCl9cmV0dXJuIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsXCJjZW50ZXIgYm90dG9tXCIsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQrbywhMCkpLmNzcyh7d2lkdGg6cy0yKnRoaXMub3B0aW9ucy5oT2Zmc2V0LGhlaWdodDpcImF1dG9cIn0pLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLCExfWZvcih0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsdGhpcy4kYW5jaG9yLHQsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQpKTshRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LHRoaXMuJHBhcmVudCwhMCkmJnRoaXMuY291bnRlcjspdGhpcy5fcmVwb3NpdGlvbih0KSx0aGlzLl9zZXRQb3NpdGlvbigpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vbih7XCJvcGVuLnpmLnRyaWdnZXJcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcImNsb3NlLnpmLnRyaWdnZXJcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXCJ0b2dnbGUuemYudHJpZ2dlclwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXCJyZXNpemVtZS56Zi50cmlnZ2VyXCI6dGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKX0pLHRoaXMub3B0aW9ucy5ob3ZlciYmKHRoaXMuJGFuY2hvci5vZmYoXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd25cIikub24oXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXCIsZnVuY3Rpb24oKXt2YXIgaT10KFwiYm9keVwiKS5kYXRhKCk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGkud2hhdGlucHV0JiZcIm1vdXNlXCIhPT1pLndoYXRpbnB1dHx8KGNsZWFyVGltZW91dChlLnRpbWVvdXQpLGUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5vcGVuKCksZS4kYW5jaG9yLmRhdGEoXCJob3ZlclwiLCEwKX0sZS5vcHRpb25zLmhvdmVyRGVsYXkpKX0pLm9uKFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXCJob3ZlclwiLCExKX0sZS5vcHRpb25zLmhvdmVyRGVsYXkpfSksdGhpcy5vcHRpb25zLmhvdmVyUGFuZSYmdGhpcy4kZWxlbWVudC5vZmYoXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd25cIikub24oXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KX0pLm9uKFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXCJob3ZlclwiLCExKX0sZS5vcHRpb25zLmhvdmVyRGVsYXkpfSkpLHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oXCJrZXlkb3duLnpmLmRyb3Bkb3duXCIsZnVuY3Rpb24oaSl7dmFyIG49dCh0aGlzKTtGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoZS4kZWxlbWVudCk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcIkRyb3Bkb3duXCIse29wZW46ZnVuY3Rpb24oKXtuLmlzKGUuJGFuY2hvcikmJihlLm9wZW4oKSxlLiRlbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiLC0xKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSl9LGNsb3NlOmZ1bmN0aW9uKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpfX0pfSl9fSx7a2V5OlwiX2FkZEJvZHlIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLm5vdCh0aGlzLiRlbGVtZW50KSxpPXRoaXM7ZS5vZmYoXCJjbGljay56Zi5kcm9wZG93blwiKS5vbihcImNsaWNrLnpmLmRyb3Bkb3duXCIsZnVuY3Rpb24odCl7aS4kYW5jaG9yLmlzKHQudGFyZ2V0KXx8aS4kYW5jaG9yLmZpbmQodC50YXJnZXQpLmxlbmd0aHx8aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KS5sZW5ndGh8fChpLmNsb3NlKCksZS5vZmYoXCJjbGljay56Zi5kcm9wZG93blwiKSl9KX19LHtrZXk6XCJvcGVuXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJjbG9zZW1lLnpmLmRyb3Bkb3duXCIsdGhpcy4kZWxlbWVudC5hdHRyKFwiaWRcIikpLHRoaXMuJGFuY2hvci5hZGRDbGFzcyhcImhvdmVyXCIpLmF0dHIoe1wiYXJpYS1leHBhbmRlZFwiOiEwfSksdGhpcy5fc2V0UG9zaXRpb24oKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiaXMtb3BlblwiKS5hdHRyKHtcImFyaWEtaGlkZGVuXCI6ITF9KSx0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXt2YXIgdD1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7dC5sZW5ndGgmJnQuZXEoMCkuZm9jdXMoKX10aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLl9hZGRCb2R5SGFuZGxlcigpLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJkZvdW5kYXRpb24uS2V5Ym9hcmQudHJhcEZvY3VzKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInNob3cuemYuZHJvcGRvd25cIixbdGhpcy4kZWxlbWVudF0pfX0se2tleTpcImNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImlzLW9wZW5cIikpcmV0dXJuITE7aWYodGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImlzLW9wZW5cIikuYXR0cih7XCJhcmlhLWhpZGRlblwiOiEwfSksdGhpcy4kYW5jaG9yLnJlbW92ZUNsYXNzKFwiaG92ZXJcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksdGhpcy5jbGFzc0NoYW5nZWQpe3ZhciB0PXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO3QmJnRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcykuY3NzKHtoZWlnaHQ6XCJcIix3aWR0aDpcIlwifSksdGhpcy5jbGFzc0NoYW5nZWQ9ITEsdGhpcy5jb3VudGVyPTQsdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aD0wfXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImhpZGUuemYuZHJvcGRvd25cIixbdGhpcy4kZWxlbWVudF0pLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJkZvdW5kYXRpb24uS2V5Ym9hcmQucmVsZWFzZUZvY3VzKHRoaXMuJGVsZW1lbnQpfX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImlzLW9wZW5cIikpe2lmKHRoaXMuJGFuY2hvci5kYXRhKFwiaG92ZXJcIikpcmV0dXJuO3RoaXMuY2xvc2UoKX1lbHNlIHRoaXMub3BlbigpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLnRyaWdnZXJcIikuaGlkZSgpLHRoaXMuJGFuY2hvci5vZmYoXCIuemYuZHJvcGRvd25cIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO2UuZGVmYXVsdHM9e3BhcmVudENsYXNzOm51bGwsaG92ZXJEZWxheToyNTAsaG92ZXI6ITEsaG92ZXJQYW5lOiExLHZPZmZzZXQ6MSxoT2Zmc2V0OjEscG9zaXRpb25DbGFzczpcIlwiLHRyYXBGb2N1czohMSxhdXRvRm9jdXM6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiRHJvcGRvd25cIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcImRyb3Bkb3duXCIpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXCJEcm9wZG93bk1lbnVcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcIkRyb3Bkb3duTWVudVwiLHtFTlRFUjpcIm9wZW5cIixTUEFDRTpcIm9wZW5cIixBUlJPV19SSUdIVDpcIm5leHRcIixBUlJPV19VUDpcInVwXCIsQVJST1dfRE9XTjpcImRvd25cIixBUlJPV19MRUZUOlwicHJldmlvdXNcIixFU0NBUEU6XCJjbG9zZVwifSl9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XCIpO3RoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXCIuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcIikuY2hpbGRyZW4oXCIuaXMtZHJvcGRvd24tc3VibWVudVwiKS5hZGRDbGFzcyhcImZpcnN0LXN1YlwiKSx0aGlzLiRtZW51SXRlbXM9dGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cIm1lbnVpdGVtXCJdJyksdGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbcm9sZT1cIm1lbnVpdGVtXCJdJyksdGhpcy4kdGFicy5maW5kKFwidWwuaXMtZHJvcGRvd24tc3VibWVudVwiKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyksdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcyl8fFwicmlnaHRcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnR8fEZvdW5kYXRpb24ucnRsKCl8fHRoaXMuJGVsZW1lbnQucGFyZW50cyhcIi50b3AtYmFyLXJpZ2h0XCIpLmlzKFwiKlwiKT8odGhpcy5vcHRpb25zLmFsaWdubWVudD1cInJpZ2h0XCIsdC5hZGRDbGFzcyhcIm9wZW5zLWxlZnRcIikpOnQuYWRkQ2xhc3MoXCJvcGVucy1yaWdodFwiKSx0aGlzLmNoYW5nZWQ9ITEsdGhpcy5fZXZlbnRzKCl9fSx7a2V5OlwiX2lzVmVydGljYWxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwiYmxvY2tcIj09PXRoaXMuJHRhYnMuY3NzKFwiZGlzcGxheVwiKX19LHtrZXk6XCJfZXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLGk9XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQsbj1cImlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XCIscz1mdW5jdGlvbihzKXt2YXIgbz10KHMudGFyZ2V0KS5wYXJlbnRzVW50aWwoXCJ1bFwiLFwiLlwiK24pLGE9by5oYXNDbGFzcyhuKSxyPVwidHJ1ZVwiPT09by5hdHRyKFwiZGF0YS1pcy1jbGlja1wiKSxsPW8uY2hpbGRyZW4oXCIuaXMtZHJvcGRvd24tc3VibWVudVwiKTtpZihhKWlmKHIpe2lmKCFlLm9wdGlvbnMuY2xvc2VPbkNsaWNrfHwhZS5vcHRpb25zLmNsaWNrT3BlbiYmIWl8fGUub3B0aW9ucy5mb3JjZUZvbGxvdyYmaSlyZXR1cm47cy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxzLnByZXZlbnREZWZhdWx0KCksZS5faGlkZShvKX1lbHNlIHMucHJldmVudERlZmF1bHQoKSxzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGUuX3Nob3cobCksby5hZGQoby5wYXJlbnRzVW50aWwoZS4kZWxlbWVudCxcIi5cIituKSkuYXR0cihcImRhdGEtaXMtY2xpY2tcIiwhMCl9Oyh0aGlzLm9wdGlvbnMuY2xpY2tPcGVufHxpKSYmdGhpcy4kbWVudUl0ZW1zLm9uKFwiY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51XCIscyksZS5vcHRpb25zLmNsb3NlT25DbGlja0luc2lkZSYmdGhpcy4kbWVudUl0ZW1zLm9uKFwiY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVwiLGZ1bmN0aW9uKGkpe3ZhciBzPXQodGhpcyksbz1zLmhhc0NsYXNzKG4pO298fGUuX2hpZGUoKX0pLHRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJG1lbnVJdGVtcy5vbihcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51XCIsZnVuY3Rpb24oaSl7dmFyIHM9dCh0aGlzKSxvPXMuaGFzQ2xhc3Mobik7byYmKGNsZWFyVGltZW91dChzLmRhdGEoXCJfZGVsYXlcIikpLHMuZGF0YShcIl9kZWxheVwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9zaG93KHMuY2hpbGRyZW4oXCIuaXMtZHJvcGRvd24tc3VibWVudVwiKSl9LGUub3B0aW9ucy5ob3ZlckRlbGF5KSkpfSkub24oXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3dubWVudVwiLGZ1bmN0aW9uKGkpe3ZhciBzPXQodGhpcyksbz1zLmhhc0NsYXNzKG4pO2lmKG8mJmUub3B0aW9ucy5hdXRvY2xvc2Upe2lmKFwidHJ1ZVwiPT09cy5hdHRyKFwiZGF0YS1pcy1jbGlja1wiKSYmZS5vcHRpb25zLmNsaWNrT3BlbilyZXR1cm4hMTtjbGVhclRpbWVvdXQocy5kYXRhKFwiX2RlbGF5XCIpKSxzLmRhdGEoXCJfZGVsYXlcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5faGlkZShzKX0sZS5vcHRpb25zLmNsb3NpbmdUaW1lKSl9fSksdGhpcy4kbWVudUl0ZW1zLm9uKFwia2V5ZG93bi56Zi5kcm9wZG93bm1lbnVcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dChpLnRhcmdldCkucGFyZW50c1VudGlsKFwidWxcIiwnW3JvbGU9XCJtZW51aXRlbVwiXScpLGE9ZS4kdGFicy5pbmRleChvKT4tMSxyPWE/ZS4kdGFiczpvLnNpYmxpbmdzKFwibGlcIikuYWRkKG8pO3IuZWFjaChmdW5jdGlvbihlKXtpZih0KHRoaXMpLmlzKG8pKXJldHVybiBuPXIuZXEoZS0xKSx2b2lkKHM9ci5lcShlKzEpKX0pO3ZhciBsPWZ1bmN0aW9uKCl7by5pcyhcIjpsYXN0LWNoaWxkXCIpfHwocy5jaGlsZHJlbihcImE6Zmlyc3RcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpfSx1PWZ1bmN0aW9uKCl7bi5jaGlsZHJlbihcImE6Zmlyc3RcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCl9LGQ9ZnVuY3Rpb24oKXt2YXIgdD1vLmNoaWxkcmVuKFwidWwuaXMtZHJvcGRvd24tc3VibWVudVwiKTt0Lmxlbmd0aCYmKGUuX3Nob3codCksby5maW5kKFwibGkgPiBhOmZpcnN0XCIpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKX0saD1mdW5jdGlvbigpe3ZhciB0PW8ucGFyZW50KFwidWxcIikucGFyZW50KFwibGlcIik7dC5jaGlsZHJlbihcImE6Zmlyc3RcIikuZm9jdXMoKSxlLl9oaWRlKHQpLGkucHJldmVudERlZmF1bHQoKX0sYz17b3BlbjpkLGNsb3NlOmZ1bmN0aW9uKCl7ZS5faGlkZShlLiRlbGVtZW50KSxlLiRtZW51SXRlbXMuZmluZChcImE6Zmlyc3RcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCl9LGhhbmRsZWQ6ZnVuY3Rpb24oKXtpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfX07YT9lLl9pc1ZlcnRpY2FsKCk/Rm91bmRhdGlvbi5ydGwoKT90LmV4dGVuZChjLHtkb3duOmwsdXA6dSxuZXh0OmgscHJldmlvdXM6ZH0pOnQuZXh0ZW5kKGMse2Rvd246bCx1cDp1LG5leHQ6ZCxwcmV2aW91czpofSk6Rm91bmRhdGlvbi5ydGwoKT90LmV4dGVuZChjLHtuZXh0OnUscHJldmlvdXM6bCxkb3duOmQsdXA6aH0pOnQuZXh0ZW5kKGMse25leHQ6bCxwcmV2aW91czp1LGRvd246ZCx1cDpofSk6Rm91bmRhdGlvbi5ydGwoKT90LmV4dGVuZChjLHtuZXh0OmgscHJldmlvdXM6ZCxkb3duOmwsdXA6dX0pOnQuZXh0ZW5kKGMse25leHQ6ZCxwcmV2aW91czpoLGRvd246bCx1cDp1fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcIkRyb3Bkb3duTWVudVwiLGMpfSl9fSx7a2V5OlwiX2FkZEJvZHlIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLGk9dGhpcztlLm9mZihcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVwiKS5vbihcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVwiLGZ1bmN0aW9uKHQpe3ZhciBuPWkuJGVsZW1lbnQuZmluZCh0LnRhcmdldCk7bi5sZW5ndGh8fChpLl9oaWRlKCksZS5vZmYoXCJtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnVcIikpfSl9fSx7a2V5OlwiX3Nob3dcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uKGksbil7cmV0dXJuIHQobikuZmluZChlKS5sZW5ndGg+MH0pKSxuPWUucGFyZW50KFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcIikuc2libGluZ3MoXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFwiKTt0aGlzLl9oaWRlKG4saSksZS5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIikuYWRkQ2xhc3MoXCJqcy1kcm9wZG93bi1hY3RpdmVcIikucGFyZW50KFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcIikuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIik7dmFyIHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApO2lmKCFzKXt2YXIgbz1cImxlZnRcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ/XCItcmlnaHRcIjpcIi1sZWZ0XCIsYT1lLnBhcmVudChcIi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFwiKTthLnJlbW92ZUNsYXNzKFwib3BlbnNcIitvKS5hZGRDbGFzcyhcIm9wZW5zLVwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApLHN8fGEucmVtb3ZlQ2xhc3MoXCJvcGVucy1cIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcIm9wZW5zLWlubmVyXCIpLHRoaXMuY2hhbmdlZD0hMH1lLmNzcyhcInZpc2liaWxpdHlcIixcIlwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLl9hZGRCb2R5SGFuZGxlcigpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInNob3cuemYuZHJvcGRvd25tZW51XCIsW2VdKX19LHtrZXk6XCJfaGlkZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk7aT10JiZ0Lmxlbmd0aD90OnZvaWQgMCE9PWU/dGhpcy4kdGFicy5ub3QoZnVuY3Rpb24odCxpKXtyZXR1cm4gdD09PWV9KTp0aGlzLiRlbGVtZW50O3ZhciBuPWkuaGFzQ2xhc3MoXCJpcy1hY3RpdmVcIil8fGkuZmluZChcIi5pcy1hY3RpdmVcIikubGVuZ3RoPjA7aWYobil7aWYoaS5maW5kKFwibGkuaXMtYWN0aXZlXCIpLmFkZChpKS5hdHRyKHtcImRhdGEtaXMtY2xpY2tcIjohMX0pLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlXCIpLGkuZmluZChcInVsLmpzLWRyb3Bkb3duLWFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImpzLWRyb3Bkb3duLWFjdGl2ZVwiKSx0aGlzLmNoYW5nZWR8fGkuZmluZChcIm9wZW5zLWlubmVyXCIpLmxlbmd0aCl7dmFyIHM9XCJsZWZ0XCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50P1wicmlnaHRcIjpcImxlZnRcIjtpLmZpbmQoXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFwiKS5hZGQoaSkucmVtb3ZlQ2xhc3MoXCJvcGVucy1pbm5lciBvcGVucy1cIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcIm9wZW5zLVwiK3MpLHRoaXMuY2hhbmdlZD0hMX10aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJoaWRlLnpmLmRyb3Bkb3dubWVudVwiLFtpXSl9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJG1lbnVJdGVtcy5vZmYoXCIuemYuZHJvcGRvd25tZW51XCIpLnJlbW92ZUF0dHIoXCJkYXRhLWlzLWNsaWNrXCIpLnJlbW92ZUNsYXNzKFwiaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXJcIiksdChkb2N1bWVudC5ib2R5KS5vZmYoXCIuemYuZHJvcGRvd25tZW51XCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXCJkcm9wZG93blwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUhvdmVyOiExLGF1dG9jbG9zZTohMCxob3ZlckRlbGF5OjUwLGNsaWNrT3BlbjohMSxjbG9zaW5nVGltZTo1MDAsYWxpZ25tZW50OlwibGVmdFwiLGNsb3NlT25DbGljazohMCxjbG9zZU9uQ2xpY2tJbnNpZGU6ITAsdmVydGljYWxDbGFzczpcInZlcnRpY2FsXCIscmlnaHRDbGFzczpcImFsaWduLXJpZ2h0XCIsZm9yY2VGb2xsb3c6ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXCJEcm9wZG93bk1lbnVcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIkVxdWFsaXplclwiKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFwiZGF0YS1lcXVhbGl6ZXJcIil8fFwiXCIsaT10aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplci13YXRjaD1cIicrZSsnXCJdJyk7dGhpcy4kd2F0Y2hlZD1pLmxlbmd0aD9pOnRoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLWVxdWFsaXplci13YXRjaF1cIiksdGhpcy4kZWxlbWVudC5hdHRyKFwiZGF0YS1yZXNpemVcIixlfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXCJlcVwiKSksdGhpcy4kZWxlbWVudC5hdHRyKFwiZGF0YS1tdXRhdGVcIixlfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXCJlcVwiKSksdGhpcy5oYXNOZXN0ZWQ9dGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtZXF1YWxpemVyXVwiKS5sZW5ndGg+MCx0aGlzLmlzTmVzdGVkPXRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksXCJbZGF0YS1lcXVhbGl6ZXJdXCIpLmxlbmd0aD4wLHRoaXMuaXNPbj0hMSx0aGlzLl9iaW5kSGFuZGxlcj17b25SZXNpemVNZUJvdW5kOnRoaXMuX29uUmVzaXplTWUuYmluZCh0aGlzKSxvblBvc3RFcXVhbGl6ZWRCb3VuZDp0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKX07dmFyIG4scz10aGlzLiRlbGVtZW50LmZpbmQoXCJpbWdcIik7dGhpcy5vcHRpb25zLmVxdWFsaXplT24/KG49dGhpcy5fY2hlY2tNUSgpLHQod2luZG93KS5vbihcImNoYW5nZWQuemYubWVkaWFxdWVyeVwiLHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSkpOnRoaXMuX2V2ZW50cygpLCh2b2lkIDAhPT1uJiZuPT09ITF8fHZvaWQgMD09PW4pJiYocy5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChzLHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTp0aGlzLl9yZWZsb3coKSl9fSx7a2V5OlwiX3BhdXNlRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmlzT249ITEsdGhpcy4kZWxlbWVudC5vZmYoe1wiLnpmLmVxdWFsaXplclwiOnRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFwicmVzaXplbWUuemYudHJpZ2dlclwiOnRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCxcIm11dGF0ZW1lLnpmLnRyaWdnZXJcIjp0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmR9KX19LHtrZXk6XCJfb25SZXNpemVNZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX3JlZmxvdygpfX0se2tleTpcIl9vblBvc3RFcXVhbGl6ZWRcIix2YWx1ZTpmdW5jdGlvbih0KXt0LnRhcmdldCE9PXRoaXMuJGVsZW1lbnRbMF0mJnRoaXMuX3JlZmxvdygpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy5oYXNOZXN0ZWQ/dGhpcy4kZWxlbWVudC5vbihcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXCIsdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpOih0aGlzLiRlbGVtZW50Lm9uKFwicmVzaXplbWUuemYudHJpZ2dlclwiLHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCksdGhpcy4kZWxlbWVudC5vbihcIm11dGF0ZW1lLnpmLnRyaWdnZXJcIix0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpKSx0aGlzLmlzT249ITB9fSx7a2V5OlwiX2NoZWNrTVFcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PSFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuaXModGhpcy5vcHRpb25zLmVxdWFsaXplT24pO3JldHVybiB0P3RoaXMuaXNPbiYmKHRoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXCJoZWlnaHRcIixcImF1dG9cIikpOnRoaXMuaXNPbnx8dGhpcy5fZXZlbnRzKCksdH19LHtrZXk6XCJfa2lsbHN3aXRjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcIl9yZWZsb3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrJiZ0aGlzLl9pc1N0YWNrZWQoKT8odGhpcy4kd2F0Y2hlZC5jc3MoXCJoZWlnaHRcIixcImF1dG9cIiksITEpOnZvaWQodGhpcy5vcHRpb25zLmVxdWFsaXplQnlSb3c/dGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpOnRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpKX19LHtrZXk6XCJfaXNTdGFja2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy4kd2F0Y2hlZFswXXx8IXRoaXMuJHdhdGNoZWRbMV18fHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIT09dGhpcy4kd2F0Y2hlZFsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3B9fSx7a2V5OlwiZ2V0SGVpZ2h0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxpPTAsbj10aGlzLiR3YXRjaGVkLmxlbmd0aDtpPG47aSsrKXRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0PVwiYXV0b1wiLGUucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7dChlKX19LHtrZXk6XCJnZXRIZWlnaHRzQnlSb3dcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLiR3YXRjaGVkLmxlbmd0aD90aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wOjAsbj1bXSxzPTA7bltzXT1bXTtmb3IodmFyIG89MCxhPXRoaXMuJHdhdGNoZWQubGVuZ3RoO288YTtvKyspe3RoaXMuJHdhdGNoZWRbb10uc3R5bGUuaGVpZ2h0PVwiYXV0b1wiO3ZhciByPXQodGhpcy4kd2F0Y2hlZFtvXSkub2Zmc2V0KCkudG9wO3IhPWkmJihzKyssbltzXT1bXSxpPXIpLG5bc10ucHVzaChbdGhpcy4kd2F0Y2hlZFtvXSx0aGlzLiR3YXRjaGVkW29dLm9mZnNldEhlaWdodF0pfWZvcih2YXIgbD0wLHU9bi5sZW5ndGg7bDx1O2wrKyl7dmFyIGQ9dChuW2xdKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1sxXX0pLmdldCgpLGg9TWF0aC5tYXguYXBwbHkobnVsbCxkKTtuW2xdLnB1c2goaCl9ZShuKX19LHtrZXk6XCJhcHBseUhlaWdodFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGgubWF4LmFwcGx5KG51bGwsdCk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclwiKSx0aGlzLiR3YXRjaGVkLmNzcyhcImhlaWdodFwiLGUpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXCIpfX0se2tleTpcImFwcGx5SGVpZ2h0QnlSb3dcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyXCIpO2Zvcih2YXIgaT0wLG49ZS5sZW5ndGg7aTxuO2krKyl7dmFyIHM9ZVtpXS5sZW5ndGgsbz1lW2ldW3MtMV07aWYoczw9Mil0KGVbaV1bMF1bMF0pLmNzcyh7aGVpZ2h0OlwiYXV0b1wifSk7ZWxzZXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJwcmVlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyXCIpO2Zvcih2YXIgYT0wLHI9cy0xO2E8cjthKyspdChlW2ldW2FdWzBdKS5jc3Moe2hlaWdodDpvfSk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwicG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXJcIil9fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXCIpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXCJoZWlnaHRcIixcImF1dG9cIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO2UuZGVmYXVsdHM9e2VxdWFsaXplT25TdGFjazohMSxlcXVhbGl6ZUJ5Um93OiExLGVxdWFsaXplT246XCJcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIkVxdWFsaXplclwiKX0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZX19KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyxuKSx0aGlzLnJ1bGVzPVtdLHRoaXMuY3VycmVudFBhdGg9XCJcIix0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiSW50ZXJjaGFuZ2VcIil9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2FkZEJyZWFrcG9pbnRzKCksdGhpcy5fZ2VuZXJhdGVSdWxlcygpLHRoaXMuX3JlZmxvdygpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFwicmVzaXplLnpmLmludGVyY2hhbmdlXCIsRm91bmRhdGlvbi51dGlsLnRocm90dGxlKGZ1bmN0aW9uKCl7ZS5fcmVmbG93KCl9LDUwKSl9fSx7a2V5OlwiX3JlZmxvd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7Zm9yKHZhciBlIGluIHRoaXMucnVsZXMpaWYodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIGk9dGhpcy5ydWxlc1tlXTt3aW5kb3cubWF0Y2hNZWRpYShpLnF1ZXJ5KS5tYXRjaGVzJiYodD1pKX10JiZ0aGlzLnJlcGxhY2UodC5wYXRoKX19LHtrZXk6XCJfYWRkQnJlYWtwb2ludHNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcylpZihGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcy5oYXNPd25Qcm9wZXJ0eSh0KSl7dmFyIGk9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXNbdF07ZS5TUEVDSUFMX1FVRVJJRVNbaS5uYW1lXT1pLnZhbHVlfX19LHtrZXk6XCJfZ2VuZXJhdGVSdWxlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpLG49W107aT10aGlzLm9wdGlvbnMucnVsZXM/dGhpcy5vcHRpb25zLnJ1bGVzOnRoaXMuJGVsZW1lbnQuZGF0YShcImludGVyY2hhbmdlXCIpLm1hdGNoKC9cXFsuKj9cXF0vZyk7Zm9yKHZhciBzIGluIGkpaWYoaS5oYXNPd25Qcm9wZXJ0eShzKSl7dmFyIG89aVtzXS5zbGljZSgxLC0xKS5zcGxpdChcIiwgXCIpLGE9by5zbGljZSgwLC0xKS5qb2luKFwiXCIpLHI9b1tvLmxlbmd0aC0xXTtlLlNQRUNJQUxfUVVFUklFU1tyXSYmKHI9ZS5TUEVDSUFMX1FVRVJJRVNbcl0pLG4ucHVzaCh7cGF0aDphLHF1ZXJ5OnJ9KX10aGlzLnJ1bGVzPW59fSx7a2V5OlwicmVwbGFjZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuY3VycmVudFBhdGghPT1lKXt2YXIgaT10aGlzLG49XCJyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZVwiO1wiSU1HXCI9PT10aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lP3RoaXMuJGVsZW1lbnQuYXR0cihcInNyY1wiLGUpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7aS5jdXJyZW50UGF0aD1lfSkudHJpZ2dlcihuKTplLm1hdGNoKC9cXC4oZ2lmfGpwZ3xqcGVnfHBuZ3xzdmd8dGlmZikoWz8jXS4qKT8vaSk/dGhpcy4kZWxlbWVudC5jc3Moe1wiYmFja2dyb3VuZC1pbWFnZVwiOlwidXJsKFwiK2UrXCIpXCJ9KS50cmlnZ2VyKG4pOnQuZ2V0KGUsZnVuY3Rpb24ocyl7aS4kZWxlbWVudC5odG1sKHMpLnRyaWdnZXIobiksdChzKS5mb3VuZGF0aW9uKCksaS5jdXJyZW50UGF0aD1lfSl9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe319XSksZX0oKTtlLmRlZmF1bHRzPXtydWxlczpudWxsfSxlLlNQRUNJQUxfUVVFUklFUz17bGFuZHNjYXBlOlwic2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIixwb3J0cmFpdDpcInNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIixyZXRpbmE6XCJvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweClcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIkludGVyY2hhbmdlXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSx0aGlzLmNhbGNQb2ludHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXCJNYWdlbGxhblwiKTtcbn1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy4kZWxlbWVudFswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFwibWFnZWxsYW5cIik7dGhpcy4kdGFyZ2V0cz10KFwiW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XVwiKSx0aGlzLiRsaW5rcz10aGlzLiRlbGVtZW50LmZpbmQoXCJhXCIpLHRoaXMuJGVsZW1lbnQuYXR0cih7XCJkYXRhLXJlc2l6ZVwiOmUsXCJkYXRhLXNjcm9sbFwiOmUsaWQ6ZX0pLHRoaXMuJGFjdGl2ZT10KCksdGhpcy5zY3JvbGxQb3M9cGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LDEwKSx0aGlzLl9ldmVudHMoKX19LHtrZXk6XCJjYWxjUG9pbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLGk9ZG9jdW1lbnQuYm9keSxuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt0aGlzLnBvaW50cz1bXSx0aGlzLndpbkhlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCxuLmNsaWVudEhlaWdodCkpLHRoaXMuZG9jSGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoaS5zY3JvbGxIZWlnaHQsaS5vZmZzZXRIZWlnaHQsbi5jbGllbnRIZWlnaHQsbi5zY3JvbGxIZWlnaHQsbi5vZmZzZXRIZWlnaHQpKSx0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49TWF0aC5yb3VuZChpLm9mZnNldCgpLnRvcC1lLm9wdGlvbnMudGhyZXNob2xkKTtpLnRhcmdldFBvaW50PW4sZS5wb2ludHMucHVzaChuKX0pfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dChcImh0bWwsIGJvZHlcIikse2R1cmF0aW9uOmUub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixlYXNpbmc6ZS5vcHRpb25zLmFuaW1hdGlvbkVhc2luZ307dCh3aW5kb3cpLm9uZShcImxvYWRcIixmdW5jdGlvbigpe2Uub3B0aW9ucy5kZWVwTGlua2luZyYmbG9jYXRpb24uaGFzaCYmZS5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKSxlLmNhbGNQb2ludHMoKSxlLl91cGRhdGVBY3RpdmUoKX0pLHRoaXMuJGVsZW1lbnQub24oe1wicmVzaXplbWUuemYudHJpZ2dlclwiOnRoaXMucmVmbG93LmJpbmQodGhpcyksXCJzY3JvbGxtZS56Zi50cmlnZ2VyXCI6dGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQodGhpcyl9KS5vbihcImNsaWNrLnpmLm1hZ2VsbGFuXCIsJ2FbaHJlZl49XCIjXCJdJyxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCk7dmFyIGk9dGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO2Uuc2Nyb2xsVG9Mb2MoaSl9KSx0KHdpbmRvdykub24oXCJwb3BzdGF0ZVwiLGZ1bmN0aW9uKHQpe2Uub3B0aW9ucy5kZWVwTGlua2luZyYmZS5zY3JvbGxUb0xvYyh3aW5kb3cubG9jYXRpb24uaGFzaCl9KX19LHtrZXk6XCJzY3JvbGxUb0xvY1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCF0KGUpLmxlbmd0aClyZXR1cm4hMTt0aGlzLl9pblRyYW5zaXRpb249ITA7dmFyIGk9dGhpcyxuPU1hdGgucm91bmQodChlKS5vZmZzZXQoKS50b3AtdGhpcy5vcHRpb25zLnRocmVzaG9sZC8yLXRoaXMub3B0aW9ucy5iYXJPZmZzZXQpO3QoXCJodG1sLCBib2R5XCIpLnN0b3AoITApLmFuaW1hdGUoe3Njcm9sbFRvcDpufSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyxmdW5jdGlvbigpe2kuX2luVHJhbnNpdGlvbj0hMSxpLl91cGRhdGVBY3RpdmUoKX0pfX0se2tleTpcInJlZmxvd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jYWxjUG9pbnRzKCksdGhpcy5fdXBkYXRlQWN0aXZlKCl9fSx7a2V5OlwiX3VwZGF0ZUFjdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX2luVHJhbnNpdGlvbil7dmFyIHQsZT1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApO2lmKGUrdGhpcy53aW5IZWlnaHQ9PT10aGlzLmRvY0hlaWdodCl0PXRoaXMucG9pbnRzLmxlbmd0aC0xO2Vsc2UgaWYoZTx0aGlzLnBvaW50c1swXSl0PXZvaWQgMDtlbHNle3ZhciBpPXRoaXMuc2Nyb2xsUG9zPGUsbj10aGlzLHM9dGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHQscyl7cmV0dXJuIGk/dC1uLm9wdGlvbnMuYmFyT2Zmc2V0PD1lOnQtbi5vcHRpb25zLmJhck9mZnNldC1uLm9wdGlvbnMudGhyZXNob2xkPD1lfSk7dD1zLmxlbmd0aD9zLmxlbmd0aC0xOjB9aWYodGhpcy4kYWN0aXZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy4kYWN0aXZlPXRoaXMuJGxpbmtzLmZpbHRlcignW2hyZWY9XCIjJyt0aGlzLiR0YXJnZXRzLmVxKHQpLmRhdGEoXCJtYWdlbGxhbi10YXJnZXRcIikrJ1wiXScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXt2YXIgbz1cIlwiO3ZvaWQgMCE9dCYmKG89dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZShcImhyZWZcIikpLG8hPT13aW5kb3cubG9jYXRpb24uaGFzaCYmKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLG8pOndpbmRvdy5sb2NhdGlvbi5oYXNoPW8pfXRoaXMuc2Nyb2xsUG9zPWUsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwidXBkYXRlLnpmLm1hZ2VsbGFuXCIsW3RoaXMuJGFjdGl2ZV0pfX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLiRlbGVtZW50Lm9mZihcIi56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhblwiKS5maW5kKFwiLlwiK3RoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSx0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe3ZhciB0PXRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO3dpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UodCxcIlwiKX1Gb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17YW5pbWF0aW9uRHVyYXRpb246NTAwLGFuaW1hdGlvbkVhc2luZzpcImxpbmVhclwiLHRocmVzaG9sZDo1MCxhY3RpdmVDbGFzczpcImFjdGl2ZVwiLGRlZXBMaW5raW5nOiExLGJhck9mZnNldDowfSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiTWFnZWxsYW5cIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy4kbGFzdFRyaWdnZXI9dCgpLHRoaXMuJHRyaWdnZXJzPXQoKSx0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiT2ZmQ2FudmFzXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXCJPZmZDYW52YXNcIix7RVNDQVBFOlwiY2xvc2VcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXCJpZFwiKTtpZih0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiaXMtdHJhbnNpdGlvbi1cIit0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiksdGhpcy4kdHJpZ2dlcnM9dChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cIicrZSsnXCJdLCBbZGF0YS1jbG9zZT1cIicrZSsnXCJdLCBbZGF0YS10b2dnbGU9XCInK2UrJ1wiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKS5hdHRyKFwiYXJpYS1jb250cm9sc1wiLGUpLHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT09PSEwKXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG49XCJmaXhlZFwiPT09dCh0aGlzLiRlbGVtZW50KS5jc3MoXCJwb3NpdGlvblwiKT9cImlzLW92ZXJsYXktZml4ZWRcIjpcImlzLW92ZXJsYXktYWJzb2x1dGVcIjtpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJqcy1vZmYtY2FudmFzLW92ZXJsYXkgXCIrbiksdGhpcy4kb3ZlcmxheT10KGkpLFwiaXMtb3ZlcmxheS1maXhlZFwiPT09bj90KFwiYm9keVwiKS5hcHBlbmQodGhpcy4kb3ZlcmxheSk6dGhpcy4kZWxlbWVudC5zaWJsaW5ncyhcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cIikuYXBwZW5kKHRoaXMuJG92ZXJsYXkpfXRoaXMub3B0aW9ucy5pc1JldmVhbGVkPXRoaXMub3B0aW9ucy5pc1JldmVhbGVkfHxuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcyxcImdcIikudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSksdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQ9PT0hMCYmKHRoaXMub3B0aW9ucy5yZXZlYWxPbj10aGlzLm9wdGlvbnMucmV2ZWFsT258fHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8ocmV2ZWFsLWZvci1tZWRpdW18cmV2ZWFsLWZvci1sYXJnZSkvZylbMF0uc3BsaXQoXCItXCIpWzJdLHRoaXMuX3NldE1RQ2hlY2tlcigpKSwhdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lPT0hMCYmKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZT0xZTMqcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KFwiW2RhdGEtb2ZmLWNhbnZhc11cIilbMF0pLnRyYW5zaXRpb25EdXJhdGlvbikpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhc1wiKS5vbih7XCJvcGVuLnpmLnRyaWdnZXJcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcImNsb3NlLnpmLnRyaWdnZXJcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXCJ0b2dnbGUuemYudHJpZ2dlclwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXCJrZXlkb3duLnpmLm9mZmNhbnZhc1wiOnRoaXMuX2hhbmRsZUtleWJvYXJkLmJpbmQodGhpcyl9KSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrPT09ITApe3ZhciBlPXRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT90aGlzLiRvdmVybGF5OnQoXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXCIpO2Uub24oe1wiY2xpY2suemYub2ZmY2FudmFzXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpfSl9fX0se2tleTpcIl9zZXRNUUNoZWNrZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsZnVuY3Rpb24oKXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChlLm9wdGlvbnMucmV2ZWFsT24pP2UucmV2ZWFsKCEwKTplLnJldmVhbCghMSl9KS5vbmUoXCJsb2FkLnpmLm9mZmNhbnZhc1wiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKSYmZS5yZXZlYWwoITApfSl9fSx7a2V5OlwicmV2ZWFsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtY2xvc2VdXCIpO3Q/KHRoaXMuY2xvc2UoKSx0aGlzLmlzUmV2ZWFsZWQ9ITAsdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFwib3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyXCIpLGUubGVuZ3RoJiZlLmhpZGUoKSk6KHRoaXMuaXNSZXZlYWxlZD0hMSx0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSx0aGlzLiRlbGVtZW50Lm9uKHtcIm9wZW4uemYudHJpZ2dlclwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFwidG9nZ2xlLnpmLnRyaWdnZXJcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpfSksZS5sZW5ndGgmJmUuc2hvdygpKX19LHtrZXk6XCJfc3RvcFNjcm9sbGluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiExfX0se2tleTpcIm9wZW5cIix2YWx1ZTpmdW5jdGlvbihlLGkpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaXMtb3BlblwiKSYmIXRoaXMuaXNSZXZlYWxlZCl7dmFyIG49dGhpcztpJiYodGhpcy4kbGFzdFRyaWdnZXI9aSksXCJ0b3BcIj09PXRoaXMub3B0aW9ucy5mb3JjZVRvP3dpbmRvdy5zY3JvbGxUbygwLDApOlwiYm90dG9tXCI9PT10aGlzLm9wdGlvbnMuZm9yY2VUbyYmd2luZG93LnNjcm9sbFRvKDAsZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpLG4uJGVsZW1lbnQuYWRkQ2xhc3MoXCJpcy1vcGVuXCIpLHRoaXMuJHRyaWdnZXJzLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKS50cmlnZ2VyKFwib3BlbmVkLnpmLm9mZmNhbnZhc1wiKSx0aGlzLm9wdGlvbnMuY29udGVudFNjcm9sbD09PSExJiZ0KFwiYm9keVwiKS5hZGRDbGFzcyhcImlzLW9mZi1jYW52YXMtb3BlblwiKS5vbihcInRvdWNobW92ZVwiLHRoaXMuX3N0b3BTY3JvbGxpbmcpLHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT09PSEwJiZ0aGlzLiRvdmVybGF5LmFkZENsYXNzKFwiaXMtdmlzaWJsZVwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrPT09ITAmJnRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT09PSEwJiZ0aGlzLiRvdmVybGF5LmFkZENsYXNzKFwiaXMtY2xvc2FibGVcIiksdGhpcy5vcHRpb25zLmF1dG9Gb2N1cz09PSEwJiZ0aGlzLiRlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodGhpcy4kZWxlbWVudCksZnVuY3Rpb24oKXtuLiRlbGVtZW50LmZpbmQoXCJhLCBidXR0b25cIikuZXEoMCkuZm9jdXMoKX0pLHRoaXMub3B0aW9ucy50cmFwRm9jdXM9PT0hMCYmKHRoaXMuJGVsZW1lbnQuc2libGluZ3MoXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXCIpLmF0dHIoXCJ0YWJpbmRleFwiLFwiLTFcIiksRm91bmRhdGlvbi5LZXlib2FyZC50cmFwRm9jdXModGhpcy4kZWxlbWVudCkpfX19LHtrZXk6XCJjbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpcy1vcGVuXCIpJiYhdGhpcy5pc1JldmVhbGVkKXt2YXIgaT10aGlzO2kuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJpcy1vcGVuXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLnRyaWdnZXIoXCJjbG9zZWQuemYub2ZmY2FudmFzXCIpLHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsPT09ITEmJnQoXCJib2R5XCIpLnJlbW92ZUNsYXNzKFwiaXMtb2ZmLWNhbnZhcy1vcGVuXCIpLm9mZihcInRvdWNobW92ZVwiLHRoaXMuX3N0b3BTY3JvbGxpbmcpLHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT09PSEwJiZ0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKFwiaXMtdmlzaWJsZVwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrPT09ITAmJnRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheT09PSEwJiZ0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKFwiaXMtY2xvc2FibGVcIiksdGhpcy4kdHJpZ2dlcnMuYXR0cihcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLHRoaXMub3B0aW9ucy50cmFwRm9jdXM9PT0hMCYmKHRoaXMuJGVsZW1lbnQuc2libGluZ3MoXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXCIpLnJlbW92ZUF0dHIoXCJ0YWJpbmRleFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlbGVhc2VGb2N1cyh0aGlzLiRlbGVtZW50KSl9fX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImlzLW9wZW5cIik/dGhpcy5jbG9zZSh0LGUpOnRoaXMub3Blbih0LGUpfX0se2tleTpcIl9oYW5kbGVLZXlib2FyZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkodCxcIk9mZkNhbnZhc1wiLHtjbG9zZTpmdW5jdGlvbigpe3JldHVybiBlLmNsb3NlKCksZS4kbGFzdFRyaWdnZXIuZm9jdXMoKSwhMH0saGFuZGxlZDpmdW5jdGlvbigpe3Quc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpfX0pfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2xvc2UoKSx0aGlzLiRlbGVtZW50Lm9mZihcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcIiksdGhpcy4kb3ZlcmxheS5vZmYoXCIuemYub2ZmY2FudmFzXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKX19XSksZX0oKTtlLmRlZmF1bHRzPXtjbG9zZU9uQ2xpY2s6ITAsY29udGVudE92ZXJsYXk6ITAsY29udGVudFNjcm9sbDohMCx0cmFuc2l0aW9uVGltZTowLHRyYW5zaXRpb246XCJwdXNoXCIsZm9yY2VUbzpudWxsLGlzUmV2ZWFsZWQ6ITEscmV2ZWFsT246bnVsbCxhdXRvRm9jdXM6ITAscmV2ZWFsQ2xhc3M6XCJyZXZlYWwtZm9yLVwiLHRyYXBGb2N1czohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIk9mZkNhbnZhc1wiKX0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZX19KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiT3JiaXRcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcIk9yYml0XCIse2x0cjp7QVJST1dfUklHSFQ6XCJuZXh0XCIsQVJST1dfTEVGVDpcInByZXZpb3VzXCJ9LHJ0bDp7QVJST1dfTEVGVDpcIm5leHRcIixBUlJPV19SSUdIVDpcInByZXZpb3VzXCJ9fSl9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3Jlc2V0KCksdGhpcy4kd3JhcHBlcj10aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSx0aGlzLiRzbGlkZXM9dGhpcy4kZWxlbWVudC5maW5kKFwiLlwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTt2YXIgdD10aGlzLiRlbGVtZW50LmZpbmQoXCJpbWdcIiksZT10aGlzLiRzbGlkZXMuZmlsdGVyKFwiLmlzLWFjdGl2ZVwiKSxpPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcIm9yYml0XCIpO3RoaXMuJGVsZW1lbnQuYXR0cih7XCJkYXRhLXJlc2l6ZVwiOmksaWQ6aX0pLGUubGVuZ3RofHx0aGlzLiRzbGlkZXMuZXEoMCkuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIiksdGhpcy5vcHRpb25zLnVzZU1VSXx8dGhpcy4kc2xpZGVzLmFkZENsYXNzKFwibm8tbW90aW9udWlcIiksdC5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCh0LHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTp0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKSx0aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy5fbG9hZEJ1bGxldHMoKSx0aGlzLl9ldmVudHMoKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSYmdGhpcy5nZW9TeW5jKCksdGhpcy5vcHRpb25zLmFjY2Vzc2libGUmJnRoaXMuJHdyYXBwZXIuYXR0cihcInRhYmluZGV4XCIsMCl9fSx7a2V5OlwiX2xvYWRCdWxsZXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRidWxsZXRzPXRoaXMuJGVsZW1lbnQuZmluZChcIi5cIit0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKFwiYnV0dG9uXCIpfX0se2tleTpcImdlb1N5bmNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50aW1lcj1uZXcgRm91bmRhdGlvbi5UaW1lcih0aGlzLiRlbGVtZW50LHtkdXJhdGlvbjp0aGlzLm9wdGlvbnMudGltZXJEZWxheSxpbmZpbml0ZTohMX0sZnVuY3Rpb24oKXt0LmNoYW5nZVNsaWRlKCEwKX0pLHRoaXMudGltZXIuc3RhcnQoKX19LHtrZXk6XCJfcHJlcGFyZUZvck9yYml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zZXRXcmFwcGVySGVpZ2h0KCl9fSx7a2V5OlwiX3NldFdyYXBwZXJIZWlnaHRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaSxuPTAscz0wLG89dGhpczt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe2k9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsdCh0aGlzKS5hdHRyKFwiZGF0YS1zbGlkZVwiLHMpLG8uJHNsaWRlcy5maWx0ZXIoXCIuaXMtYWN0aXZlXCIpWzBdIT09by4kc2xpZGVzLmVxKHMpWzBdJiZ0KHRoaXMpLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLGRpc3BsYXk6XCJub25lXCJ9KSxuPWk+bj9pOm4scysrfSkscz09PXRoaXMuJHNsaWRlcy5sZW5ndGgmJih0aGlzLiR3cmFwcGVyLmNzcyh7aGVpZ2h0Om59KSxlJiZlKG4pKX19LHtrZXk6XCJfc2V0U2xpZGVIZWlnaHRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe3QodGhpcykuY3NzKFwibWF4LWhlaWdodFwiLGUpfSl9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLiRlbGVtZW50Lm9mZihcIi5yZXNpemVtZS56Zi50cmlnZ2VyXCIpLm9uKHtcInJlc2l6ZW1lLnpmLnRyaWdnZXJcIjp0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKX0pLHRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7aWYodGhpcy5vcHRpb25zLnN3aXBlJiZ0aGlzLiRzbGlkZXMub2ZmKFwic3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXRcIikub24oXCJzd2lwZWxlZnQuemYub3JiaXRcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS5jaGFuZ2VTbGlkZSghMCl9KS5vbihcInN3aXBlcmlnaHQuemYub3JiaXRcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS5jaGFuZ2VTbGlkZSghMSl9KSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJih0aGlzLiRzbGlkZXMub24oXCJjbGljay56Zi5vcmJpdFwiLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC5kYXRhKFwiY2xpY2tlZE9uXCIsIWUuJGVsZW1lbnQuZGF0YShcImNsaWNrZWRPblwiKSksZS50aW1lcltlLiRlbGVtZW50LmRhdGEoXCJjbGlja2VkT25cIik/XCJwYXVzZVwiOlwic3RhcnRcIl0oKX0pLHRoaXMub3B0aW9ucy5wYXVzZU9uSG92ZXImJnRoaXMuJGVsZW1lbnQub24oXCJtb3VzZWVudGVyLnpmLm9yYml0XCIsZnVuY3Rpb24oKXtlLnRpbWVyLnBhdXNlKCl9KS5vbihcIm1vdXNlbGVhdmUuemYub3JiaXRcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcImNsaWNrZWRPblwiKXx8ZS50aW1lci5zdGFydCgpfSkpLHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLm5leHRDbGFzcytcIiwgLlwiK3RoaXMub3B0aW9ucy5wcmV2Q2xhc3MpO2kuYXR0cihcInRhYmluZGV4XCIsMCkub24oXCJjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdFwiLGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKHQodGhpcykuaGFzQ2xhc3MoZS5vcHRpb25zLm5leHRDbGFzcykpfSl9dGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuJGJ1bGxldHMub24oXCJjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdFwiLGZ1bmN0aW9uKCl7aWYoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKXJldHVybiExO3ZhciBpPXQodGhpcykuZGF0YShcInNsaWRlXCIpLG49aT5lLiRzbGlkZXMuZmlsdGVyKFwiLmlzLWFjdGl2ZVwiKS5kYXRhKFwic2xpZGVcIikscz1lLiRzbGlkZXMuZXEoaSk7ZS5jaGFuZ2VTbGlkZShuLHMsaSl9KSx0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSYmdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oXCJrZXlkb3duLnpmLm9yYml0XCIsZnVuY3Rpb24oaSl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcIk9yYml0XCIse25leHQ6ZnVuY3Rpb24oKXtlLmNoYW5nZVNsaWRlKCEwKX0scHJldmlvdXM6ZnVuY3Rpb24oKXtlLmNoYW5nZVNsaWRlKCExKX0saGFuZGxlZDpmdW5jdGlvbigpe3QoaS50YXJnZXQpLmlzKGUuJGJ1bGxldHMpJiZlLiRidWxsZXRzLmZpbHRlcihcIi5pcy1hY3RpdmVcIikuZm9jdXMoKX19KX0pfX19LHtrZXk6XCJfcmVzZXRcIix2YWx1ZTpmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPXR5cGVvZiB0aGlzLiRzbGlkZXMmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSYmKHRoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLm9yYml0XCIpLmZpbmQoXCIqXCIpLm9mZihcIi56Zi5vcmJpdFwiKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMudGltZXIucmVzdGFydCgpLHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGUpe3QoZSkucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmUgaXMtYWN0aXZlIGlzLWluXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWxpdmVcIikuaGlkZSgpfSksdGhpcy4kc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIikuc2hvdygpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInNsaWRlY2hhbmdlLnpmLm9yYml0XCIsW3RoaXMuJHNsaWRlcy5maXJzdCgpXSksdGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuX3VwZGF0ZUJ1bGxldHMoMCkpfX0se2tleTpcImNoYW5nZVNsaWRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe2lmKHRoaXMuJHNsaWRlcyl7dmFyIG49dGhpcy4kc2xpZGVzLmZpbHRlcihcIi5pcy1hY3RpdmVcIikuZXEoMCk7aWYoL211aS9nLnRlc3QoblswXS5jbGFzc05hbWUpKXJldHVybiExO3ZhciBzLG89dGhpcy4kc2xpZGVzLmZpcnN0KCksYT10aGlzLiRzbGlkZXMubGFzdCgpLHI9dD9cIlJpZ2h0XCI6XCJMZWZ0XCIsbD10P1wiTGVmdFwiOlwiUmlnaHRcIix1PXRoaXM7cz1lP2U6dD90aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwP24ubmV4dChcIi5cIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoP24ubmV4dChcIi5cIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk6bzpuLm5leHQoXCIuXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOnRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/bi5wcmV2KFwiLlwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGg/bi5wcmV2KFwiLlwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTphOm4ucHJldihcIi5cIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykscy5sZW5ndGgmJih0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJiZWZvcmVzbGlkZWNoYW5nZS56Zi5vcmJpdFwiLFtuLHNdKSx0aGlzLm9wdGlvbnMuYnVsbGV0cyYmKGk9aXx8dGhpcy4kc2xpZGVzLmluZGV4KHMpLHRoaXMuX3VwZGF0ZUJ1bGxldHMoaSkpLHRoaXMub3B0aW9ucy51c2VNVUkmJiF0aGlzLiRlbGVtZW50LmlzKFwiOmhpZGRlblwiKT8oRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHMuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIikuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOjB9KSx0aGlzLm9wdGlvbnNbXCJhbmltSW5Gcm9tXCIrcl0sZnVuY3Rpb24oKXtzLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLGRpc3BsYXk6XCJibG9ja1wifSkuYXR0cihcImFyaWEtbGl2ZVwiLFwicG9saXRlXCIpfSksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dChuLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlXCIpLHRoaXMub3B0aW9uc1tcImFuaW1PdXRUb1wiK2xdLGZ1bmN0aW9uKCl7bi5yZW1vdmVBdHRyKFwiYXJpYS1saXZlXCIpLHUub3B0aW9ucy5hdXRvUGxheSYmIXUudGltZXIuaXNQYXVzZWQmJnUudGltZXIucmVzdGFydCgpfSkpOihuLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlIGlzLWluXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWxpdmVcIikuaGlkZSgpLHMuYWRkQ2xhc3MoXCJpcy1hY3RpdmUgaXMtaW5cIikuYXR0cihcImFyaWEtbGl2ZVwiLFwicG9saXRlXCIpLnNob3coKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJiF0aGlzLnRpbWVyLmlzUGF1c2VkJiZ0aGlzLnRpbWVyLnJlc3RhcnQoKSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwic2xpZGVjaGFuZ2UuemYub3JiaXRcIixbc10pKX19fSx7a2V5OlwiX3VwZGF0ZUJ1bGxldHNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcIi5pcy1hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIikuYmx1cigpLGk9ZS5maW5kKFwic3BhbjpsYXN0XCIpLmRldGFjaCgpO3RoaXMuJGJ1bGxldHMuZXEodCkuYWRkQ2xhc3MoXCJpcy1hY3RpdmVcIikuYXBwZW5kKGkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLm9yYml0XCIpLmZpbmQoXCIqXCIpLm9mZihcIi56Zi5vcmJpdFwiKS5lbmQoKS5oaWRlKCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO2UuZGVmYXVsdHM9e2J1bGxldHM6ITAsbmF2QnV0dG9uczohMCxhbmltSW5Gcm9tUmlnaHQ6XCJzbGlkZS1pbi1yaWdodFwiLGFuaW1PdXRUb1JpZ2h0Olwic2xpZGUtb3V0LXJpZ2h0XCIsYW5pbUluRnJvbUxlZnQ6XCJzbGlkZS1pbi1sZWZ0XCIsYW5pbU91dFRvTGVmdDpcInNsaWRlLW91dC1sZWZ0XCIsYXV0b1BsYXk6ITAsdGltZXJEZWxheTo1ZTMsaW5maW5pdGVXcmFwOiEwLHN3aXBlOiEwLHBhdXNlT25Ib3ZlcjohMCxhY2Nlc3NpYmxlOiEwLGNvbnRhaW5lckNsYXNzOlwib3JiaXQtY29udGFpbmVyXCIsc2xpZGVDbGFzczpcIm9yYml0LXNsaWRlXCIsYm94T2ZCdWxsZXRzOlwib3JiaXQtYnVsbGV0c1wiLG5leHRDbGFzczpcIm9yYml0LW5leHRcIixwcmV2Q2xhc3M6XCJvcmJpdC1wcmV2aW91c1wiLHVzZU1VSTohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIk9yYml0XCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD10KGkpLHRoaXMucnVsZXM9dGhpcy4kZWxlbWVudC5kYXRhKFwicmVzcG9uc2l2ZS1tZW51XCIpLHRoaXMuY3VycmVudE1xPW51bGwsdGhpcy5jdXJyZW50UGx1Z2luPW51bGwsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIlJlc3BvbnNpdmVNZW51XCIpfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5ydWxlcyl7Zm9yKHZhciBlPXt9LG49dGhpcy5ydWxlcy5zcGxpdChcIiBcIikscz0wO3M8bi5sZW5ndGg7cysrKXt2YXIgbz1uW3NdLnNwbGl0KFwiLVwiKSxhPW8ubGVuZ3RoPjE/b1swXTpcInNtYWxsXCIscj1vLmxlbmd0aD4xP29bMV06b1swXTtudWxsIT09aVtyXSYmKGVbYV09aVtyXSl9dGhpcy5ydWxlcz1lfXQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKXx8dGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKSx0aGlzLiRlbGVtZW50LmF0dHIoXCJkYXRhLW11dGF0ZVwiLHRoaXMuJGVsZW1lbnQuYXR0cihcImRhdGEtbXV0YXRlXCIpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXCJyZXNwb25zaXZlLW1lbnVcIikpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsZnVuY3Rpb24oKXtlLl9jaGVja01lZGlhUXVlcmllcygpfSl9fSx7a2V5OlwiX2NoZWNrTWVkaWFRdWVyaWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSxuPXRoaXM7dC5lYWNoKHRoaXMucnVsZXMsZnVuY3Rpb24odCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodCkmJihlPXQpfSksZSYmKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbZV0ucGx1Z2lufHwodC5lYWNoKGksZnVuY3Rpb24odCxlKXtuLiRlbGVtZW50LnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3MpfSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSx0aGlzLmN1cnJlbnRQbHVnaW4mJnRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdGhpcy5jdXJyZW50UGx1Z2luPW5ldyB0aGlzLnJ1bGVzW2VdLnBsdWdpbih0aGlzLiRlbGVtZW50LHt9KSkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdCh3aW5kb3cpLm9mZihcIi56Zi5SZXNwb25zaXZlTWVudVwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17fTt2YXIgaT17ZHJvcGRvd246e2Nzc0NsYXNzOlwiZHJvcGRvd25cIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1tcImRyb3Bkb3duLW1lbnVcIl18fG51bGx9LGRyaWxsZG93bjp7Y3NzQ2xhc3M6XCJkcmlsbGRvd25cIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2lucy5kcmlsbGRvd258fG51bGx9LGFjY29yZGlvbjp7Y3NzQ2xhc3M6XCJhY2NvcmRpb24tbWVudVwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zW1wiYWNjb3JkaW9uLW1lbnVcIl18fG51bGx9fTtGb3VuZGF0aW9uLnBsdWdpbihlLFwiUmVzcG9uc2l2ZU1lbnVcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PXQoaSksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIlJlc3BvbnNpdmVUb2dnbGVcIil9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZGF0YShcInJlc3BvbnNpdmUtdG9nZ2xlXCIpO2lmKGV8fGNvbnNvbGUuZXJyb3IoXCJZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuXCIpLHRoaXMuJHRhcmdldE1lbnU9dChcIiNcIitlKSx0aGlzLiR0b2dnbGVyPXRoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLXRvZ2dsZV1cIiksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LHRoaXMub3B0aW9ucyx0aGlzLiR0YXJnZXRNZW51LmRhdGEoKSksdGhpcy5vcHRpb25zLmFuaW1hdGUpe3ZhciBpPXRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KFwiIFwiKTt0aGlzLmFuaW1hdGlvbkluPWlbMF0sdGhpcy5hbmltYXRpb25PdXQ9aVsxXXx8bnVsbH10aGlzLl91cGRhdGUoKX19LHtrZXk6XCJfZXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVNcUhhbmRsZXI9dGhpcy5fdXBkYXRlLmJpbmQodGhpcyksdCh3aW5kb3cpLm9uKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSx0aGlzLiR0b2dnbGVyLm9uKFwiY2xpY2suemYucmVzcG9uc2l2ZVRvZ2dsZVwiLHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKX19LHtrZXk6XCJfdXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcik/KHRoaXMuJGVsZW1lbnQuaGlkZSgpLHRoaXMuJHRhcmdldE1lbnUuc2hvdygpKToodGhpcy4kZWxlbWVudC5zaG93KCksdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCkpfX0se2tleTpcInRvZ2dsZU1lbnVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpfHwodGhpcy5vcHRpb25zLmFuaW1hdGU/dGhpcy4kdGFyZ2V0TWVudS5pcyhcIjpoaWRkZW5cIik/Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJHRhcmdldE1lbnUsdGhpcy5hbmltYXRpb25JbixmdW5jdGlvbigpe3QuJGVsZW1lbnQudHJpZ2dlcihcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVwiKSx0LiR0YXJnZXRNZW51LmZpbmQoXCJbZGF0YS1tdXRhdGVdXCIpLnRyaWdnZXJIYW5kbGVyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKX0pOkZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kdGFyZ2V0TWVudSx0aGlzLmFuaW1hdGlvbk91dCxmdW5jdGlvbigpe3QuJGVsZW1lbnQudHJpZ2dlcihcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVwiKX0pOih0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKSx0aGlzLiR0YXJnZXRNZW51LmZpbmQoXCJbZGF0YS1tdXRhdGVdXCIpLnRyaWdnZXIoXCJtdXRhdGVtZS56Zi50cmlnZ2VyXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVwiKSkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLnJlc3BvbnNpdmVUb2dnbGVcIiksdGhpcy4kdG9nZ2xlci5vZmYoXCIuemYucmVzcG9uc2l2ZVRvZ2dsZVwiKSx0KHdpbmRvdykub2ZmKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17aGlkZUZvcjpcIm1lZGl1bVwiLGFuaW1hdGU6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXCJSZXNwb25zaXZlVG9nZ2xlXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybi9pUChhZHxob25lfG9kKS4qT1MvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpfWZ1bmN0aW9uIGkoKXtyZXR1cm4vQW5kcm9pZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gbigpe3JldHVybiBlKCl8fGkoKX12YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIlJldmVhbFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFwiUmV2ZWFsXCIse0VOVEVSOlwib3BlblwiLFNQQUNFOlwib3BlblwiLEVTQ0FQRTpcImNsb3NlXCJ9KX1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pZD10aGlzLiRlbGVtZW50LmF0dHIoXCJpZFwiKSx0aGlzLmlzQWN0aXZlPSExLHRoaXMuY2FjaGVkPXttcTpGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudH0sdGhpcy5pc01vYmlsZT1uKCksdGhpcy4kYW5jaG9yPXQodCgnW2RhdGEtb3Blbj1cIicrdGhpcy5pZCsnXCJdJykubGVuZ3RoPydbZGF0YS1vcGVuPVwiJyt0aGlzLmlkKydcIl0nOidbZGF0YS10b2dnbGU9XCInK3RoaXMuaWQrJ1wiXScpLHRoaXMuJGFuY2hvci5hdHRyKHtcImFyaWEtY29udHJvbHNcIjp0aGlzLmlkLFwiYXJpYS1oYXNwb3B1cFwiOiEwLHRhYmluZGV4OjB9KSwodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmdWxsXCIpKSYmKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuPSEwLHRoaXMub3B0aW9ucy5vdmVybGF5PSExKSx0aGlzLm9wdGlvbnMub3ZlcmxheSYmIXRoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5PXRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpKSx0aGlzLiRlbGVtZW50LmF0dHIoe3JvbGU6XCJkaWFsb2dcIixcImFyaWEtaGlkZGVuXCI6ITAsXCJkYXRhLXlldGktYm94XCI6dGhpcy5pZCxcImRhdGEtcmVzaXplXCI6dGhpcy5pZH0pLHRoaXMuJG92ZXJsYXk/dGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KToodGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0KHRoaXMub3B0aW9ucy5hcHBlbmRUbykpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJ3aXRob3V0LW92ZXJsYXlcIikpLHRoaXMuX2V2ZW50cygpLHRoaXMub3B0aW9ucy5kZWVwTGluayYmd2luZG93LmxvY2F0aW9uLmhhc2g9PT1cIiNcIit0aGlzLmlkJiZ0KHdpbmRvdykub25lKFwibG9hZC56Zi5yZXZlYWxcIix0aGlzLm9wZW4uYmluZCh0aGlzKSl9fSx7a2V5OlwiX21ha2VPdmVybGF5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdChcIjxkaXY+PC9kaXY+XCIpLmFkZENsYXNzKFwicmV2ZWFsLW92ZXJsYXlcIikuYXBwZW5kVG8odGhpcy5vcHRpb25zLmFwcGVuZFRvKX19LHtrZXk6XCJfdXBkYXRlUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLGksbj10aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKSxzPXQod2luZG93KS53aWR0aCgpLG89dGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpLGE9dCh3aW5kb3cpLmhlaWdodCgpO2U9XCJhdXRvXCI9PT10aGlzLm9wdGlvbnMuaE9mZnNldD9wYXJzZUludCgocy1uKS8yLDEwKTpwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwxMCksaT1cImF1dG9cIj09PXRoaXMub3B0aW9ucy52T2Zmc2V0P28+YT9wYXJzZUludChNYXRoLm1pbigxMDAsYS8xMCksMTApOnBhcnNlSW50KChhLW8pLzQsMTApOnBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LDEwKSx0aGlzLiRlbGVtZW50LmNzcyh7dG9wOmkrXCJweFwifSksdGhpcy4kb3ZlcmxheSYmXCJhdXRvXCI9PT10aGlzLm9wdGlvbnMuaE9mZnNldHx8KHRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OmUrXCJweFwifSksdGhpcy4kZWxlbWVudC5jc3Moe21hcmdpbjpcIjBweFwifSkpfX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsaT10aGlzO3RoaXMuJGVsZW1lbnQub24oe1wib3Blbi56Zi50cmlnZ2VyXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXCJjbG9zZS56Zi50cmlnZ2VyXCI6ZnVuY3Rpb24obixzKXtpZihuLnRhcmdldD09PWkuJGVsZW1lbnRbMF18fHQobi50YXJnZXQpLnBhcmVudHMoXCJbZGF0YS1jbG9zYWJsZV1cIilbMF09PT1zKXJldHVybiBlLmNsb3NlLmFwcGx5KGUpfSxcInRvZ2dsZS56Zi50cmlnZ2VyXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKSxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcIjpmdW5jdGlvbigpe2kuX3VwZGF0ZVBvc2l0aW9uKCl9fSksdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9uKFwia2V5ZG93bi56Zi5yZXZlYWxcIixmdW5jdGlvbih0KXsxMyE9PXQud2hpY2gmJjMyIT09dC53aGljaHx8KHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLGkub3BlbigpKX0pLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5Lm9mZihcIi56Zi5yZXZlYWxcIikub24oXCJjbGljay56Zi5yZXZlYWxcIixmdW5jdGlvbihlKXtlLnRhcmdldCE9PWkuJGVsZW1lbnRbMF0mJiF0LmNvbnRhaW5zKGkuJGVsZW1lbnRbMF0sZS50YXJnZXQpJiZ0LmNvbnRhaW5zKGRvY3VtZW50LGUudGFyZ2V0KSYmaS5jbG9zZSgpfSksdGhpcy5vcHRpb25zLmRlZXBMaW5rJiZ0KHdpbmRvdykub24oXCJwb3BzdGF0ZS56Zi5yZXZlYWw6XCIrdGhpcy5pZCx0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKX19LHtrZXk6XCJfaGFuZGxlU3RhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXt3aW5kb3cubG9jYXRpb24uaGFzaCE9PVwiI1wiK3RoaXMuaWR8fHRoaXMuaXNBY3RpdmU/dGhpcy5jbG9zZSgpOnRoaXMub3BlbigpfX0se2tleTpcIm9wZW5cIix2YWx1ZTpmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtzLmlzTW9iaWxlPyhzLm9yaWdpbmFsU2Nyb2xsUG9zfHwocy5vcmlnaW5hbFNjcm9sbFBvcz13aW5kb3cucGFnZVlPZmZzZXQpLHQoXCJodG1sLCBib2R5XCIpLmFkZENsYXNzKFwiaXMtcmV2ZWFsLW9wZW5cIikpOnQoXCJib2R5XCIpLmFkZENsYXNzKFwiaXMtcmV2ZWFsLW9wZW5cIil9dmFyIGk9dGhpcztpZih0aGlzLm9wdGlvbnMuZGVlcExpbmspe3ZhciBuPVwiI1wiK3RoaXMuaWQ7d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlP3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLG51bGwsbik6d2luZG93LmxvY2F0aW9uLmhhc2g9bn10aGlzLmlzQWN0aXZlPSEwLHRoaXMuJGVsZW1lbnQuY3NzKHt2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KS5zaG93KCkuc2Nyb2xsVG9wKDApLHRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcImhpZGRlblwifSkuc2hvdygpLHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHt2aXNpYmlsaXR5OlwiXCJ9KSx0aGlzLiRvdmVybGF5JiYodGhpcy4kb3ZlcmxheS5jc3Moe3Zpc2liaWxpdHk6XCJcIn0pLmhpZGUoKSx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFzdFwiKT90aGlzLiRvdmVybGF5LmFkZENsYXNzKFwiZmFzdFwiKTp0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwic2xvd1wiKSYmdGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcInNsb3dcIikpLHRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZHx8dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiY2xvc2VtZS56Zi5yZXZlYWxcIix0aGlzLmlkKTt2YXIgcz10aGlzO3RoaXMub3B0aW9ucy5hbmltYXRpb25Jbj8hZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe3MuJGVsZW1lbnQuYXR0cih7XCJhcmlhLWhpZGRlblwiOiExLHRhYmluZGV4Oi0xfSkuZm9jdXMoKSxlKCksRm91bmRhdGlvbi5LZXlib2FyZC50cmFwRm9jdXMocy4kZWxlbWVudCl9O2kub3B0aW9ucy5vdmVybGF5JiZGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oaS4kb3ZlcmxheSxcImZhZGUtaW5cIiksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKGkuJGVsZW1lbnQsaS5vcHRpb25zLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7aS4kZWxlbWVudCYmKGkuZm9jdXNhYmxlRWxlbWVudHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGkuJGVsZW1lbnQpLHQoKSl9KX0oKToodGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMuJG92ZXJsYXkuc2hvdygwKSx0aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSkpLHRoaXMuJGVsZW1lbnQuYXR0cih7XCJhcmlhLWhpZGRlblwiOiExLHRhYmluZGV4Oi0xfSkuZm9jdXMoKSxGb3VuZGF0aW9uLktleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJvcGVuLnpmLnJldmVhbFwiKSxlKCksc2V0VGltZW91dChmdW5jdGlvbigpe2kuX2V4dHJhSGFuZGxlcnMoKX0sMCl9fSx7a2V5OlwiX2V4dHJhSGFuZGxlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudCYmKHRoaXMuZm9jdXNhYmxlRWxlbWVudHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpLHRoaXMub3B0aW9ucy5vdmVybGF5fHwhdGhpcy5vcHRpb25zLmNsb3NlT25DbGlja3x8dGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHQoXCJib2R5XCIpLm9uKFwiY2xpY2suemYucmV2ZWFsXCIsZnVuY3Rpb24oaSl7aS50YXJnZXQhPT1lLiRlbGVtZW50WzBdJiYhdC5jb250YWlucyhlLiRlbGVtZW50WzBdLGkudGFyZ2V0KSYmdC5jb250YWlucyhkb2N1bWVudCxpLnRhcmdldCkmJmUuY2xvc2UoKX0pLHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjJiZ0KHdpbmRvdykub24oXCJrZXlkb3duLnpmLnJldmVhbFwiLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXCJSZXZlYWxcIix7Y2xvc2U6ZnVuY3Rpb24oKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSl9fSl9KSx0aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi56Zi5yZXZlYWxcIixmdW5jdGlvbihpKXt2YXIgbj10KHRoaXMpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXCJSZXZlYWxcIix7b3BlbjpmdW5jdGlvbigpe2UuJGVsZW1lbnQuZmluZChcIjpmb2N1c1wiKS5pcyhlLiRlbGVtZW50LmZpbmQoXCJbZGF0YS1jbG9zZV1cIikpP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLiRhbmNob3IuZm9jdXMoKX0sMSk6bi5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzKSYmZS5vcGVuKCl9LGNsb3NlOmZ1bmN0aW9uKCl7ZS5vcHRpb25zLmNsb3NlT25Fc2MmJihlLmNsb3NlKCksZS4kYW5jaG9yLmZvY3VzKCkpfSxoYW5kbGVkOmZ1bmN0aW9uKHQpe3QmJmkucHJldmVudERlZmF1bHQoKX19KX0pKX19LHtrZXk6XCJjbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2kuaXNNb2JpbGU/KHQoXCJodG1sLCBib2R5XCIpLnJlbW92ZUNsYXNzKFwiaXMtcmV2ZWFsLW9wZW5cIiksaS5vcmlnaW5hbFNjcm9sbFBvcyYmKHQoXCJib2R5XCIpLnNjcm9sbFRvcChpLm9yaWdpbmFsU2Nyb2xsUG9zKSxpLm9yaWdpbmFsU2Nyb2xsUG9zPW51bGwpKTp0KFwiYm9keVwiKS5yZW1vdmVDbGFzcyhcImlzLXJldmVhbC1vcGVuXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVsZWFzZUZvY3VzKGkuJGVsZW1lbnQpLGkuJGVsZW1lbnQuYXR0cihcImFyaWEtaGlkZGVuXCIsITApLGkuJGVsZW1lbnQudHJpZ2dlcihcImNsb3NlZC56Zi5yZXZlYWxcIil9aWYoIXRoaXMuaXNBY3RpdmV8fCF0aGlzLiRlbGVtZW50LmlzKFwiOnZpc2libGVcIikpcmV0dXJuITE7dmFyIGk9dGhpczt0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0Pyh0aGlzLm9wdGlvbnMub3ZlcmxheT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJG92ZXJsYXksXCJmYWRlLW91dFwiLGUpOmUoKSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkpOih0aGlzLm9wdGlvbnMub3ZlcmxheT90aGlzLiRvdmVybGF5LmhpZGUoMCxlKTplKCksdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9mZihcImtleWRvd24uemYucmV2ZWFsXCIpLCF0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdChcImJvZHlcIikub2ZmKFwiY2xpY2suemYucmV2ZWFsXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFwia2V5ZG93bi56Zi5yZXZlYWxcIiksdGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSYmdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKSx0aGlzLmlzQWN0aXZlPSExLGkub3B0aW9ucy5kZWVwTGluayYmKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZT93aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXCJcIixkb2N1bWVudC50aXRsZSx3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKFwiI1wiK3RoaXMuaWQsXCJcIikpOndpbmRvdy5sb2NhdGlvbi5oYXNoPVwiXCIpfX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc0FjdGl2ZT90aGlzLmNsb3NlKCk6dGhpcy5vcGVuKCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLm92ZXJsYXkmJih0aGlzLiRlbGVtZW50LmFwcGVuZFRvKHQodGhpcy5vcHRpb25zLmFwcGVuZFRvKSksdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCkpLHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpLHRoaXMuJGFuY2hvci5vZmYoXCIuemZcIiksdCh3aW5kb3cpLm9mZihcIi56Zi5yZXZlYWw6XCIrdGhpcy5pZCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxlfSgpO3MuZGVmYXVsdHM9e2FuaW1hdGlvbkluOlwiXCIsYW5pbWF0aW9uT3V0OlwiXCIsc2hvd0RlbGF5OjAsaGlkZURlbGF5OjAsY2xvc2VPbkNsaWNrOiEwLGNsb3NlT25Fc2M6ITAsbXVsdGlwbGVPcGVuZWQ6ITEsdk9mZnNldDpcImF1dG9cIixoT2Zmc2V0OlwiYXV0b1wiLGZ1bGxTY3JlZW46ITEsYnRtT2Zmc2V0UGN0OjEwLG92ZXJsYXk6ITAscmVzZXRPbkNsb3NlOiExLGRlZXBMaW5rOiExLGFwcGVuZFRvOlwiYm9keVwifSxGb3VuZGF0aW9uLnBsdWdpbihzLFwiUmV2ZWFsXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe3JldHVybiB0L2V9ZnVuY3Rpb24gaSh0LGUsaSxuKXtyZXR1cm4gTWF0aC5hYnModC5wb3NpdGlvbigpW2VdK3Rbbl0oKS8yLWkpfWZ1bmN0aW9uIG4odCxlKXtyZXR1cm4gTWF0aC5sb2coZSkvTWF0aC5sb2codCl9dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGUsaSl7X2NsYXNzQ2FsbENoZWNrKHRoaXMscyksdGhpcy4kZWxlbWVudD1lLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxzLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLGkpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXCJTbGlkZXJcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcIlNsaWRlclwiLHtsdHI6e0FSUk9XX1JJR0hUOlwiaW5jcmVhc2VcIixBUlJPV19VUDpcImluY3JlYXNlXCIsQVJST1dfRE9XTjpcImRlY3JlYXNlXCIsQVJST1dfTEVGVDpcImRlY3JlYXNlXCIsU0hJRlRfQVJST1dfUklHSFQ6XCJpbmNyZWFzZV9mYXN0XCIsU0hJRlRfQVJST1dfVVA6XCJpbmNyZWFzZV9mYXN0XCIsU0hJRlRfQVJST1dfRE9XTjpcImRlY3JlYXNlX2Zhc3RcIixTSElGVF9BUlJPV19MRUZUOlwiZGVjcmVhc2VfZmFzdFwifSxydGw6e0FSUk9XX0xFRlQ6XCJpbmNyZWFzZVwiLEFSUk9XX1JJR0hUOlwiZGVjcmVhc2VcIixTSElGVF9BUlJPV19MRUZUOlwiaW5jcmVhc2VfZmFzdFwiLFNISUZUX0FSUk9XX1JJR0hUOlwiZGVjcmVhc2VfZmFzdFwifX0pfXJldHVybiBfY3JlYXRlQ2xhc3Mocyxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmlucHV0cz10aGlzLiRlbGVtZW50LmZpbmQoXCJpbnB1dFwiKSx0aGlzLmhhbmRsZXM9dGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtc2xpZGVyLWhhbmRsZV1cIiksdGhpcy4kaGFuZGxlPXRoaXMuaGFuZGxlcy5lcSgwKSx0aGlzLiRpbnB1dD10aGlzLmlucHV0cy5sZW5ndGg/dGhpcy5pbnB1dHMuZXEoMCk6dChcIiNcIit0aGlzLiRoYW5kbGUuYXR0cihcImFyaWEtY29udHJvbHNcIikpLHRoaXMuJGZpbGw9dGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtc2xpZGVyLWZpbGxdXCIpLmNzcyh0aGlzLm9wdGlvbnMudmVydGljYWw/XCJoZWlnaHRcIjpcIndpZHRoXCIsMCk7dmFyIGU9ITE7KHRoaXMub3B0aW9ucy5kaXNhYmxlZHx8dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpJiYodGhpcy5vcHRpb25zLmRpc2FibGVkPSEwLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSx0aGlzLmlucHV0cy5sZW5ndGh8fCh0aGlzLmlucHV0cz10KCkuYWRkKHRoaXMuJGlucHV0KSx0aGlzLm9wdGlvbnMuYmluZGluZz0hMCksdGhpcy5fc2V0SW5pdEF0dHIoMCksdGhpcy5oYW5kbGVzWzFdJiYodGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkPSEwLHRoaXMuJGhhbmRsZTI9dGhpcy5oYW5kbGVzLmVxKDEpLHRoaXMuJGlucHV0Mj10aGlzLmlucHV0cy5sZW5ndGg+MT90aGlzLmlucHV0cy5lcSgxKTp0KFwiI1wiK3RoaXMuJGhhbmRsZTIuYXR0cihcImFyaWEtY29udHJvbHNcIikpLHRoaXMuaW5wdXRzWzFdfHwodGhpcy5pbnB1dHM9dGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0MikpLGU9ITAsdGhpcy5fc2V0SW5pdEF0dHIoMSkpLHRoaXMuc2V0SGFuZGxlcygpLHRoaXMuX2V2ZW50cygpfX0se2tleTpcInNldEhhbmRsZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5oYW5kbGVzWzFdP3RoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5pbnB1dHMuZXEoMCkudmFsKCksITAsZnVuY3Rpb24oKXt0Ll9zZXRIYW5kbGVQb3ModC4kaGFuZGxlMix0LmlucHV0cy5lcSgxKS52YWwoKSwhMCl9KTp0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMuaW5wdXRzLmVxKDApLnZhbCgpLCEwKX19LHtrZXk6XCJfcmVmbG93XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNldEhhbmRsZXMoKX19LHtrZXk6XCJfcGN0T2ZCYXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgaT1lKHQtdGhpcy5vcHRpb25zLnN0YXJ0LHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KTtzd2l0Y2godGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbil7Y2FzZVwicG93XCI6aT10aGlzLl9sb2dUcmFuc2Zvcm0oaSk7YnJlYWs7Y2FzZVwibG9nXCI6aT10aGlzLl9wb3dUcmFuc2Zvcm0oaSl9cmV0dXJuIGkudG9GaXhlZCgyKX19LHtrZXk6XCJfdmFsdWVcIix2YWx1ZTpmdW5jdGlvbih0KXtzd2l0Y2godGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbil7Y2FzZVwicG93XCI6dD10aGlzLl9wb3dUcmFuc2Zvcm0odCk7YnJlYWs7Y2FzZVwibG9nXCI6dD10aGlzLl9sb2dUcmFuc2Zvcm0odCl9dmFyIGU9KHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KSp0K3RoaXMub3B0aW9ucy5zdGFydDtyZXR1cm4gZX19LHtrZXk6XCJfbG9nVHJhbnNmb3JtXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsdCoodGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UtMSkrMSl9fSx7a2V5OlwiX3Bvd1RyYW5zZm9ybVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybihNYXRoLnBvdyh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSx0KS0xKS8odGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UtMSl9fSx7a2V5OlwiX3NldEhhbmRsZVBvc1wiLHZhbHVlOmZ1bmN0aW9uKHQsaSxuLHMpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSl7aT1wYXJzZUZsb2F0KGkpLGk8dGhpcy5vcHRpb25zLnN0YXJ0P2k9dGhpcy5vcHRpb25zLnN0YXJ0Omk+dGhpcy5vcHRpb25zLmVuZCYmKGk9dGhpcy5vcHRpb25zLmVuZCk7dmFyIG89dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO2lmKG8paWYoMD09PXRoaXMuaGFuZGxlcy5pbmRleCh0KSl7dmFyIGE9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoXCJhcmlhLXZhbHVlbm93XCIpKTtpPWk+PWE/YS10aGlzLm9wdGlvbnMuc3RlcDppfWVsc2V7dmFyIHI9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUuYXR0cihcImFyaWEtdmFsdWVub3dcIikpO2k9aTw9cj9yK3RoaXMub3B0aW9ucy5zdGVwOml9dGhpcy5vcHRpb25zLnZlcnRpY2FsJiYhbiYmKGk9dGhpcy5vcHRpb25zLmVuZC1pKTt2YXIgbD10aGlzLHU9dGhpcy5vcHRpb25zLnZlcnRpY2FsLGQ9dT9cImhlaWdodFwiOlwid2lkdGhcIixoPXU/XCJ0b3BcIjpcImxlZnRcIixjPXRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0sZj10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RdLHA9dGhpcy5fcGN0T2ZCYXIoaSksbT0oZi1jKSpwLGc9KDEwMCplKG0sZikpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpO2k9cGFyc2VGbG9hdChpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpKTt2YXIgdj17fTtpZih0aGlzLl9zZXRWYWx1ZXModCxpKSxvKXt2YXIgeSx3PTA9PT10aGlzLmhhbmRsZXMuaW5kZXgodCksYj1+figxMDAqZShjLGYpKTtpZih3KXZbaF09ZytcIiVcIix5PXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMlswXS5zdHlsZVtoXSktZytiLHMmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHMmJnMoKTtlbHNle3ZhciAkPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2hdKTt5PWctKGlzTmFOKCQpPyh0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LXRoaXMub3B0aW9ucy5zdGFydCkvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKTokKStifXZbXCJtaW4tXCIrZF09eStcIiVcIn10aGlzLiRlbGVtZW50Lm9uZShcImZpbmlzaGVkLnpmLmFuaW1hdGVcIixmdW5jdGlvbigpe2wuJGVsZW1lbnQudHJpZ2dlcihcIm1vdmVkLnpmLnNsaWRlclwiLFt0XSl9KTt2YXIgQz10aGlzLiRlbGVtZW50LmRhdGEoXCJkcmFnZ2luZ1wiKT8xZTMvNjA6dGhpcy5vcHRpb25zLm1vdmVUaW1lO0ZvdW5kYXRpb24uTW92ZShDLHQsZnVuY3Rpb24oKXtpc05hTihnKT90LmNzcyhoLDEwMCpwK1wiJVwiKTp0LmNzcyhoLGcrXCIlXCIpLGwub3B0aW9ucy5kb3VibGVTaWRlZD9sLiRmaWxsLmNzcyh2KTpsLiRmaWxsLmNzcyhkLDEwMCpwK1wiJVwiKX0pLGNsZWFyVGltZW91dChsLnRpbWVvdXQpLGwudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bC4kZWxlbWVudC50cmlnZ2VyKFwiY2hhbmdlZC56Zi5zbGlkZXJcIixbdF0pfSxsLm9wdGlvbnMuY2hhbmdlZERlbGF5KX19fSx7a2V5OlwiX3NldEluaXRBdHRyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9MD09PXQ/dGhpcy5vcHRpb25zLmluaXRpYWxTdGFydDp0aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCxpPXRoaXMuaW5wdXRzLmVxKHQpLmF0dHIoXCJpZFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFwic2xpZGVyXCIpO3RoaXMuaW5wdXRzLmVxKHQpLmF0dHIoe2lkOmksbWF4OnRoaXMub3B0aW9ucy5lbmQsbWluOnRoaXMub3B0aW9ucy5zdGFydCxzdGVwOnRoaXMub3B0aW9ucy5zdGVwfSksdGhpcy5pbnB1dHMuZXEodCkudmFsKGUpLHRoaXMuaGFuZGxlcy5lcSh0KS5hdHRyKHtyb2xlOlwic2xpZGVyXCIsXCJhcmlhLWNvbnRyb2xzXCI6aSxcImFyaWEtdmFsdWVtYXhcIjp0aGlzLm9wdGlvbnMuZW5kLFwiYXJpYS12YWx1ZW1pblwiOnRoaXMub3B0aW9ucy5zdGFydCxcImFyaWEtdmFsdWVub3dcIjplLFwiYXJpYS1vcmllbnRhdGlvblwiOnRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cInZlcnRpY2FsXCI6XCJob3Jpem9udGFsXCIsdGFiaW5kZXg6MH0pfX0se2tleTpcIl9zZXRWYWx1ZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMub3B0aW9ucy5kb3VibGVTaWRlZD90aGlzLmhhbmRsZXMuaW5kZXgodCk6MDt0aGlzLmlucHV0cy5lcShpKS52YWwoZSksdC5hdHRyKFwiYXJpYS12YWx1ZW5vd1wiLGUpfX0se2tleTpcIl9oYW5kbGVFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKG4scyxvKXt2YXIgYSxyO2lmKG8pYT10aGlzLl9hZGp1c3RWYWx1ZShudWxsLG8pLHI9ITA7ZWxzZXtuLnByZXZlbnREZWZhdWx0KCk7dmFyIGw9dGhpcyx1PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxkPXU/XCJoZWlnaHRcIjpcIndpZHRoXCIsaD11P1widG9wXCI6XCJsZWZ0XCIsYz11P24ucGFnZVk6bi5wYWdlWCxmPSh0aGlzLiRoYW5kbGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0vMix0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RdKSxwPXU/dCh3aW5kb3cpLnNjcm9sbFRvcCgpOnQod2luZG93KS5zY3JvbGxMZWZ0KCksbT10aGlzLiRlbGVtZW50Lm9mZnNldCgpW2hdO24uY2xpZW50WT09PW4ucGFnZVkmJihjKz1wKTt2YXIgZyx2PWMtbTtnPXY8MD8wOnY+Zj9mOnY7dmFyIHk9ZShnLGYpO2lmKGE9dGhpcy5fdmFsdWUoeSksRm91bmRhdGlvbi5ydGwoKSYmIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmKGE9dGhpcy5vcHRpb25zLmVuZC1hKSxhPWwuX2FkanVzdFZhbHVlKG51bGwsYSkscj0hMSwhcyl7dmFyIHc9aSh0aGlzLiRoYW5kbGUsaCxnLGQpLGI9aSh0aGlzLiRoYW5kbGUyLGgsZyxkKTtcbnM9dzw9Yj90aGlzLiRoYW5kbGU6dGhpcy4kaGFuZGxlMn19dGhpcy5fc2V0SGFuZGxlUG9zKHMsYSxyKX19LHtrZXk6XCJfYWRqdXN0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpLG4scyxvLGE9dGhpcy5vcHRpb25zLnN0ZXAscj1wYXJzZUZsb2F0KGEvMik7cmV0dXJuIGk9dD9wYXJzZUZsb2F0KHQuYXR0cihcImFyaWEtdmFsdWVub3dcIikpOmUsbj1pJWEscz1pLW4sbz1zK2EsMD09PW4/aTppPWk+PXMrcj9vOnN9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZSksdGhpcy5oYW5kbGVzWzFdJiZ0aGlzLl9ldmVudHNGb3JIYW5kbGUodGhpcy4kaGFuZGxlMil9fSx7a2V5OlwiX2V2ZW50c0ZvckhhbmRsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpLG49dGhpcztpZih0aGlzLmlucHV0cy5vZmYoXCJjaGFuZ2UuemYuc2xpZGVyXCIpLm9uKFwiY2hhbmdlLnpmLnNsaWRlclwiLGZ1bmN0aW9uKGUpe3ZhciBpPW4uaW5wdXRzLmluZGV4KHQodGhpcykpO24uX2hhbmRsZUV2ZW50KGUsbi5oYW5kbGVzLmVxKGkpLHQodGhpcykudmFsKCkpfSksdGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0JiZ0aGlzLiRlbGVtZW50Lm9mZihcImNsaWNrLnpmLnNsaWRlclwiKS5vbihcImNsaWNrLnpmLnNsaWRlclwiLGZ1bmN0aW9uKGUpe3JldHVybiFuLiRlbGVtZW50LmRhdGEoXCJkcmFnZ2luZ1wiKSYmdm9pZCh0KGUudGFyZ2V0KS5pcyhcIltkYXRhLXNsaWRlci1oYW5kbGVdXCIpfHwobi5vcHRpb25zLmRvdWJsZVNpZGVkP24uX2hhbmRsZUV2ZW50KGUpOm4uX2hhbmRsZUV2ZW50KGUsbi4kaGFuZGxlKSkpfSksdGhpcy5vcHRpb25zLmRyYWdnYWJsZSl7dGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7dmFyIHM9dChcImJvZHlcIik7ZS5vZmYoXCJtb3VzZWRvd24uemYuc2xpZGVyXCIpLm9uKFwibW91c2Vkb3duLnpmLnNsaWRlclwiLGZ1bmN0aW9uKG8pe2UuYWRkQ2xhc3MoXCJpcy1kcmFnZ2luZ1wiKSxuLiRmaWxsLmFkZENsYXNzKFwiaXMtZHJhZ2dpbmdcIiksbi4kZWxlbWVudC5kYXRhKFwiZHJhZ2dpbmdcIiwhMCksaT10KG8uY3VycmVudFRhcmdldCkscy5vbihcIm1vdXNlbW92ZS56Zi5zbGlkZXJcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksbi5faGFuZGxlRXZlbnQodCxpKX0pLm9uKFwibW91c2V1cC56Zi5zbGlkZXJcIixmdW5jdGlvbih0KXtuLl9oYW5kbGVFdmVudCh0LGkpLGUucmVtb3ZlQ2xhc3MoXCJpcy1kcmFnZ2luZ1wiKSxuLiRmaWxsLnJlbW92ZUNsYXNzKFwiaXMtZHJhZ2dpbmdcIiksbi4kZWxlbWVudC5kYXRhKFwiZHJhZ2dpbmdcIiwhMSkscy5vZmYoXCJtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyXCIpfSl9KS5vbihcInNlbGVjdHN0YXJ0LnpmLnNsaWRlciB0b3VjaG1vdmUuemYuc2xpZGVyXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpfSl9ZS5vZmYoXCJrZXlkb3duLnpmLnNsaWRlclwiKS5vbihcImtleWRvd24uemYuc2xpZGVyXCIsZnVuY3Rpb24oZSl7dmFyIGkscz10KHRoaXMpLG89bi5vcHRpb25zLmRvdWJsZVNpZGVkP24uaGFuZGxlcy5pbmRleChzKTowLGE9cGFyc2VGbG9hdChuLmlucHV0cy5lcShvKS52YWwoKSk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSxcIlNsaWRlclwiLHtkZWNyZWFzZTpmdW5jdGlvbigpe2k9YS1uLm9wdGlvbnMuc3RlcH0saW5jcmVhc2U6ZnVuY3Rpb24oKXtpPWErbi5vcHRpb25zLnN0ZXB9LGRlY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24oKXtpPWEtMTAqbi5vcHRpb25zLnN0ZXB9LGluY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24oKXtpPWErMTAqbi5vcHRpb25zLnN0ZXB9LGhhbmRsZWQ6ZnVuY3Rpb24oKXtlLnByZXZlbnREZWZhdWx0KCksbi5fc2V0SGFuZGxlUG9zKHMsaSwhMCl9fSl9KX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhhbmRsZXMub2ZmKFwiLnpmLnNsaWRlclwiKSx0aGlzLmlucHV0cy5vZmYoXCIuemYuc2xpZGVyXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFwiLnpmLnNsaWRlclwiKSxjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLHN9KCk7cy5kZWZhdWx0cz17c3RhcnQ6MCxlbmQ6MTAwLHN0ZXA6MSxpbml0aWFsU3RhcnQ6MCxpbml0aWFsRW5kOjEwMCxiaW5kaW5nOiExLGNsaWNrU2VsZWN0OiEwLHZlcnRpY2FsOiExLGRyYWdnYWJsZTohMCxkaXNhYmxlZDohMSxkb3VibGVTaWRlZDohMSxkZWNpbWFsOjIsbW92ZVRpbWU6MjAwLGRpc2FibGVkQ2xhc3M6XCJkaXNhYmxlZFwiLGludmVydFZlcnRpY2FsOiExLGNoYW5nZWREZWxheTo1MDAsbm9uTGluZWFyQmFzZTo1LHBvc2l0aW9uVmFsdWVGdW5jdGlvbjpcImxpbmVhclwifSxGb3VuZGF0aW9uLnBsdWdpbihzLFwiU2xpZGVyXCIpfShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlfX0oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSxudWxsKS5mb250U2l6ZSwxMCkqdH12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoZSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxpKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGkuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIlN0aWNreVwiKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKGksW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5wYXJlbnQoXCJbZGF0YS1zdGlja3ktY29udGFpbmVyXVwiKSxpPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcInN0aWNreVwiKSxuPXRoaXM7ZS5sZW5ndGh8fCh0aGlzLndhc1dyYXBwZWQ9ITApLHRoaXMuJGNvbnRhaW5lcj1lLmxlbmd0aD9lOnQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikud3JhcElubmVyKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHtcImRhdGEtcmVzaXplXCI6aX0pLHRoaXMuc2Nyb2xsQ291bnQ9dGhpcy5vcHRpb25zLmNoZWNrRXZlcnksdGhpcy5pc1N0dWNrPSExLHQod2luZG93KS5vbmUoXCJsb2FkLnpmLnN0aWNreVwiLGZ1bmN0aW9uKCl7bi5jb250YWluZXJIZWlnaHQ9XCJub25lXCI9PW4uJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKT8wOm4uJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LG4uJGNvbnRhaW5lci5jc3MoXCJoZWlnaHRcIixuLmNvbnRhaW5lckhlaWdodCksbi5lbGVtSGVpZ2h0PW4uY29udGFpbmVySGVpZ2h0LFwiXCIhPT1uLm9wdGlvbnMuYW5jaG9yP24uJGFuY2hvcj10KFwiI1wiK24ub3B0aW9ucy5hbmNob3IpOm4uX3BhcnNlUG9pbnRzKCksbi5fc2V0U2l6ZXMoZnVuY3Rpb24oKXt2YXIgdD13aW5kb3cucGFnZVlPZmZzZXQ7bi5fY2FsYyghMSx0KSxuLmlzU3R1Y2t8fG4uX3JlbW92ZVN0aWNreSghKHQ+PW4udG9wUG9pbnQpKX0pLG4uX2V2ZW50cyhpLnNwbGl0KFwiLVwiKS5yZXZlcnNlKCkuam9pbihcIi1cIikpfSl9fSx7a2V5OlwiX3BhcnNlUG9pbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9XCJcIj09dGhpcy5vcHRpb25zLnRvcEFuY2hvcj8xOnRoaXMub3B0aW9ucy50b3BBbmNob3IsaT1cIlwiPT10aGlzLm9wdGlvbnMuYnRtQW5jaG9yP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ6dGhpcy5vcHRpb25zLmJ0bUFuY2hvcixuPVtlLGldLHM9e30sbz0wLGE9bi5sZW5ndGg7bzxhJiZuW29dO28rKyl7dmFyIHI7aWYoXCJudW1iZXJcIj09dHlwZW9mIG5bb10pcj1uW29dO2Vsc2V7dmFyIGw9bltvXS5zcGxpdChcIjpcIiksdT10KFwiI1wiK2xbMF0pO3I9dS5vZmZzZXQoKS50b3AsbFsxXSYmXCJib3R0b21cIj09PWxbMV0udG9Mb3dlckNhc2UoKSYmKHIrPXVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KX1zW29dPXJ9dGhpcy5wb2ludHM9c319LHtrZXk6XCJfZXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcyxuPXRoaXMuc2Nyb2xsTGlzdGVuZXI9XCJzY3JvbGwuemYuXCIrZTt0aGlzLmlzT258fCh0aGlzLmNhblN0aWNrJiYodGhpcy5pc09uPSEwLHQod2luZG93KS5vZmYobikub24obixmdW5jdGlvbih0KXswPT09aS5zY3JvbGxDb3VudD8oaS5zY3JvbGxDb3VudD1pLm9wdGlvbnMuY2hlY2tFdmVyeSxpLl9zZXRTaXplcyhmdW5jdGlvbigpe2kuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KX0pKTooaS5zY3JvbGxDb3VudC0tLGkuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KSl9KSksdGhpcy4kZWxlbWVudC5vZmYoXCJyZXNpemVtZS56Zi50cmlnZ2VyXCIpLm9uKFwicmVzaXplbWUuemYudHJpZ2dlclwiLGZ1bmN0aW9uKHQscyl7aS5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtpLl9jYWxjKCExKSxpLmNhblN0aWNrP2kuaXNPbnx8aS5fZXZlbnRzKGUpOmkuaXNPbiYmaS5fcGF1c2VMaXN0ZW5lcnMobil9KX0pKX19LHtrZXk6XCJfcGF1c2VMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmlzT249ITEsdCh3aW5kb3cpLm9mZihlKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJwYXVzZS56Zi5zdGlja3lcIil9fSx7a2V5OlwiX2NhbGNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0JiZ0aGlzLl9zZXRTaXplcygpLHRoaXMuY2FuU3RpY2s/KGV8fChlPXdpbmRvdy5wYWdlWU9mZnNldCksdm9pZChlPj10aGlzLnRvcFBvaW50P2U8PXRoaXMuYm90dG9tUG9pbnQ/dGhpcy5pc1N0dWNrfHx0aGlzLl9zZXRTdGlja3koKTp0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMSk6dGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITApKSk6KHRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSwhMSl9fSx7a2V5OlwiX3NldFN0aWNreVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XCJ0b3BcIj09PWU/XCJtYXJnaW5Ub3BcIjpcIm1hcmdpbkJvdHRvbVwiLG49XCJ0b3BcIj09PWU/XCJib3R0b21cIjpcInRvcFwiLHM9e307c1tpXT10aGlzLm9wdGlvbnNbaV0rXCJlbVwiLHNbZV09MCxzW25dPVwiYXV0b1wiLHRoaXMuaXNTdHVjaz0hMCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaXMtYW5jaG9yZWQgaXMtYXQtXCIrbikuYWRkQ2xhc3MoXCJpcy1zdHVjayBpcy1hdC1cIitlKS5jc3MocykudHJpZ2dlcihcInN0aWNreS56Zi5zdHVja3RvOlwiK2UpLHRoaXMuJGVsZW1lbnQub24oXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXCIsZnVuY3Rpb24oKXt0Ll9zZXRTaXplcygpfSl9fSx7a2V5OlwiX3JlbW92ZVN0aWNreVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XCJ0b3BcIj09PWUsbj17fSxzPSh0aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXS10aGlzLnBvaW50c1swXTp0aGlzLmFuY2hvckhlaWdodCktdGhpcy5lbGVtSGVpZ2h0LG89aT9cIm1hcmdpblRvcFwiOlwibWFyZ2luQm90dG9tXCIsYT10P1widG9wXCI6XCJib3R0b21cIjtuW29dPTAsbi5ib3R0b209XCJhdXRvXCIsdD9uLnRvcD0wOm4udG9wPXMsdGhpcy5pc1N0dWNrPSExLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJpcy1zdHVjayBpcy1hdC1cIitlKS5hZGRDbGFzcyhcImlzLWFuY2hvcmVkIGlzLWF0LVwiK2EpLmNzcyhuKS50cmlnZ2VyKFwic3RpY2t5LnpmLnVuc3R1Y2tmcm9tOlwiK2EpfX0se2tleTpcIl9zZXRTaXplc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY2FuU3RpY2s9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zdGlja3lPbiksdGhpcy5jYW5TdGlja3x8dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmdCgpO3ZhciBlPXRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxpPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksbj1wYXJzZUludChpW1wicGFkZGluZy1sZWZ0XCJdLDEwKSxzPXBhcnNlSW50KGlbXCJwYWRkaW5nLXJpZ2h0XCJdLDEwKTt0aGlzLiRhbmNob3ImJnRoaXMuJGFuY2hvci5sZW5ndGg/dGhpcy5hbmNob3JIZWlnaHQ9dGhpcy4kYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDp0aGlzLl9wYXJzZVBvaW50cygpLHRoaXMuJGVsZW1lbnQuY3NzKHtcIm1heC13aWR0aFwiOmUtbi1zK1wicHhcIn0pO3ZhciBvPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fHx0aGlzLmNvbnRhaW5lckhlaWdodDtpZihcIm5vbmVcIj09dGhpcy4kZWxlbWVudC5jc3MoXCJkaXNwbGF5XCIpJiYobz0wKSx0aGlzLmNvbnRhaW5lckhlaWdodD1vLHRoaXMuJGNvbnRhaW5lci5jc3Moe2hlaWdodDpvfSksdGhpcy5lbGVtSGVpZ2h0PW8sIXRoaXMuaXNTdHVjayYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImlzLWF0LWJvdHRvbVwiKSl7dmFyIGE9KHRoaXMucG9pbnRzP3RoaXMucG9pbnRzWzFdLXRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS50b3A6dGhpcy5hbmNob3JIZWlnaHQpLXRoaXMuZWxlbUhlaWdodDt0aGlzLiRlbGVtZW50LmNzcyhcInRvcFwiLGEpfXRoaXMuX3NldEJyZWFrUG9pbnRzKG8sZnVuY3Rpb24oKXt0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ0KCl9KX19LHtrZXk6XCJfc2V0QnJlYWtQb2ludHNcIix2YWx1ZTpmdW5jdGlvbih0LGkpe2lmKCF0aGlzLmNhblN0aWNrKXtpZighaXx8XCJmdW5jdGlvblwiIT10eXBlb2YgaSlyZXR1cm4hMTtpKCl9dmFyIG49ZSh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxzPWUodGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksbz10aGlzLnBvaW50cz90aGlzLnBvaW50c1swXTp0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLGE9dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMV06byt0aGlzLmFuY2hvckhlaWdodCxyPXdpbmRvdy5pbm5lckhlaWdodDtcInRvcFwiPT09dGhpcy5vcHRpb25zLnN0aWNrVG8/KG8tPW4sYS09dCtuKTpcImJvdHRvbVwiPT09dGhpcy5vcHRpb25zLnN0aWNrVG8mJihvLT1yLSh0K3MpLGEtPXItcyksdGhpcy50b3BQb2ludD1vLHRoaXMuYm90dG9tUG9pbnQ9YSxpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiZpKCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcytcIiBpcy1hbmNob3JlZCBpcy1hdC10b3BcIikuY3NzKHtoZWlnaHQ6XCJcIix0b3A6XCJcIixib3R0b206XCJcIixcIm1heC13aWR0aFwiOlwiXCJ9KS5vZmYoXCJyZXNpemVtZS56Zi50cmlnZ2VyXCIpLHRoaXMuJGFuY2hvciYmdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9mZihcImNoYW5nZS56Zi5zdGlja3lcIiksdCh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKSx0aGlzLndhc1dyYXBwZWQ/dGhpcy4kZWxlbWVudC51bndyYXAoKTp0aGlzLiRjb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKS5jc3Moe2hlaWdodDpcIlwifSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpfX1dKSxpfSgpO2kuZGVmYXVsdHM9e2NvbnRhaW5lcjpcIjxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PlwiLHN0aWNrVG86XCJ0b3BcIixhbmNob3I6XCJcIix0b3BBbmNob3I6XCJcIixidG1BbmNob3I6XCJcIixtYXJnaW5Ub3A6MSxtYXJnaW5Cb3R0b206MSxzdGlja3lPbjpcIm1lZGl1bVwiLHN0aWNreUNsYXNzOlwic3RpY2t5XCIsY29udGFpbmVyQ2xhc3M6XCJzdGlja3ktY29udGFpbmVyXCIsY2hlY2tFdmVyeTotMX0sRm91bmRhdGlvbi5wbHVnaW4oaSxcIlN0aWNreVwiKX0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZX19KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiVGFic1wiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFwiVGFic1wiLHtFTlRFUjpcIm9wZW5cIixTUEFDRTpcIm9wZW5cIixBUlJPV19SSUdIVDpcIm5leHRcIixBUlJPV19VUDpcInByZXZpb3VzXCIsQVJST1dfRE9XTjpcIm5leHRcIixBUlJPV19MRUZUOlwicHJldmlvdXNcIn0pfXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKHRoaXMuJGVsZW1lbnQuYXR0cih7cm9sZTpcInRhYmxpc3RcIn0pLHRoaXMuJHRhYlRpdGxlcz10aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyksdGhpcy4kdGFiQ29udGVudD10KCdbZGF0YS10YWJzLWNvbnRlbnQ9XCInK3RoaXMuJGVsZW1lbnRbMF0uaWQrJ1wiXScpLHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcImFcIikscz1pLmhhc0NsYXNzKFwiXCIrZS5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyksbz1uWzBdLmhhc2guc2xpY2UoMSksYT1uWzBdLmlkP25bMF0uaWQ6bytcIi1sYWJlbFwiLHI9dChcIiNcIitvKTtpZihpLmF0dHIoe3JvbGU6XCJwcmVzZW50YXRpb25cIn0pLG4uYXR0cih7cm9sZTpcInRhYlwiLFwiYXJpYS1jb250cm9sc1wiOm8sXCJhcmlhLXNlbGVjdGVkXCI6cyxpZDphfSksci5hdHRyKHtyb2xlOlwidGFicGFuZWxcIixcImFyaWEtaGlkZGVuXCI6IXMsXCJhcmlhLWxhYmVsbGVkYnlcIjphfSkscyYmZS5vcHRpb25zLmF1dG9Gb2N1cyYmdCh3aW5kb3cpLmxvYWQoZnVuY3Rpb24oKXt0KFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtzY3JvbGxUb3A6aS5vZmZzZXQoKS50b3B9LGUub3B0aW9ucy5kZWVwTGlua1NtdWRnZURlbGF5LGZ1bmN0aW9uKCl7bi5mb2N1cygpfSl9KSxlLm9wdGlvbnMuZGVlcExpbmspe3ZhciBsPXdpbmRvdy5sb2NhdGlvbi5oYXNoO2lmKGwubGVuZ3RoKXt2YXIgbj1pLmZpbmQoJ1tocmVmPVwiJytsKydcIl0nKTtuLmxlbmd0aCYmKGUuc2VsZWN0VGFiKHQobCkpLGUub3B0aW9ucy5kZWVwTGlua1NtdWRnZSYmdCh3aW5kb3cpLmxvYWQoZnVuY3Rpb24oKXt2YXIgbj1pLm9mZnNldCgpO3QoXCJodG1sLCBib2R5XCIpLmFuaW1hdGUoe3Njcm9sbFRvcDpuLnRvcH0sZS5vcHRpb25zLmRlZXBMaW5rU211ZGdlRGVsYXkpfSksaS50cmlnZ2VyKFwiZGVlcGxpbmsuemYudGFic1wiLFtuLHQobCldKSl9fX0pLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7dmFyIGk9dGhpcy4kdGFiQ29udGVudC5maW5kKFwiaW1nXCIpO2kubGVuZ3RoP0ZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoaSx0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk6dGhpcy5fc2V0SGVpZ2h0KCl9dGhpcy5fZXZlbnRzKCl9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fYWRkS2V5SGFuZGxlcigpLHRoaXMuX2FkZENsaWNrSGFuZGxlcigpLHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcj1udWxsLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCYmKHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcj10aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSx0KHdpbmRvdykub24oXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcIix0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpKX19LHtrZXk6XCJfYWRkQ2xpY2tIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFwiY2xpY2suemYudGFic1wiKS5vbihcImNsaWNrLnpmLnRhYnNcIixcIi5cIit0aGlzLm9wdGlvbnMubGlua0NsYXNzLGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxpLnN0b3BQcm9wYWdhdGlvbigpLGUuX2hhbmRsZVRhYkNoYW5nZSh0KHRoaXMpKX0pfX0se2tleTpcIl9hZGRLZXlIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuJHRhYlRpdGxlcy5vZmYoXCJrZXlkb3duLnpmLnRhYnNcIikub24oXCJrZXlkb3duLnpmLnRhYnNcIixmdW5jdGlvbihpKXtpZig5IT09aS53aGljaCl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcInVsXCIpLmNoaWxkcmVuKFwibGlcIik7YS5lYWNoKGZ1bmN0aW9uKGkpe2lmKHQodGhpcykuaXMobykpcmV0dXJuIHZvaWQoZS5vcHRpb25zLndyYXBPbktleXM/KG49MD09PWk/YS5sYXN0KCk6YS5lcShpLTEpLHM9aT09PWEubGVuZ3RoLTE/YS5maXJzdCgpOmEuZXEoaSsxKSk6KG49YS5lcShNYXRoLm1heCgwLGktMSkpLHM9YS5lcShNYXRoLm1pbihpKzEsYS5sZW5ndGgtMSkpKSl9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFwiVGFic1wiLHtvcGVuOmZ1bmN0aW9uKCl7by5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCksZS5faGFuZGxlVGFiQ2hhbmdlKG8pfSxwcmV2aW91czpmdW5jdGlvbigpe24uZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShuKX0sbmV4dDpmdW5jdGlvbigpe3MuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShzKX0saGFuZGxlZDpmdW5jdGlvbigpe2kuc3RvcFByb3BhZ2F0aW9uKCksaS5wcmV2ZW50RGVmYXVsdCgpfX0pfX0pfX0se2tleTpcIl9oYW5kbGVUYWJDaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0Lmhhc0NsYXNzKFwiXCIrdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpcmV0dXJuIHZvaWQodGhpcy5vcHRpb25zLmFjdGl2ZUNvbGxhcHNlJiYodGhpcy5fY29sbGFwc2VUYWIodCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiY29sbGFwc2UuemYudGFic1wiLFt0XSkpKTt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcytcIi5cIit0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSxpPXQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKSxuPWlbMF0uaGFzaCxzPXRoaXMuJHRhYkNvbnRlbnQuZmluZChuKTtpZih0aGlzLl9jb2xsYXBzZVRhYihlKSx0aGlzLl9vcGVuVGFiKHQpLHRoaXMub3B0aW9ucy5kZWVwTGluayl7dmFyIG89dC5maW5kKFwiYVwiKS5hdHRyKFwiaHJlZlwiKTt0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeT9oaXN0b3J5LnB1c2hTdGF0ZSh7fSxcIlwiLG8pOmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LFwiXCIsbyl9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiY2hhbmdlLnpmLnRhYnNcIixbdCxzXSkscy5maW5kKFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKX19LHtrZXk6XCJfb3BlblRhYlwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKSxpPWVbMF0uaGFzaCxuPXRoaXMuJHRhYkNvbnRlbnQuZmluZChpKTt0LmFkZENsYXNzKFwiXCIrdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyksZS5hdHRyKHtcImFyaWEtc2VsZWN0ZWRcIjpcInRydWVcIn0pLG4uYWRkQ2xhc3MoXCJcIit0aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykuYXR0cih7XCJhcmlhLWhpZGRlblwiOlwiZmFsc2VcIn0pfX0se2tleTpcIl9jb2xsYXBzZVRhYlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpPWUucmVtb3ZlQ2xhc3MoXCJcIit0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKS5maW5kKCdbcm9sZT1cInRhYlwiXScpLmF0dHIoe1wiYXJpYS1zZWxlY3RlZFwiOlwiZmFsc2VcIn0pO3QoXCIjXCIraS5hdHRyKFwiYXJpYS1jb250cm9sc1wiKSkucmVtb3ZlQ2xhc3MoXCJcIit0aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykuYXR0cih7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSl9fSx7a2V5Olwic2VsZWN0VGFiXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7ZT1cIm9iamVjdFwiPT10eXBlb2YgdD90WzBdLmlkOnQsZS5pbmRleE9mKFwiI1wiKTwwJiYoZT1cIiNcIitlKTt2YXIgaT10aGlzLiR0YWJUaXRsZXMuZmluZCgnW2hyZWY9XCInK2UrJ1wiXScpLnBhcmVudChcIi5cIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKTt0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoaSl9fSx7a2V5OlwiX3NldEhlaWdodFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9MDt0aGlzLiR0YWJDb250ZW50LmZpbmQoXCIuXCIrdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmNzcyhcImhlaWdodFwiLFwiXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5oYXNDbGFzcyhcIlwiK3RoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKTtufHxpLmNzcyh7dmlzaWJpbGl0eTpcImhpZGRlblwiLGRpc3BsYXk6XCJibG9ja1wifSk7dmFyIHM9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7bnx8aS5jc3Moe3Zpc2liaWxpdHk6XCJcIixkaXNwbGF5OlwiXCJ9KSxlPXM+ZT9zOmV9KS5jc3MoXCJoZWlnaHRcIixlK1wicHhcIil9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5maW5kKFwiLlwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MpLm9mZihcIi56Zi50YWJzXCIpLmhpZGUoKS5lbmQoKS5maW5kKFwiLlwiK3RoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5oaWRlKCksdGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0JiZudWxsIT10aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXImJnQod2luZG93KS5vZmYoXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcIix0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKX19XSksZX0oKTtlLmRlZmF1bHRzPXtkZWVwTGluazohMSxkZWVwTGlua1NtdWRnZTohMSxkZWVwTGlua1NtdWRnZURlbGF5OjMwMCx1cGRhdGVIaXN0b3J5OiExLGF1dG9Gb2N1czohMSx3cmFwT25LZXlzOiEwLG1hdGNoSGVpZ2h0OiExLGFjdGl2ZUNvbGxhcHNlOiExLGxpbmtDbGFzczpcInRhYnMtdGl0bGVcIixsaW5rQWN0aXZlQ2xhc3M6XCJpcy1hY3RpdmVcIixwYW5lbENsYXNzOlwidGFicy1wYW5lbFwiLHBhbmVsQWN0aXZlQ2xhc3M6XCJpcy1hY3RpdmVcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIlRhYnNcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsaS5kYXRhKCksbiksdGhpcy5jbGFzc05hbWU9XCJcIix0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFwiVG9nZ2xlclwiKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7dGhpcy5vcHRpb25zLmFuaW1hdGU/KGU9dGhpcy5vcHRpb25zLmFuaW1hdGUuc3BsaXQoXCIgXCIpLHRoaXMuYW5pbWF0aW9uSW49ZVswXSx0aGlzLmFuaW1hdGlvbk91dD1lWzFdfHxudWxsKTooZT10aGlzLiRlbGVtZW50LmRhdGEoXCJ0b2dnbGVyXCIpLHRoaXMuY2xhc3NOYW1lPVwiLlwiPT09ZVswXT9lLnNsaWNlKDEpOmUpO3ZhciBpPXRoaXMuJGVsZW1lbnRbMF0uaWQ7dCgnW2RhdGEtb3Blbj1cIicraSsnXCJdLCBbZGF0YS1jbG9zZT1cIicraSsnXCJdLCBbZGF0YS10b2dnbGU9XCInK2krJ1wiXScpLmF0dHIoXCJhcmlhLWNvbnRyb2xzXCIsaSksdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCF0aGlzLiRlbGVtZW50LmlzKFwiOmhpZGRlblwiKSl9fSx7a2V5OlwiX2V2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5vZmYoXCJ0b2dnbGUuemYudHJpZ2dlclwiKS5vbihcInRvZ2dsZS56Zi50cmlnZ2VyXCIsdGhpcy50b2dnbGUuYmluZCh0aGlzKSl9fSx7a2V5OlwidG9nZ2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlP1wiX3RvZ2dsZUFuaW1hdGVcIjpcIl90b2dnbGVDbGFzc1wiXSgpfX0se2tleTpcIl90b2dnbGVDbGFzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dmFyIHQ9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dD90aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJvbi56Zi50b2dnbGVyXCIpOnRoaXMuJGVsZW1lbnQudHJpZ2dlcihcIm9mZi56Zi50b2dnbGVyXCIpLHRoaXMuX3VwZGF0ZUFSSUEodCksdGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKX19LHtrZXk6XCJfdG9nZ2xlQW5pbWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLiRlbGVtZW50LmlzKFwiOmhpZGRlblwiKT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCx0aGlzLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7dC5fdXBkYXRlQVJJQSghMCksdGhpcy50cmlnZ2VyKFwib24uemYudG9nZ2xlclwiKSx0aGlzLmZpbmQoXCJbZGF0YS1tdXRhdGVdXCIpLnRyaWdnZXIoXCJtdXRhdGVtZS56Zi50cmlnZ2VyXCIpfSk6Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uT3V0LGZ1bmN0aW9uKCl7dC5fdXBkYXRlQVJJQSghMSksdGhpcy50cmlnZ2VyKFwib2ZmLnpmLnRvZ2dsZXJcIiksdGhpcy5maW5kKFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKX0pfX0se2tleTpcIl91cGRhdGVBUklBXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEhdCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5vZmYoXCIuemYudG9nZ2xlclwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17YW5pbWF0ZTohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcIlRvZ2dsZXJcIil9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGV9fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5pc0FjdGl2ZT0hMSx0aGlzLmlzQ2xpY2s9ITEsdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcIlRvb2x0aXBcIil9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIil8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcInRvb2x0aXBcIik7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3M9dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3N8fHRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy4kZWxlbWVudCksdGhpcy5vcHRpb25zLnRpcFRleHQ9dGhpcy5vcHRpb25zLnRpcFRleHR8fHRoaXMuJGVsZW1lbnQuYXR0cihcInRpdGxlXCIpLHRoaXMudGVtcGxhdGU9dGhpcy5vcHRpb25zLnRlbXBsYXRlP3QodGhpcy5vcHRpb25zLnRlbXBsYXRlKTp0aGlzLl9idWlsZFRlbXBsYXRlKGUpLHRoaXMub3B0aW9ucy5hbGxvd0h0bWw/dGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5odG1sKHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk6dGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS50ZXh0KHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCksdGhpcy4kZWxlbWVudC5hdHRyKHt0aXRsZTpcIlwiLFwiYXJpYS1kZXNjcmliZWRieVwiOmUsXCJkYXRhLXlldGktYm94XCI6ZSxcImRhdGEtdG9nZ2xlXCI6ZSxcImRhdGEtcmVzaXplXCI6ZX0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpLHRoaXMudXNlZFBvc2l0aW9ucz1bXSx0aGlzLmNvdW50ZXI9NCx0aGlzLmNsYXNzQ2hhbmdlZD0hMSx0aGlzLl9ldmVudHMoKX19LHtrZXk6XCJfZ2V0UG9zaXRpb25DbGFzc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0KXJldHVyblwiXCI7dmFyIGU9dFswXS5jbGFzc05hbWUubWF0Y2goL1xcYih0b3B8bGVmdHxyaWdodClcXGIvZyk7cmV0dXJuIGU9ZT9lWzBdOlwiXCJ9fSx7a2V5OlwiX2J1aWxkVGVtcGxhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT0odGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcytcIiBcIit0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcytcIiBcIit0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCksbj10KFwiPGRpdj48L2Rpdj5cIikuYWRkQ2xhc3MoaSkuYXR0cih7cm9sZTpcInRvb2x0aXBcIixcImFyaWEtaGlkZGVuXCI6ITAsXCJkYXRhLWlzLWFjdGl2ZVwiOiExLFwiZGF0YS1pcy1mb2N1c1wiOiExLGlkOmV9KTtyZXR1cm4gbn19LHtrZXk6XCJfcmVwb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQ/dDpcImJvdHRvbVwiKSwhdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJ0b3BcIik8MD90aGlzLnRlbXBsYXRlLmFkZENsYXNzKFwidG9wXCIpOlwidG9wXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImJvdHRvbVwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6XCJsZWZ0XCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcInJpZ2h0XCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcInJpZ2h0XCIpOlwicmlnaHRcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwibGVmdFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXCJsZWZ0XCIpOiF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcInRvcFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXCJsZWZ0XCIpPDA/dGhpcy50ZW1wbGF0ZS5hZGRDbGFzcyhcImxlZnRcIik6XCJ0b3BcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwiYm90dG9tXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImxlZnRcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFwibGVmdFwiKTpcImxlZnRcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwicmlnaHRcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwiYm90dG9tXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTpcInJpZ2h0XCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcImxlZnRcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFwiYm90dG9tXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTp0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLHRoaXMuY291bnRlci0tfX0se2tleTpcIl9zZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy50ZW1wbGF0ZSksaT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLG49XCJsZWZ0XCI9PT10P1wibGVmdFwiOlwicmlnaHRcIj09PXQ/XCJsZWZ0XCI6XCJ0b3BcIixzPVwidG9wXCI9PT1uP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiO1wiaGVpZ2h0XCI9PT1zP3RoaXMub3B0aW9ucy52T2Zmc2V0OnRoaXMub3B0aW9ucy5oT2Zmc2V0O2lmKGUud2lkdGg+PWUud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpcmV0dXJuIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LFwiY2VudGVyIGJvdHRvbVwiLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LCEwKSkuY3NzKHt3aWR0aDppLndpbmRvd0RpbXMud2lkdGgtMip0aGlzLm9wdGlvbnMuaE9mZnNldCxoZWlnaHQ6XCJhdXRvXCJ9KSwhMTtmb3IodGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLHRoaXMuJGVsZW1lbnQsXCJjZW50ZXIgXCIrKHR8fFwiYm90dG9tXCIpLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7IUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkmJnRoaXMuY291bnRlcjspdGhpcy5fcmVwb3NpdGlvbih0KSx0aGlzLl9zZXRQb3NpdGlvbigpfX0se2tleTpcInNob3dcIix2YWx1ZTpmdW5jdGlvbigpe2lmKFwiYWxsXCIhPT10aGlzLm9wdGlvbnMuc2hvd09uJiYhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zaG93T24pKXJldHVybiExO3ZhciB0PXRoaXM7dGhpcy50ZW1wbGF0ZS5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIikuc2hvdygpLHRoaXMuX3NldFBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiY2xvc2VtZS56Zi50b29sdGlwXCIsdGhpcy50ZW1wbGF0ZS5hdHRyKFwiaWRcIikpLHRoaXMudGVtcGxhdGUuYXR0cih7XCJkYXRhLWlzLWFjdGl2ZVwiOiEwLFwiYXJpYS1oaWRkZW5cIjohMX0pLHQuaXNBY3RpdmU9ITAsdGhpcy50ZW1wbGF0ZS5zdG9wKCkuaGlkZSgpLmNzcyhcInZpc2liaWxpdHlcIixcIlwiKS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVJbkR1cmF0aW9uLGZ1bmN0aW9uKCl7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwic2hvdy56Zi50b29sdGlwXCIpfX0se2tleTpcImhpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XCJhcmlhLWhpZGRlblwiOiEwLFwiZGF0YS1pcy1hY3RpdmVcIjohMX0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbixmdW5jdGlvbigpe3QuaXNBY3RpdmU9ITEsdC5pc0NsaWNrPSExLHQuY2xhc3NDaGFuZ2VkJiYodC50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0Ll9nZXRQb3NpdGlvbkNsYXNzKHQudGVtcGxhdGUpKS5hZGRDbGFzcyh0Lm9wdGlvbnMucG9zaXRpb25DbGFzcyksdC51c2VkUG9zaXRpb25zPVtdLHQuY291bnRlcj00LHQuY2xhc3NDaGFuZ2VkPSExKX0pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImhpZGUuemYudG9vbHRpcFwiKX19LHtrZXk6XCJfZXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9KHRoaXMudGVtcGxhdGUsITEpO3RoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJGVsZW1lbnQub24oXCJtb3VzZWVudGVyLnpmLnRvb2x0aXBcIixmdW5jdGlvbihlKXt0LmlzQWN0aXZlfHwodC50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LnNob3coKX0sdC5vcHRpb25zLmhvdmVyRGVsYXkpKX0pLm9uKFwibW91c2VsZWF2ZS56Zi50b29sdGlwXCIsZnVuY3Rpb24oaSl7Y2xlYXJUaW1lb3V0KHQudGltZW91dCksKCFlfHx0LmlzQ2xpY2smJiF0Lm9wdGlvbnMuY2xpY2tPcGVuKSYmdC5oaWRlKCl9KSx0aGlzLm9wdGlvbnMuY2xpY2tPcGVuP3RoaXMuJGVsZW1lbnQub24oXCJtb3VzZWRvd24uemYudG9vbHRpcFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5pc0NsaWNrfHwodC5pc0NsaWNrPSEwLCF0Lm9wdGlvbnMuZGlzYWJsZUhvdmVyJiZ0LiRlbGVtZW50LmF0dHIoXCJ0YWJpbmRleFwiKXx8dC5pc0FjdGl2ZXx8dC5zaG93KCkpfSk6dGhpcy4kZWxlbWVudC5vbihcIm1vdXNlZG93bi56Zi50b29sdGlwXCIsZnVuY3Rpb24oZSl7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0LmlzQ2xpY2s9ITB9KSx0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNofHx0aGlzLiRlbGVtZW50Lm9uKFwidGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmU/dC5oaWRlKCk6dC5zaG93KCl9KSx0aGlzLiRlbGVtZW50Lm9uKHtcImNsb3NlLnpmLnRyaWdnZXJcIjp0aGlzLmhpZGUuYmluZCh0aGlzKX0pLHRoaXMuJGVsZW1lbnQub24oXCJmb2N1cy56Zi50b29sdGlwXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGU9ITAsdC5pc0NsaWNrPyh0Lm9wdGlvbnMuY2xpY2tPcGVufHwoZT0hMSksITEpOnZvaWQgdC5zaG93KCl9KS5vbihcImZvY3Vzb3V0LnpmLnRvb2x0aXBcIixmdW5jdGlvbihpKXtlPSExLHQuaXNDbGljaz0hMSx0LmhpZGUoKX0pLm9uKFwicmVzaXplbWUuemYudHJpZ2dlclwiLGZ1bmN0aW9uKCl7dC5pc0FjdGl2ZSYmdC5fc2V0UG9zaXRpb24oKX0pfX0se2tleTpcInRvZ2dsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc0FjdGl2ZT90aGlzLmhpZGUoKTp0aGlzLnNob3coKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LmF0dHIoXCJ0aXRsZVwiLHRoaXMudGVtcGxhdGUudGV4dCgpKS5vZmYoXCIuemYudHJpZ2dlciAuemYudG9vbHRpcFwiKS5yZW1vdmVDbGFzcyhcImhhcy10aXAgdG9wIHJpZ2h0IGxlZnRcIikucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnkgYXJpYS1oYXNwb3B1cCBkYXRhLWRpc2FibGUtaG92ZXIgZGF0YS1yZXNpemUgZGF0YS10b2dnbGUgZGF0YS10b29sdGlwIGRhdGEteWV0aS1ib3hcIiksdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyl9fV0pLGV9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUZvclRvdWNoOiExLGhvdmVyRGVsYXk6MjAwLGZhZGVJbkR1cmF0aW9uOjE1MCxmYWRlT3V0RHVyYXRpb246MTUwLGRpc2FibGVIb3ZlcjohMSx0ZW1wbGF0ZUNsYXNzZXM6XCJcIix0b29sdGlwQ2xhc3M6XCJ0b29sdGlwXCIsdHJpZ2dlckNsYXNzOlwiaGFzLXRpcFwiLHNob3dPbjpcInNtYWxsXCIsdGVtcGxhdGU6XCJcIix0aXBUZXh0OlwiXCIsdG91Y2hDbG9zZVRleHQ6XCJUYXAgdG8gY2xvc2UuXCIsY2xpY2tPcGVuOiEwLHBvc2l0aW9uQ2xhc3M6XCJcIix2T2Zmc2V0OjEwLGhPZmZzZXQ6MTIsYWxsb3dIdG1sOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFwiVG9vbHRpcFwiKX0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZX19KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9dChpKSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5ydWxlcz10aGlzLiRlbGVtZW50LmRhdGEoXCJyZXNwb25zaXZlLWFjY29yZGlvbi10YWJzXCIpLHRoaXMuY3VycmVudE1xPW51bGwsdGhpcy5jdXJyZW50UGx1Z2luPW51bGwsdGhpcy4kZWxlbWVudC5hdHRyKFwiaWRcIil8fHRoaXMuJGVsZW1lbnQuYXR0cihcImlkXCIsRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFwicmVzcG9uc2l2ZWFjY29yZGlvbnRhYnNcIikpLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXCJSZXNwb25zaXZlQWNjb3JkaW9uVGFic1wiKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMucnVsZXMpe2Zvcih2YXIgZT17fSxuPXRoaXMucnVsZXMuc3BsaXQoXCIgXCIpLHM9MDtzPG4ubGVuZ3RoO3MrKyl7dmFyIG89bltzXS5zcGxpdChcIi1cIiksYT1vLmxlbmd0aD4xP29bMF06XCJzbWFsbFwiLHI9by5sZW5ndGg+MT9vWzFdOm9bMF07bnVsbCE9PWlbcl0mJihlW2FdPWlbcl0pfXRoaXMucnVsZXM9ZX10aGlzLl9nZXRBbGxPcHRpb25zKCksdC5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpfHx0aGlzLl9jaGVja01lZGlhUXVlcmllcygpfX0se2tleTpcIl9nZXRBbGxPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2UuYWxsT3B0aW9ucz17fTtmb3IodmFyIG4gaW4gaSlpZihpLmhhc093blByb3BlcnR5KG4pKXt2YXIgcz1pW25dO3RyeXt2YXIgbz10KFwiPHVsPjwvdWw+XCIpLGE9bmV3IHMucGx1Z2luKG8sZS5vcHRpb25zKTtmb3IodmFyIHIgaW4gYS5vcHRpb25zKWlmKGEub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShyKSYmXCJ6ZlBsdWdpblwiIT09cil7dmFyIGw9YS5vcHRpb25zW3JdO2UuYWxsT3B0aW9uc1tyXT1sfWEuZGVzdHJveSgpfWNhdGNoKHQpe319fX0se2tleTpcIl9ldmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XCIsZnVuY3Rpb24oKXtlLl9jaGVja01lZGlhUXVlcmllcygpfSl9fSx7a2V5OlwiX2NoZWNrTWVkaWFRdWVyaWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSxuPXRoaXM7dC5lYWNoKHRoaXMucnVsZXMsZnVuY3Rpb24odCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodCkmJihlPXQpfSksZSYmKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbZV0ucGx1Z2lufHwodC5lYWNoKGksZnVuY3Rpb24odCxlKXtuLiRlbGVtZW50LnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3MpfSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSx0aGlzLmN1cnJlbnRQbHVnaW4mJighdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoXCJ6ZlBsdWdpblwiKSYmdGhpcy5zdG9yZXpmRGF0YSYmdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoXCJ6ZlBsdWdpblwiLHRoaXMuc3RvcmV6ZkRhdGEpLHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCkpLHRoaXMuX2hhbmRsZU1hcmt1cCh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSx0aGlzLmN1cnJlbnRQbHVnaW49bmV3IHRoaXMucnVsZXNbZV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQse30pLHRoaXMuc3RvcmV6ZkRhdGE9dGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoXCJ6ZlBsdWdpblwiKSkpfX0se2tleTpcIl9oYW5kbGVNYXJrdXBcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLG49XCJhY2NvcmRpb25cIixzPXQoXCJbZGF0YS10YWJzLWNvbnRlbnQ9XCIrdGhpcy4kZWxlbWVudC5hdHRyKFwiaWRcIikrXCJdXCIpO2lmKHMubGVuZ3RoJiYobj1cInRhYnNcIiksbiE9PWUpe3ZhciBvPWkuYWxsT3B0aW9ucy5saW5rQ2xhc3M/aS5hbGxPcHRpb25zLmxpbmtDbGFzczpcInRhYnMtdGl0bGVcIixhPWkuYWxsT3B0aW9ucy5wYW5lbENsYXNzP2kuYWxsT3B0aW9ucy5wYW5lbENsYXNzOlwidGFicy1wYW5lbFwiO3RoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cihcInJvbGVcIik7dmFyIHI9dGhpcy4kZWxlbWVudC5jaGlsZHJlbihcIi5cIitvK1wiLFtkYXRhLWFjY29yZGlvbi1pdGVtXVwiKS5yZW1vdmVDbGFzcyhvKS5yZW1vdmVDbGFzcyhcImFjY29yZGlvbi1pdGVtXCIpLnJlbW92ZUF0dHIoXCJkYXRhLWFjY29yZGlvbi1pdGVtXCIpLGw9ci5jaGlsZHJlbihcImFcIikucmVtb3ZlQ2xhc3MoXCJhY2NvcmRpb24tdGl0bGVcIik7aWYoXCJ0YWJzXCI9PT1uPyhzPXMuY2hpbGRyZW4oXCIuXCIrYSkucmVtb3ZlQ2xhc3MoYSkucmVtb3ZlQXR0cihcInJvbGVcIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWxhYmVsbGVkYnlcIikscy5jaGlsZHJlbihcImFcIikucmVtb3ZlQXR0cihcInJvbGVcIikucmVtb3ZlQXR0cihcImFyaWEtY29udHJvbHNcIikucmVtb3ZlQXR0cihcImFyaWEtc2VsZWN0ZWRcIikpOnM9ci5jaGlsZHJlbihcIltkYXRhLXRhYi1jb250ZW50XVwiKS5yZW1vdmVDbGFzcyhcImFjY29yZGlvbi1jb250ZW50XCIpLHMuY3NzKHtkaXNwbGF5OlwiXCIsdmlzaWJpbGl0eTpcIlwifSksci5jc3Moe2Rpc3BsYXk6XCJcIix2aXNpYmlsaXR5OlwiXCJ9KSxcImFjY29yZGlvblwiPT09ZSlzLmVhY2goZnVuY3Rpb24oZSxuKXt0KG4pLmFwcGVuZFRvKHIuZ2V0KGUpKS5hZGRDbGFzcyhcImFjY29yZGlvbi1jb250ZW50XCIpLmF0dHIoXCJkYXRhLXRhYi1jb250ZW50XCIsXCJcIikucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIikuY3NzKHtoZWlnaHQ6XCJcIn0pLHQoXCJbZGF0YS10YWJzLWNvbnRlbnQ9XCIraS4kZWxlbWVudC5hdHRyKFwiaWRcIikrXCJdXCIpLmFmdGVyKCc8ZGl2IGlkPVwidGFicy1wbGFjZWhvbGRlci0nK2kuJGVsZW1lbnQuYXR0cihcImlkXCIpKydcIj48L2Rpdj4nKS5yZW1vdmUoKSxyLmFkZENsYXNzKFwiYWNjb3JkaW9uLWl0ZW1cIikuYXR0cihcImRhdGEtYWNjb3JkaW9uLWl0ZW1cIixcIlwiKSxsLmFkZENsYXNzKFwiYWNjb3JkaW9uLXRpdGxlXCIpfSk7ZWxzZSBpZihcInRhYnNcIj09PWUpe3ZhciB1PXQoXCJbZGF0YS10YWJzLWNvbnRlbnQ9XCIraS4kZWxlbWVudC5hdHRyKFwiaWRcIikrXCJdXCIpLGQ9dChcIiN0YWJzLXBsYWNlaG9sZGVyLVwiK2kuJGVsZW1lbnQuYXR0cihcImlkXCIpKTtkLmxlbmd0aD8odT10KCc8ZGl2IGNsYXNzPVwidGFicy1jb250ZW50XCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoZCkuYXR0cihcImRhdGEtdGFicy1jb250ZW50XCIsaS4kZWxlbWVudC5hdHRyKFwiaWRcIikpLGQucmVtb3ZlKCkpOnU9dCgnPGRpdiBjbGFzcz1cInRhYnMtY29udGVudFwiPjwvZGl2PicpLmluc2VydEFmdGVyKGkuJGVsZW1lbnQpLmF0dHIoXCJkYXRhLXRhYnMtY29udGVudFwiLGkuJGVsZW1lbnQuYXR0cihcImlkXCIpKSxzLmVhY2goZnVuY3Rpb24oZSxpKXt2YXIgbj10KGkpLmFwcGVuZFRvKHUpLmFkZENsYXNzKGEpLHM9bC5nZXQoZSkuaGFzaC5zbGljZSgxKSxvPXQoaSkuYXR0cihcImlkXCIpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXCJhY2NvcmRpb25cIik7cyE9PW8mJihcIlwiIT09cz90KGkpLmF0dHIoXCJpZFwiLHMpOihzPW8sdChpKS5hdHRyKFwiaWRcIixzKSx0KGwuZ2V0KGUpKS5hdHRyKFwiaHJlZlwiLHQobC5nZXQoZSkpLmF0dHIoXCJocmVmXCIpLnJlcGxhY2UoXCIjXCIsXCJcIikrXCIjXCIrcykpKTt2YXIgZD10KHIuZ2V0KGUpKS5oYXNDbGFzcyhcImlzLWFjdGl2ZVwiKTtkJiZuLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpfSksci5hZGRDbGFzcyhvKX19fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3VycmVudFBsdWdpbiYmdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKSx0KHdpbmRvdykub2ZmKFwiLnpmLlJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKX19XSksZX0oKTtlLmRlZmF1bHRzPXt9O3ZhciBpPXt0YWJzOntjc3NDbGFzczpcInRhYnNcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2lucy50YWJzfHxudWxsfSxhY2NvcmRpb246e2Nzc0NsYXNzOlwiYWNjb3JkaW9uXCIscGx1Z2luOkZvdW5kYXRpb24uX3BsdWdpbnMuYWNjb3JkaW9ufHxudWxsfX07Rm91bmRhdGlvbi5wbHVnaW4oZSxcIlJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXCIpfShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4xXFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xcbiAqXFxuICogSW5jbHVkZXMgU2l6emxlLmpzXFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE2LTA5LTIyVDIyOjMwWlxcbiAqL1xcbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcXG5cXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcXG5cXHRcXHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxcblxcdFxcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXFxuXFx0XFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXFxuXFx0XFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cXG5cXHRcXHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFxcXCJqcXVlcnlcXFwiKSh3aW5kb3cpO1xcblxcdFxcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xcblxcdFxcdFxcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcXG5cXHRcXHRcXHRmdW5jdGlvbiggdyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICF3LmRvY3VtZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggXFxcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWN0b3J5KCB3ICk7XFxuXFx0XFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZhY3RvcnkoIGdsb2JhbCApO1xcblxcdH1cXG5cXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcXG5cXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxcbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgYXJyID0gW107XFxuXFxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xcblxcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG5cXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XFxuXFxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XFxuXFxudmFyIHB1c2ggPSBhcnIucHVzaDtcXG5cXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xcblxcbnZhciBjbGFzczJ0eXBlID0ge307XFxuXFxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcXG5cXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcXG5cXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcXG5cXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xcblxcbnZhciBzdXBwb3J0ID0ge307XFxuXFxuXFxuXFxuXFx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xcblxcdFxcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFxcXCJzY3JpcHRcXFwiICk7XFxuXFxuXFx0XFx0c2NyaXB0LnRleHQgPSBjb2RlO1xcblxcdFxcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcXG5cXHR9XFxuLyogZ2xvYmFsIFN5bWJvbCAqL1xcbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcXG5cXG5cXG5cXG52YXJcXG5cXHR2ZXJzaW9uID0gXFxcIjMuMS4xXFxcIixcXG5cXG5cXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxcblxcdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcXG5cXG5cXHRcXHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcXG5cXHRcXHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxcblxcdFxcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcXG5cXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcXG5cXHRydHJpbSA9IC9eW1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rfFtcXFxcc1xcXFx1RkVGRlxcXFx4QTBdKyQvZyxcXG5cXG5cXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcXG5cXHRybXNQcmVmaXggPSAvXi1tcy0vLFxcblxcdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcXG5cXG5cXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXFxuXFx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcXG5cXHRcXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XFxuXFx0fTtcXG5cXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xcblxcblxcdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcXG5cXHRqcXVlcnk6IHZlcnNpb24sXFxuXFxuXFx0Y29uc3RydWN0b3I6IGpRdWVyeSxcXG5cXG5cXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcXG5cXHRsZW5ndGg6IDAsXFxuXFxuXFx0dG9BcnJheTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcXG5cXHR9LFxcblxcblxcdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcXG5cXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxcblxcdGdldDogZnVuY3Rpb24oIG51bSApIHtcXG5cXG5cXHRcXHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XFxuXFx0XFx0aWYgKCBudW0gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XFxuXFx0XFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XFxuXFx0fSxcXG5cXG5cXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXFxuXFx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXFxuXFx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XFxuXFxuXFx0XFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcXG5cXHRcXHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XFxuXFxuXFx0XFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcXG5cXHRcXHRyZXQucHJldk9iamVjdCA9IHRoaXM7XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcXG5cXHRcXHRyZXR1cm4gcmV0O1xcblxcdH0sXFxuXFxuXFx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cXG5cXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xcblxcdH0sXFxuXFxuXFx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xcblxcdFxcdH0gKSApO1xcblxcdH0sXFxuXFxuXFx0c2xpY2U6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XFxuXFx0fSxcXG5cXG5cXHRmaXJzdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcXG5cXHR9LFxcblxcblxcdGxhc3Q6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLmVxKCAtMSApO1xcblxcdH0sXFxuXFxuXFx0ZXE6IGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcXG5cXHR9LFxcblxcblxcdGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XFxuXFx0fSxcXG5cXG5cXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXFxuXFx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXFxuXFx0cHVzaDogcHVzaCxcXG5cXHRzb3J0OiBhcnIuc29ydCxcXG5cXHRzcGxpY2U6IGFyci5zcGxpY2VcXG59O1xcblxcbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxcblxcdFxcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxcblxcdFxcdGkgPSAxLFxcblxcdFxcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXFxuXFx0XFx0ZGVlcCA9IGZhbHNlO1xcblxcblxcdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cXG5cXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRkZWVwID0gdGFyZ2V0O1xcblxcblxcdFxcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcXG5cXHRcXHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcXG5cXHRcXHRpKys7XFxuXFx0fVxcblxcblxcdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxcblxcdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXFxcIm9iamVjdFxcXCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcXG5cXHRcXHR0YXJnZXQgPSB7fTtcXG5cXHR9XFxuXFxuXFx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXFxuXFx0aWYgKCBpID09PSBsZW5ndGggKSB7XFxuXFx0XFx0dGFyZ2V0ID0gdGhpcztcXG5cXHRcXHRpLS07XFxuXFx0fVxcblxcblxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcblxcdFxcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcXG5cXHRcXHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XFxuXFx0XFx0XFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xcblxcdFxcdFxcdFxcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxcblxcdFxcdFxcdFxcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcXG5cXHRcXHRcXHRcXHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcXG5cXHRcXHRcXHRcXHRcXHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb3B5SXNBcnJheSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb3B5SXNBcnJheSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0gY29weTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxcblxcdGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXFxcRC9nLCBcXFwiXFxcIiApLFxcblxcblxcdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXFxuXFx0aXNSZWFkeTogdHJ1ZSxcXG5cXG5cXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xcblxcdH0sXFxuXFxuXFx0bm9vcDogZnVuY3Rpb24oKSB7fSxcXG5cXG5cXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFxcXCJmdW5jdGlvblxcXCI7XFxuXFx0fSxcXG5cXG5cXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxcblxcblxcdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XFxuXFx0fSxcXG5cXG5cXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFxuXFx0XFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cXG5cXHRcXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXFxuXFx0XFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2MilcXG5cXHRcXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcXG5cXHRcXHRyZXR1cm4gKCB0eXBlID09PSBcXFwibnVtYmVyXFxcIiB8fCB0eXBlID09PSBcXFwic3RyaW5nXFxcIiApICYmXFxuXFxuXFx0XFx0XFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFxcXCJcXFwiKVxcblxcdFxcdFxcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFxcXCIweC4uLlxcXCIpXFxuXFx0XFx0XFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXFxuXFx0XFx0XFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xcblxcdH0sXFxuXFxuXFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHR2YXIgcHJvdG8sIEN0b3I7XFxuXFxuXFx0XFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXFxuXFx0XFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXFxuXFx0XFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcXFwiW29iamVjdCBPYmplY3RdXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xcblxcblxcdFxcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cXG5cXHRcXHRpZiAoICFwcm90byApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cXG5cXHRcXHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcXFwiY29uc3RydWN0b3JcXFwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XFxuXFx0XFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcXG5cXHR9LFxcblxcblxcdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFxuXFx0XFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG5cXHRcXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcXG5cXHRcXHR2YXIgbmFtZTtcXG5cXG5cXHRcXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0sXFxuXFxuXFx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHRpZiAoIG9iaiA9PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiBvYmogKyBcXFwiXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXFxuXFx0XFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBvYmogPT09IFxcXCJmdW5jdGlvblxcXCIgP1xcblxcdFxcdFxcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXFxcIm9iamVjdFxcXCIgOlxcblxcdFxcdFxcdHR5cGVvZiBvYmo7XFxuXFx0fSxcXG5cXG5cXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxcblxcdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xcblxcdFxcdERPTUV2YWwoIGNvZGUgKTtcXG5cXHR9LFxcblxcblxcdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXFxuXFx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxcblxcdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcXG5cXHRcXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXFxcIm1zLVxcXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XFxuXFx0fSxcXG5cXG5cXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0fSxcXG5cXG5cXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgbGVuZ3RoLCBpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcXG5cXHRcXHRcXHRsZW5ndGggPSBvYmoubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIG9iaiApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gb2JqO1xcblxcdH0sXFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XFxuXFx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XFxuXFx0XFx0XFx0XFxcIlxcXCIgOlxcblxcdFxcdFxcdCggdGV4dCArIFxcXCJcXFwiICkucmVwbGFjZSggcnRyaW0sIFxcXCJcXFwiICk7XFxuXFx0fSxcXG5cXG5cXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XFxuXFx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xcblxcdFxcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdFxcdGlmICggYXJyICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggcmV0LFxcblxcdFxcdFxcdFxcdFxcdHR5cGVvZiBhcnIgPT09IFxcXCJzdHJpbmdcXFwiID9cXG5cXHRcXHRcXHRcXHRcXHRbIGFyciBdIDogYXJyXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fSxcXG5cXG5cXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xcblxcdFxcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcXG5cXHR9LFxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XFxuXFx0XFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxcblxcdFxcdFxcdGogPSAwLFxcblxcdFxcdFxcdGkgPSBmaXJzdC5sZW5ndGg7XFxuXFxuXFx0XFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XFxuXFx0XFx0XFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGZpcnN0Lmxlbmd0aCA9IGk7XFxuXFxuXFx0XFx0cmV0dXJuIGZpcnN0O1xcblxcdH0sXFxuXFxuXFx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xcblxcdFxcdHZhciBjYWxsYmFja0ludmVyc2UsXFxuXFx0XFx0XFx0bWF0Y2hlcyA9IFtdLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XFxuXFxuXFx0XFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xcblxcdFxcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXFxuXFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XFxuXFx0XFx0XFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xcblxcdFxcdFxcdFxcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG1hdGNoZXM7XFxuXFx0fSxcXG5cXG5cXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcXG5cXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcXG5cXHRcXHR2YXIgbGVuZ3RoLCB2YWx1ZSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRyZXQgPSBbXTtcXG5cXG5cXHRcXHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xcblxcdFxcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdFxcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXQucHVzaCggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIGVsZW1zICkge1xcblxcdFxcdFxcdFxcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXQucHVzaCggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0XFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXFxuXFx0Z3VpZDogMSxcXG5cXG5cXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcXG5cXHQvLyBhcmd1bWVudHMuXFxuXFx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcXG5cXHRcXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHR0bXAgPSBmblsgY29udGV4dCBdO1xcblxcdFxcdFxcdGNvbnRleHQgPSBmbjtcXG5cXHRcXHRcXHRmbiA9IHRtcDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcXG5cXHRcXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxcblxcdFxcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNpbXVsYXRlZCBiaW5kXFxuXFx0XFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xcblxcdFxcdHByb3h5ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcXG5cXHRcXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcXG5cXG5cXHRcXHRyZXR1cm4gcHJveHk7XFxuXFx0fSxcXG5cXG5cXHRub3c6IERhdGUubm93LFxcblxcblxcdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxcblxcdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXFxuXFx0c3VwcG9ydDogc3VwcG9ydFxcbn0gKTtcXG5cXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgKSB7XFxuXFx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XFxufVxcblxcbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxcbmpRdWVyeS5lYWNoKCBcXFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcXFwiLnNwbGl0KCBcXFwiIFxcXCIgKSxcXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXHRjbGFzczJ0eXBlWyBcXFwiW29iamVjdCBcXFwiICsgbmFtZSArIFxcXCJdXFxcIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcbn0gKTtcXG5cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xcblxcblxcdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcXG5cXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXFxuXFx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXFxuXFx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxcblxcdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcXFwibGVuZ3RoXFxcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcXG5cXHRcXHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xcblxcblxcdGlmICggdHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHR5cGUgPT09IFxcXCJhcnJheVxcXCIgfHwgbGVuZ3RoID09PSAwIHx8XFxuXFx0XFx0dHlwZW9mIGxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XFxufVxcbnZhciBTaXp6bGUgPVxcbi8qIVxcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xcbiAqXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE2LTA4LTA4XFxuICovXFxuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XFxuXFxudmFyIGksXFxuXFx0c3VwcG9ydCxcXG5cXHRFeHByLFxcblxcdGdldFRleHQsXFxuXFx0aXNYTUwsXFxuXFx0dG9rZW5pemUsXFxuXFx0Y29tcGlsZSxcXG5cXHRzZWxlY3QsXFxuXFx0b3V0ZXJtb3N0Q29udGV4dCxcXG5cXHRzb3J0SW5wdXQsXFxuXFx0aGFzRHVwbGljYXRlLFxcblxcblxcdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcXG5cXHRzZXREb2N1bWVudCxcXG5cXHRkb2N1bWVudCxcXG5cXHRkb2NFbGVtLFxcblxcdGRvY3VtZW50SXNIVE1MLFxcblxcdHJidWdneVFTQSxcXG5cXHRyYnVnZ3lNYXRjaGVzLFxcblxcdG1hdGNoZXMsXFxuXFx0Y29udGFpbnMsXFxuXFxuXFx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxcblxcdGV4cGFuZG8gPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcblxcdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcXG5cXHRkaXJydW5zID0gMCxcXG5cXHRkb25lID0gMCxcXG5cXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcXG5cXHRcXHRpZiAoIGEgPT09IGIgKSB7XFxuXFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDA7XFxuXFx0fSxcXG5cXG5cXHQvLyBJbnN0YW5jZSBtZXRob2RzXFxuXFx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcXG5cXHRhcnIgPSBbXSxcXG5cXHRwb3AgPSBhcnIucG9wLFxcblxcdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXFxuXFx0cHVzaCA9IGFyci5wdXNoLFxcblxcdHNsaWNlID0gYXJyLnNsaWNlLFxcblxcdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxcblxcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcXG5cXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XFxuXFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdGxlbiA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAtMTtcXG5cXHR9LFxcblxcblxcdGJvb2xlYW5zID0gXFxcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXFxcIixcXG5cXG5cXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXFxuXFxuXFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcXG5cXHR3aGl0ZXNwYWNlID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcblxcblxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxcblxcdGlkZW50aWZpZXIgPSBcXFwiKD86XFxcXFxcXFxcXFxcXFxcXC58W1xcXFxcXFxcdy1dfFteXFxcXDAtXFxcXFxcXFx4YTBdKStcXFwiLFxcblxcblxcdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xcblxcdGF0dHJpYnV0ZXMgPSBcXFwiXFxcXFxcXFxbXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKD86XFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXFxuXFx0XFx0XFxcIiooWypeJHwhfl0/PSlcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0Ly8gXFxcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cXFwiXFxuXFx0XFx0XFxcIiooPzonKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcInwoXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKSl8KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXFwiKlxcXFxcXFxcXVxcXCIsXFxuXFxuXFx0cHNldWRvcyA9IFxcXCI6KFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikoPzpcXFxcXFxcXCgoXFxcIiArXFxuXFx0XFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcXG5cXHRcXHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcXG5cXHRcXHRcXFwiKCcoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwiKXxcXFwiICtcXG5cXHRcXHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcXG5cXHRcXHRcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIGF0dHJpYnV0ZXMgKyBcXFwiKSopfFxcXCIgK1xcblxcdFxcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcXG5cXHRcXHRcXFwiLipcXFwiICtcXG5cXHRcXHRcXFwiKVxcXFxcXFxcKXwpXFxcIixcXG5cXG5cXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXFxuXFx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXFxcIitcXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXHRydHJpbSA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiK3woKD86XnxbXlxcXFxcXFxcXFxcXFxcXFxdKSg/OlxcXFxcXFxcXFxcXFxcXFwuKSopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXG5cXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiosXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIgKSxcXG5cXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooWz4rfl18XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFwiICksXFxuXFxuXFx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFxcXCI9XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiICksXFxuXFxuXFx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcXG5cXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiJFxcXCIgKSxcXG5cXG5cXHRtYXRjaEV4cHIgPSB7XFxuXFx0XFx0XFxcIklEXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4jKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIilcXFwiICksXFxuXFx0XFx0XFxcIkNMQVNTXFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFxcXFxcXC4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKVxcXCIgKSxcXG5cXHRcXHRcXFwiVEFHXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwifFsqXSlcXFwiICksXFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBhdHRyaWJ1dGVzICksXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHBzZXVkb3MgKSxcXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXFxcXFwoXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcdFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OihbKy1dfClcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0XFx0XFxcIiooXFxcXFxcXFxkKyl8KSlcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFwpfClcXFwiLCBcXFwiaVxcXCIgKSxcXG5cXHRcXHRcXFwiYm9vbFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeKD86XFxcIiArIGJvb2xlYW5zICsgXFxcIikkXFxcIiwgXFxcImlcXFwiICksXFxuXFx0XFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXFxuXFx0XFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxcblxcdFxcdFxcXCJuZWVkc0NvbnRleHRcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFxcXFxcKFxcXCIgK1xcblxcdFxcdFxcdHdoaXRlc3BhY2UgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIgKVxcblxcdH0sXFxuXFxuXFx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuXFx0cmhlYWRlciA9IC9eaFxcXFxkJC9pLFxcblxcblxcdHJuYXRpdmUgPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuXFxuXFx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXFxuXFx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFxcXHctXSspfChcXFxcdyspfFxcXFwuKFtcXFxcdy1dKykpJC8sXFxuXFxuXFx0cnNpYmxpbmcgPSAvWyt+XS8sXFxuXFxuXFx0Ly8gQ1NTIGVzY2FwZXNcXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXFxuXFx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIj98KFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiICksXFxuXFx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xcblxcdFxcdHZhciBoaWdoID0gXFxcIjB4XFxcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xcblxcdFxcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XFxuXFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxcblxcdFxcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1xcXCIweFxcXCJcXG5cXHRcXHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XFxuXFx0XFx0XFx0ZXNjYXBlZCA6XFxuXFx0XFx0XFx0aGlnaCA8IDAgP1xcblxcdFxcdFxcdFxcdC8vIEJNUCBjb2RlcG9pbnRcXG5cXHRcXHRcXHRcXHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcXG5cXHRcXHRcXHRcXHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcXG5cXHRcXHRcXHRcXHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcXG5cXHR9LFxcblxcblxcdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXFxuXFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXFxuXFx0cmNzc2VzY2FwZSA9IC8oW1xcXFwwLVxcXFx4MWZcXFxceDdmXXxeLT9cXFxcZCl8Xi0kfFteXFxcXDAtXFxcXHgxZlxcXFx4N2YtXFxcXHVGRkZGXFxcXHctXS9nLFxcblxcdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xcblxcdFxcdGlmICggYXNDb2RlUG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXFxuXFx0XFx0XFx0aWYgKCBjaCA9PT0gXFxcIlxcXFwwXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gXFxcIlxcXFx1RkZGRFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXFxuXFx0XFx0XFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXFxcIlxcXFxcXFxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFxcXCIgXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxcblxcdFxcdHJldHVybiBcXFwiXFxcXFxcXFxcXFwiICsgY2g7XFxuXFx0fSxcXG5cXG5cXHQvLyBVc2VkIGZvciBpZnJhbWVzXFxuXFx0Ly8gU2VlIHNldERvY3VtZW50KClcXG5cXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcXFwiUGVybWlzc2lvbiBEZW5pZWRcXFwiXFxuXFx0Ly8gZXJyb3IgaW4gSUVcXG5cXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoKTtcXG5cXHR9LFxcblxcblxcdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcXFwiZm9ybVxcXCIgaW4gZWxlbSB8fCBcXFwibGFiZWxcXFwiIGluIGVsZW0pO1xcblxcdFxcdH0sXFxuXFx0XFx0eyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgbmV4dDogXFxcImxlZ2VuZFxcXCIgfVxcblxcdCk7XFxuXFxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcXG50cnkge1xcblxcdHB1c2guYXBwbHkoXFxuXFx0XFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxcblxcdFxcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXFxuXFx0KTtcXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxcblxcdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcXG5cXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xcbn0gY2F0Y2ggKCBlICkge1xcblxcdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cXG5cXG5cXHRcXHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxcblxcdFxcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcXG5cXHRcXHRcXHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTw5XFxuXFx0XFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxcblxcdFxcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcXG5cXHRcXHRcXHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXFxuXFx0XFx0XFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxcblxcdFxcdFxcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcXG5cXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3RvcixcXG5cXHRcXHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXFxuXFxuXFx0XFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxcblxcdFxcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xcblxcblxcdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XFxuXFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiIHx8ICFzZWxlY3RvciB8fFxcblxcdFxcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcXG5cXG5cXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHR9XFxuXFxuXFx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xcblxcdGlmICggIXNlZWQgKSB7XFxuXFxuXFx0XFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRcXHRzZXREb2N1bWVudCggY29udGV4dCApO1xcblxcdFxcdH1cXG5cXHRcXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xcblxcblxcdFxcdFxcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcXFwiZ2V0KkJ5KlxcXCIgRE9NIG1ldGhvZFxcblxcdFxcdFxcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcXG5cXHRcXHRcXHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElEIHNlbGVjdG9yXFxuXFx0XFx0XFx0XFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEb2N1bWVudCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRWxlbWVudCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5pZCA9PT0gbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFR5cGUgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xhc3Mgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcXG5cXHRcXHRcXHRpZiAoIHN1cHBvcnQucXNhICYmXFxuXFx0XFx0XFx0XFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF0gJiZcXG5cXHRcXHRcXHRcXHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcXG5cXHRcXHRcXHRcXHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OFxcblxcdFxcdFxcdFxcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxcblxcdFxcdFxcdFxcdFxcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcXFwiaWRcXFwiICkpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXFxcImlkXFxcIiwgKG5pZCA9IGV4cGFuZG8pICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxcblxcdFxcdFxcdFxcdFxcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xcblxcdFxcdFxcdFxcdFxcdGkgPSBncm91cHMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGdyb3Vwc1tpXSA9IFxcXCIjXFxcIiArIG5pZCArIFxcXCIgXFxcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcXFwiLFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcXG5cXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5ld1NlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcXG5cXHRcXHRcXHRcXHRcXHR9IGZpbmFsbHkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbmlkID09PSBleHBhbmRvICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcXFwiaWRcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQWxsIG90aGVyc1xcblxcdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcXFwiJDFcXFwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXFxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxcbiAqXFx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcXG4gKlxcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcXG5cXHR2YXIga2V5cyA9IFtdO1xcblxcblxcdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xcblxcdFxcdC8vIFVzZSAoa2V5ICsgXFxcIiBcXFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxcblxcdFxcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcXFwiIFxcXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XFxuXFx0XFx0XFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXFxuXFx0XFx0XFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXFxcIiBcXFwiIF0gPSB2YWx1ZSk7XFxuXFx0fVxcblxcdHJldHVybiBjYWNoZTtcXG59XFxuXFxuLyoqXFxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xcbiAqL1xcbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XFxuXFx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XFxuXFx0cmV0dXJuIGZuO1xcbn1cXG5cXG4vKipcXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcXG4gKi9cXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xcblxcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImZpZWxkc2V0XFxcIik7XFxuXFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gISFmbiggZWwgKTtcXG5cXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH0gZmluYWxseSB7XFxuXFx0XFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XFxuXFx0XFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XFxuXFx0XFx0fVxcblxcdFxcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXFxuXFx0XFx0ZWwgPSBudWxsO1xcblxcdH1cXG59XFxuXFxuLyoqXFxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcXG4gKi9cXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xcblxcdHZhciBhcnIgPSBhdHRycy5zcGxpdChcXFwifFxcXCIpLFxcblxcdFxcdGkgPSBhcnIubGVuZ3RoO1xcblxcblxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xcblxcdH1cXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxcbiAqL1xcbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcXG5cXHR2YXIgY3VyID0gYiAmJiBhLFxcblxcdFxcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XFxuXFxuXFx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXFxuXFx0aWYgKCBkaWZmICkge1xcblxcdFxcdHJldHVybiBkaWZmO1xcblxcdH1cXG5cXG5cXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxcblxcdGlmICggY3VyICkge1xcblxcdFxcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XFxuXFx0XFx0XFx0aWYgKCBjdXIgPT09IGIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBhID8gMSA6IC0xO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0cmV0dXJuIG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xcblxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRyZXR1cm4gKG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XFxuXFxuXFx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXFxuXFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxcblxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXFxuXFx0XFx0aWYgKCBcXFwiZm9ybVxcXCIgaW4gZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XFxuXFx0XFx0XFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcXG5cXHRcXHRcXHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcXG5cXHRcXHRcXHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXFxuXFx0XFx0XFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFxcXCJmb3JtXFxcIiBwcm9wZXJ0eS5cXG5cXHRcXHRcXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxcblxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcXG5cXHRcXHRcXHRcXHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcXG5cXHRcXHRcXHRcXHRcXHQvKiBqc2hpbnQgLVcwMTggKi9cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXG5cXHRcXHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXFxuXFx0XFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XFxuXFx0XFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXFxuXFx0XFx0fSBlbHNlIGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XFxuXFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XFxuXFx0XFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XFxuXFx0XFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcXG5cXHRcXHRcXHR2YXIgaixcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxcblxcdFxcdFxcdFxcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fSk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxcbiAqL1xcbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xcblxcdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb250ZXh0O1xcbn1cXG5cXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xcblxcbi8qKlxcbiAqIERldGVjdHMgWE1MIG5vZGVzXFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXFxuICovXFxuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XFxuXFx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXFxuXFx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XFxuXFx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXFxcIkhUTUxcXFwiIDogZmFsc2U7XFxufTtcXG5cXG4vKipcXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcXG4gKi9cXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xcblxcdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXFxuXFx0XFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xcblxcblxcdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXFxuXFx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcXG5cXHRcXHRyZXR1cm4gZG9jdW1lbnQ7XFxuXFx0fVxcblxcblxcdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXFxuXFx0ZG9jdW1lbnQgPSBkb2M7XFxuXFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXFxuXFx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcXFwicGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcXG5cXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcXG5cXHRcXHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxcblxcdFxcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XFxuXFx0XFx0XFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFxcXCJ1bmxvYWRcXFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XFxuXFx0XFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xcblxcdFxcdFxcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXFxcIm9udW5sb2FkXFxcIiwgdW5sb2FkSGFuZGxlciApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0LyogQXR0cmlidXRlc1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTw4XFxuXFx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXFxuXFx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXFxuXFx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRlbC5jbGFzc05hbWUgPSBcXFwiaVxcXCI7XFxuXFx0XFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzTmFtZVxcXCIpO1xcblxcdH0pO1xcblxcblxcdC8qIGdldEVsZW1lbnQocylCeSpcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcXG5cXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcXFwiXFxcIikgKTtcXG5cXHRcXHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCIqXFxcIikubGVuZ3RoO1xcblxcdH0pO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFPDlcXG5cXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTwxMFxcblxcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxcblxcdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxcblxcdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxcblxcdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XFxuXFx0XFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XFxuXFx0fSk7XFxuXFxuXFx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXFxuXFx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XFxuXFx0XFx0RXhwci5maWx0ZXJbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiggaWQgKSB7XFxuXFx0XFx0XFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKSA9PT0gYXR0cklkO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fTtcXG5cXHRcXHRFeHByLmZpbmRbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdEV4cHIuZmlsdGVyW1xcXCJJRFxcXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcXG5cXHRcXHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XFxuXFx0XFx0RXhwci5maW5kW1xcXCJJRFxcXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdFxcdHZhciBub2RlLCBpLCBlbGVtcyxcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcXG5cXHRcXHRcXHRcXHRcXHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWyBlbGVtIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFsgZWxlbSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gVGFnXFxuXFx0RXhwci5maW5kW1xcXCJUQUdcXFwiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xcblxcdFxcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xcblxcblxcdFxcdFxcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdFxcdHRtcCA9IFtdLFxcblxcdFxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdFxcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cXG5cXHRcXHRcXHRcXHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XFxuXFxuXFx0XFx0XFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xcblxcdFxcdFxcdGlmICggdGFnID09PSBcXFwiKlxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG1wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHR9O1xcblxcblxcdC8vIENsYXNzXFxuXFx0RXhwci5maW5kW1xcXCJDTEFTU1xcXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XFxuXFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcXG5cXG5cXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxcblxcdHJidWdneU1hdGNoZXMgPSBbXTtcXG5cXG5cXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxcblxcdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxcblxcdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcXG5cXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxcblxcdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcXG5cXHRyYnVnZ3lRU0EgPSBbXTtcXG5cXG5cXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcXG5cXHRcXHQvLyBCdWlsZCBRU0EgcmVnZXhcXG5cXHRcXHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXFxuXFx0XFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XFxuXFx0XFx0XFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXFxuXFx0XFx0XFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiJz48L2E+XFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIjxzZWxlY3QgaWQ9J1xcXCIgKyBleHBhbmRvICsgXFxcIi1cXFxcclxcXFxcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cXFwiO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcXG5cXHRcXHRcXHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XFxuXFx0XFx0XFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXFxcInNhZmVcXFwiIGZvciBXaW5SVFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiW21zYWxsb3djYXB0dXJlXj0nJ11cXFwiKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJbKl4kXT1cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86Jyd8XFxcXFxcXCJcXFxcXFxcIilcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOFxcblxcdFxcdFxcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXFxcInZhbHVlXFxcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcXFwiW3NlbGVjdGVkXVxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIlxcXFxcXFxcW1xcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzp2YWx1ZXxcXFwiICsgYm9vbGVhbnMgKyBcXFwiKVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXFxcIltpZH49XFxcIiArIGV4cGFuZG8gKyBcXFwiLV1cXFwiICkubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCJ+PVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXFxuXFx0XFx0XFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6Y2hlY2tlZFxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiOmNoZWNrZWRcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXFxuXFx0XFx0XFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJhI1xcXCIgKyBleHBhbmRvICsgXFxcIisqXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHRlbC5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXFxuXFx0XFx0XFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XFxuXFx0XFx0XFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtcXG5cXHRcXHRcXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIgKTtcXG5cXHRcXHRcXHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFxcXCJuYW1lXFxcIiwgXFxcIkRcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4XFxuXFx0XFx0XFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXFxuXFx0XFx0XFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIm5hbWVcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqWypeJHwhfl0/PVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcXG5cXHRcXHRcXHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiOmVuYWJsZWRcXFwiKS5sZW5ndGggIT09IDIgKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCI6ZW5hYmxlZFxcXCIsIFxcXCI6ZGlzYWJsZWRcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOS0xMStcXG5cXHRcXHRcXHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpkaXNhYmxlZFxcXCIpLmxlbmd0aCAhPT0gMiApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3NcXG5cXHRcXHRcXHRlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqLDp4XFxcIik7XFxuXFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIiwuKjpcXFwiKTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XFxuXFx0XFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcXG5cXHRcXHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xcblxcblxcdFxcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXFxuXFx0XFx0XFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcXG5cXHRcXHRcXHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXFxcIipcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxcblxcdFxcdFxcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcXG5cXHRcXHRcXHRtYXRjaGVzLmNhbGwoIGVsLCBcXFwiW3MhPScnXTp4XFxcIiApO1xcblxcdFxcdFxcdHJidWdneU1hdGNoZXMucHVzaCggXFxcIiE9XFxcIiwgcHNldWRvcyApO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXG5cXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFxcXCJ8XFxcIikgKTtcXG5cXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFxcXCJ8XFxcIikgKTtcXG5cXG5cXHQvKiBDb250YWluc1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XFxuXFxuXFx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXFxuXFx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXFxuXFx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcXG5cXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xcblxcdFxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcdFxcdFxcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXFxuXFx0XFx0XFx0XFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXFxuXFx0XFx0XFx0XFx0YWRvd24uY29udGFpbnMgP1xcblxcdFxcdFxcdFxcdFxcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XFxuXFx0XFx0XFx0XFx0XFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XFxuXFx0XFx0XFx0KSk7XFxuXFx0XFx0fSA6XFxuXFx0XFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0aWYgKCBiICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggYiA9PT0gYSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fTtcXG5cXG5cXHQvKiBTb3J0aW5nXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcXG5cXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cXG5cXHRmdW5jdGlvbiggYSwgYiApIHtcXG5cXG5cXHRcXHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxcblxcdFxcdGlmICggYSA9PT0gYiApIHtcXG5cXHRcXHRcXHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXFxuXFx0XFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xcblxcdFxcdGlmICggY29tcGFyZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY29tcGFyZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxcblxcdFxcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XFxuXFx0XFx0XFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcXG5cXHRcXHRcXHQxO1xcblxcblxcdFxcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xcblxcdFxcdGlmICggY29tcGFyZSAmIDEgfHxcXG5cXHRcXHRcXHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XFxuXFx0XFx0XFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxcblxcdFxcdFxcdHJldHVybiBzb3J0SW5wdXQgP1xcblxcdFxcdFxcdFxcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcXG5cXHRcXHRcXHRcXHQwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XFxuXFx0fSA6XFxuXFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxcblxcdFxcdGlmICggYSA9PT0gYiApIHtcXG5cXHRcXHRcXHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgY3VyLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGF1cCA9IGEucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRidXAgPSBiLnBhcmVudE5vZGUsXFxuXFx0XFx0XFx0YXAgPSBbIGEgXSxcXG5cXHRcXHRcXHRicCA9IFsgYiBdO1xcblxcblxcdFxcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXFxuXFx0XFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxcblxcdFxcdFxcdFxcdGIgPT09IGRvY3VtZW50ID8gMSA6XFxuXFx0XFx0XFx0XFx0YXVwID8gLTEgOlxcblxcdFxcdFxcdFxcdGJ1cCA/IDEgOlxcblxcdFxcdFxcdFxcdHNvcnRJbnB1dCA/XFxuXFx0XFx0XFx0XFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxcblxcdFxcdFxcdFxcdDA7XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcXG5cXHRcXHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXFxuXFx0XFx0Y3VyID0gYTtcXG5cXHRcXHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XFxuXFx0XFx0XFx0YXAudW5zaGlmdCggY3VyICk7XFxuXFx0XFx0fVxcblxcdFxcdGN1ciA9IGI7XFxuXFx0XFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xcblxcdFxcdFxcdGJwLnVuc2hpZnQoIGN1ciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxcblxcdFxcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xcblxcdFxcdFxcdGkrKztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGkgP1xcblxcdFxcdFxcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxcblxcdFxcdFxcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxcblxcdFxcdFxcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XFxuXFx0XFx0XFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxcblxcdFxcdFxcdDA7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gZG9jdW1lbnQ7XFxufTtcXG5cXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcXG5cXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xcbn07XFxuXFxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggZWxlbSApO1xcblxcdH1cXG5cXG5cXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcXG5cXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcXFwiPSckMSddXFxcIiApO1xcblxcblxcdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcXG5cXHRcXHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFxcXCIgXFxcIiBdICYmXFxuXFx0XFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxcblxcdFxcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcXG5cXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcXG5cXG5cXHRcXHRcXHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuXFx0XFx0XFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxcblxcdFxcdFxcdFxcdFxcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBjYXRjaCAoZSkge31cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcXG59O1xcblxcblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggY29udGV4dCApO1xcblxcdH1cXG5cXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcXG59O1xcblxcblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFx0fVxcblxcblxcdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXFxuXFx0XFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xcblxcdFxcdFxcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XFxuXFx0XFx0XFx0dW5kZWZpbmVkO1xcblxcblxcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0dmFsIDpcXG5cXHRcXHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cXG5cXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcXG5cXHRcXHRcXHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cXG5cXHRcXHRcXHRcXHR2YWwudmFsdWUgOlxcblxcdFxcdFxcdFxcdG51bGw7XFxufTtcXG5cXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcXG5cXHRyZXR1cm4gKHNlbCArIFxcXCJcXFwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XFxufTtcXG5cXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xcblxcdHRocm93IG5ldyBFcnJvciggXFxcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFxcXCIgKyBtc2cgKTtcXG59O1xcblxcbi8qKlxcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xcbiAqL1xcblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XFxuXFx0dmFyIGVsZW0sXFxuXFx0XFx0ZHVwbGljYXRlcyA9IFtdLFxcblxcdFxcdGogPSAwLFxcblxcdFxcdGkgPSAwO1xcblxcblxcdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcXG5cXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xcblxcdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xcblxcdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XFxuXFxuXFx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XFxuXFx0XFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XFxuXFx0XFx0XFx0XFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0d2hpbGUgKCBqLS0gKSB7XFxuXFx0XFx0XFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcXG5cXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcXG5cXHRzb3J0SW5wdXQgPSBudWxsO1xcblxcblxcdHJldHVybiByZXN1bHRzO1xcbn07XFxuXFxuLyoqXFxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cXG4gKi9cXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHR2YXIgbm9kZSxcXG5cXHRcXHRyZXQgPSBcXFwiXFxcIixcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0aWYgKCAhbm9kZVR5cGUgKSB7XFxuXFx0XFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcXG5cXHRcXHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcXG5cXHRcXHRcXHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xcblxcdFxcdFxcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XFxuXFx0XFx0fVxcblxcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcXG5cXHRcXHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXFxuXFx0XFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcXG5cXHRcXHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxcblxcdFxcdFxcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xcblxcdFxcdFxcdFxcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XFxuXFx0fVxcblxcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xcblxcblxcdHJldHVybiByZXQ7XFxufTtcXG5cXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcXG5cXG5cXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcXG5cXHRjYWNoZUxlbmd0aDogNTAsXFxuXFxuXFx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXFxuXFxuXFx0bWF0Y2g6IG1hdGNoRXhwcixcXG5cXG5cXHRhdHRySGFuZGxlOiB7fSxcXG5cXG5cXHRmaW5kOiB7fSxcXG5cXG5cXHRyZWxhdGl2ZToge1xcblxcdFxcdFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXFwiIFxcXCI6IHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIgfSxcXG5cXHRcXHRcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXFwiflxcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiB9XFxuXFx0fSxcXG5cXG5cXHRwcmVGaWx0ZXI6IHtcXG5cXHRcXHRcXFwiQVRUUlxcXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFxuXFx0XFx0XFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcXG5cXHRcXHRcXHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcblxcdFxcdFxcdGlmICggbWF0Y2hbMl0gPT09IFxcXCJ+PVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbM10gPSBcXFwiIFxcXCIgKyBtYXRjaFszXSArIFxcXCIgXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcXFwiQ0hJTERcXFwiXVxcblxcdFxcdFxcdFxcdDEgdHlwZSAob25seXxudGh8Li4uKVxcblxcdFxcdFxcdFxcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcXG5cXHRcXHRcXHRcXHQzIGFyZ3VtZW50IChldmVufG9kZHxcXFxcZCp8XFxcXGQqbihbKy1dXFxcXGQrKT98Li4uKVxcblxcdFxcdFxcdFxcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxcXGQqbnwpXFxuXFx0XFx0XFx0XFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxcblxcdFxcdFxcdFxcdDYgeCBvZiB4bi1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ4IHkgb2YgeS1jb21wb25lbnRcXG5cXHRcXHRcXHQqL1xcblxcdFxcdFxcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFxcXCJudGhcXFwiICkge1xcblxcdFxcdFxcdFxcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XFxuXFx0XFx0XFx0XFx0aWYgKCAhbWF0Y2hbM10gKSB7XFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcXG5cXHRcXHRcXHRcXHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXFxuXFx0XFx0XFx0XFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFxcXCJldmVuXFxcIiB8fCBtYXRjaFszXSA9PT0gXFxcIm9kZFxcXCIgKSApO1xcblxcdFxcdFxcdFxcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFxcXCJvZGRcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XFxuXFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2g7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiUFNFVURPXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdHZhciBleGNlc3MsXFxuXFx0XFx0XFx0XFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRjaEV4cHJbXFxcIkNISUxEXFxcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcXG5cXHRcXHRcXHRpZiAoIG1hdGNoWzNdICkge1xcblxcdFxcdFxcdFxcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcXG5cXHRcXHRcXHRcXHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxcblxcdFxcdFxcdFxcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcXG5cXHRcXHRcXHRcXHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcXG5cXHRcXHRcXHRcXHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXFxcIilcXFwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcXG5cXHRcXHRcXHRcXHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcXG5cXHRcXHRcXHRcXHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZmlsdGVyOiB7XFxuXFxuXFx0XFx0XFxcIlRBR1xcXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xcblxcdFxcdFxcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcXFwiKlxcXCIgP1xcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkNMQVNTXFxcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcXG5cXHRcXHRcXHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFxcXCIgXFxcIiBdO1xcblxcblxcdFxcdFxcdHJldHVybiBwYXR0ZXJuIHx8XFxuXFx0XFx0XFx0XFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcXFwiKF58XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyBjbGFzc05hbWUgKyBcXFwiKFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcInwkKVxcXCIgKSkgJiZcXG5cXHRcXHRcXHRcXHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRvciA9PT0gXFxcIiE9XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCAhb3BlcmF0b3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJlc3VsdCArPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0b3IgPT09IFxcXCI9XFxcIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiIT1cXFwiID8gcmVzdWx0ICE9PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJePVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCIqPVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIiQ9XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJ+PVxcXCIgPyAoIFxcXCIgXFxcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXFxcIiBcXFwiICkgKyBcXFwiIFxcXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwifD1cXFwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcXFwiLVxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdGZhbHNlO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xcblxcdFxcdFxcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFxcXCJudGhcXFwiLFxcblxcdFxcdFxcdFxcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcXFwibGFzdFxcXCIsXFxuXFx0XFx0XFx0XFx0b2ZUeXBlID0gd2hhdCA9PT0gXFxcIm9mLXR5cGVcXFwiO1xcblxcblxcdFxcdFxcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdFxcdH0gOlxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcXFwibmV4dFNpYmxpbmdcXFwiIDogXFxcInByZXZpb3VzU2libGluZ1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzaW1wbGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBkaXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9mVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXFxcIm9ubHlcXFwiICYmICFzdGFydCAmJiBcXFwibmV4dFNpYmxpbmdcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IHBhcmVudDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdXNlQ2FjaGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IG5vZGVJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggb2ZUeXBlID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCsrZGlmZiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB1c2VDYWNoZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiAtPSBsYXN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcXG5cXHRcXHRcXHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xcblxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcXG5cXHRcXHRcXHR2YXIgYXJncyxcXG5cXHRcXHRcXHRcXHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgcHNldWRvICk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxcblxcdFxcdFxcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXFxuXFx0XFx0XFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xcblxcdFxcdFxcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xcblxcdFxcdFxcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcXG5cXHRcXHRcXHRcXHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXFxcIlxcXCIsIGFyZ3VtZW50IF07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XFxuXFx0XFx0XFx0XFx0XFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpZHgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBtYXRjaGVkLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSkgOlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmbjtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRwc2V1ZG9zOiB7XFxuXFx0XFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXFxuXFx0XFx0XFxcIm5vdFxcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcXG5cXHRcXHRcXHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xcblxcdFxcdFxcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xcblxcdFxcdFxcdHZhciBpbnB1dCA9IFtdLFxcblxcdFxcdFxcdFxcdHJlc3VsdHMgPSBbXSxcXG5cXHRcXHRcXHRcXHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFxcXCIkMVxcXCIgKSApO1xcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xcblxcdFxcdFxcdFxcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpID0gc2VlZC5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pIDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdGlucHV0WzBdID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRcXHRcXHRpbnB1dFswXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImhhc1xcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJjb250YWluc1xcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcXG5cXHRcXHRcXHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0Ly8gXFxcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcXG5cXHRcXHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxcblxcdFxcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXFxuXFx0XFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcXFwiLVxcXCIuXFxuXFx0XFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXFxuXFx0XFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cXFwiXFxuXFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xcblxcdFxcdFxcXCJsYW5nXFxcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcXG5cXHRcXHRcXHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFxuXFx0XFx0XFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFxcXCJcXFwiKSApIHtcXG5cXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgbGFuZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtTGFuZztcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5sYW5nIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZShcXFwieG1sOmxhbmdcXFwiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcXFwibGFuZ1xcXCIpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcXFwiLVxcXCIgKSA9PT0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0Ly8gTWlzY2VsbGFuZW91c1xcblxcdFxcdFxcXCJ0YXJnZXRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcXG5cXHRcXHRcXHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwicm9vdFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImZvY3VzXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xcblxcdFxcdFxcXCJlbmFibGVkXFxcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXFxuXFx0XFx0XFxcImRpc2FibGVkXFxcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcXG5cXG5cXHRcXHRcXFwiY2hlY2tlZFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXFxuXFx0XFx0XFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiAobm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXFxcIm9wdGlvblxcXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJzZWxlY3RlZFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcXG5cXHRcXHRcXHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XFxuXFx0XFx0XFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQ29udGVudHNcXG5cXHRcXHRcXFwiZW1wdHlcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xcblxcdFxcdFxcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcXG5cXHRcXHRcXHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxcblxcdFxcdFxcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cXG5cXHRcXHRcXHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInBhcmVudFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAhRXhwci5wc2V1ZG9zW1xcXCJlbXB0eVxcXCJdKCBlbGVtICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXFxuXFx0XFx0XFxcImhlYWRlclxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJpbnB1dFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJidXR0b25cXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gbmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiBlbGVtLnR5cGUgPT09IFxcXCJidXR0b25cXFwiIHx8IG5hbWUgPT09IFxcXCJidXR0b25cXFwiO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInRleHRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cjtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiICYmXFxuXFx0XFx0XFx0XFx0ZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCIgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTw4XFxuXFx0XFx0XFx0XFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFxcXCJzZWFyY2hcXFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFxcXCJ0ZXh0XFxcIlxcblxcdFxcdFxcdFxcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXFxcInRleHRcXFwiICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXFxuXFx0XFx0XFxcImZpcnN0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyAwIF07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImxhc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImVxXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiZXZlblxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xcblxcdFxcdFxcdHZhciBpID0gMDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJvZGRcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDE7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwibHRcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xcblxcdFxcdFxcdGZvciAoIDsgLS1pID49IDA7ICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImd0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXHRcXHRcXHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KVxcblxcdH1cXG59O1xcblxcbkV4cHIucHNldWRvc1tcXFwibnRoXFxcIl0gPSBFeHByLnBzZXVkb3NbXFxcImVxXFxcIl07XFxuXFxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcXG5cXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XFxufVxcbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XFxuXFx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcXG59XFxuXFxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXFxuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XFxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XFxuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcXG5cXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xcblxcdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxcblxcdFxcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXFxuXFx0XFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcXFwiIFxcXCIgXTtcXG5cXG5cXHRpZiAoIGNhY2hlZCApIHtcXG5cXHRcXHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xcblxcdH1cXG5cXG5cXHRzb0ZhciA9IHNlbGVjdG9yO1xcblxcdGdyb3VwcyA9IFtdO1xcblxcdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcXG5cXG5cXHR3aGlsZSAoIHNvRmFyICkge1xcblxcblxcdFxcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cXG5cXHRcXHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcXG5cXHRcXHRcXHRpZiAoIG1hdGNoICkge1xcblxcdFxcdFxcdFxcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXFxuXFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdG1hdGNoZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyBDb21iaW5hdG9yc1xcblxcdFxcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xcblxcdFxcdFxcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xcblxcdFxcdFxcdHRva2Vucy5wdXNoKHtcXG5cXHRcXHRcXHRcXHR2YWx1ZTogbWF0Y2hlZCxcXG5cXHRcXHRcXHRcXHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcXG5cXHRcXHRcXHRcXHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXFxcIiBcXFwiIClcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGaWx0ZXJzXFxuXFx0XFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcXG5cXHRcXHRcXHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XFxuXFx0XFx0XFx0XFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XFxuXFx0XFx0XFx0XFx0dG9rZW5zLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiBtYXRjaGVkLFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlczogbWF0Y2hcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhbWF0Y2hlZCApIHtcXG5cXHRcXHRcXHRicmVhaztcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xcblxcdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xcblxcdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xcblxcdHJldHVybiBwYXJzZU9ubHkgP1xcblxcdFxcdHNvRmFyLmxlbmd0aCA6XFxuXFx0XFx0c29GYXIgP1xcblxcdFxcdFxcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XFxuXFx0XFx0XFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xcblxcdFxcdFxcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xcbn07XFxuXFxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxcblxcdFxcdHNlbGVjdG9yID0gXFxcIlxcXCI7XFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xcblxcdH1cXG5cXHRyZXR1cm4gc2VsZWN0b3I7XFxufVxcblxcbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XFxuXFx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxcblxcdFxcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXFxuXFx0XFx0a2V5ID0gc2tpcCB8fCBkaXIsXFxuXFx0XFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcXFwicGFyZW50Tm9kZVxcXCIsXFxuXFx0XFx0ZG9uZU5hbWUgPSBkb25lKys7XFxuXFxuXFx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xcblxcdFxcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSA6XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxcblxcdFxcdFxcdFxcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xcblxcblxcdFxcdFxcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xcblxcdFxcdFxcdGlmICggeG1sICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH07XFxufVxcblxcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcXG5cXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSA6XFxuXFx0XFx0bWF0Y2hlcnNbMF07XFxufVxcblxcbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XFxuXFx0fVxcblxcdHJldHVybiByZXN1bHRzO1xcbn1cXG5cXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xcblxcdHZhciBlbGVtLFxcblxcdFxcdG5ld1VubWF0Y2hlZCA9IFtdLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXFxuXFx0XFx0bWFwcGVkID0gbWFwICE9IG51bGw7XFxuXFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XFxuXFx0XFx0XFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRpZiAoIG1hcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXAucHVzaCggaSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XFxuXFx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcXG5cXHR9XFxuXFx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xcblxcdH1cXG5cXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0dmFyIHRlbXAsIGksIGVsZW0sXFxuXFx0XFx0XFx0cHJlTWFwID0gW10sXFxuXFx0XFx0XFx0cG9zdE1hcCA9IFtdLFxcblxcdFxcdFxcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXFxuXFxuXFx0XFx0XFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcXG5cXHRcXHRcXHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXFxcIipcXFwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxcblxcblxcdFxcdFxcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxcblxcdFxcdFxcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xcblxcdFxcdFxcdFxcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcXG5cXHRcXHRcXHRcXHRlbGVtcyxcXG5cXG5cXHRcXHRcXHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XFxuXFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcXG5cXHRcXHRcXHRcXHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0XFx0W10gOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdHMgOlxcblxcdFxcdFxcdFxcdG1hdGNoZXJJbjtcXG5cXG5cXHRcXHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xcblxcdFxcdGlmICggbWF0Y2hlciApIHtcXG5cXHRcXHRcXHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSBwb3N0RmlsdGVyXFxuXFx0XFx0aWYgKCBwb3N0RmlsdGVyICkge1xcblxcdFxcdFxcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xcblxcdFxcdFxcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcXG5cXG5cXHRcXHRcXHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXFxuXFx0XFx0XFx0aSA9IHRlbXAubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBzZWVkICkge1xcblxcdFxcdFxcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyICkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xcblxcdFxcdFxcdFxcdFxcdHRlbXAgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcXG5cXHRcXHRcXHRcXHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXRcXG5cXHRcXHRcXHQpO1xcblxcdFxcdFxcdGlmICggcG9zdEZpbmRlciApIHtcXG5cXHRcXHRcXHRcXHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xcblxcdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXFxuXFx0XFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxcblxcdFxcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcXFwiIFxcXCJdLFxcblxcdFxcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcXG5cXG5cXHRcXHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxcblxcdFxcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XFxuXFx0XFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxcblxcdFxcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xcblxcdFxcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcXG5cXHRcXHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcXG5cXHRcXHRcXHRcXHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxcblxcdFxcdFxcdFxcdFxcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcXG5cXHRcXHRcXHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRjaGVja0NvbnRleHQgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fSBdO1xcblxcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcXG5cXHRcXHRcXHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxcblxcdFxcdFxcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xcblxcdFxcdFxcdFxcdGogPSArK2k7XFxuXFx0XFx0XFx0XFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNldE1hdGNoZXIoXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxcblxcdFxcdFxcdFxcdFxcdFxcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFxcXCIgXFxcIiA/IFxcXCIqXFxcIiA6IFxcXCJcXFwiIH0pXFxuXFx0XFx0XFx0XFx0XFx0KS5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApLFxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXIsXFxuXFx0XFx0XFx0XFx0XFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXFxuXFx0XFx0XFx0XFx0XFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxcblxcdFxcdFxcdFxcdFxcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XFxufVxcblxcbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcXG5cXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxcblxcdFxcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxcblxcdFxcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcXG5cXHRcXHRcXHRcXHRtYXRjaGVkQ291bnQgPSAwLFxcblxcdFxcdFxcdFxcdGkgPSBcXFwiMFxcXCIsXFxuXFx0XFx0XFx0XFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcXG5cXHRcXHRcXHRcXHRzZXRNYXRjaGVkID0gW10sXFxuXFx0XFx0XFx0XFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXFxuXFx0XFx0XFx0XFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxcblxcdFxcdFxcdFxcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1xcXCJUQUdcXFwiXSggXFxcIipcXFwiLCBvdXRlcm1vc3QgKSxcXG5cXHRcXHRcXHRcXHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxcblxcdFxcdFxcdFxcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxcblxcdFxcdFxcdFxcdGxlbiA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXFxuXFx0XFx0XFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFxcXCJsZW5ndGhcXFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxcblxcdFxcdFxcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdFxcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXREb2N1bWVudCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcXG5cXHRcXHRcXHRcXHRpZiAoIGJ5U2V0ICkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZENvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXFxuXFx0XFx0XFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cXG5cXHRcXHRcXHRtYXRjaGVkQ291bnQgKz0gaTtcXG5cXG5cXHRcXHRcXHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcXG5cXHRcXHRcXHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXFxuXFx0XFx0XFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXFxuXFx0XFx0XFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cXG5cXHRcXHRcXHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcXFwiMFxcXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxcblxcdFxcdFxcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXFxcIjAwXFxcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cXG5cXHRcXHRcXHQvLyBudW1lcmljYWxseSB6ZXJvLlxcblxcdFxcdFxcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xcblxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXFxuXFx0XFx0XFx0XFx0XFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcXG5cXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXFxuXFx0XFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXFxuXFx0XFx0XFx0XFx0XFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xcblxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICkge1xcblxcdFxcdFxcdFxcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xcblxcdFxcdFxcdFxcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdW5tYXRjaGVkO1xcblxcdFxcdH07XFxuXFxuXFx0cmV0dXJuIGJ5U2V0ID9cXG5cXHRcXHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcXG5cXHRcXHRzdXBlck1hdGNoZXI7XFxufVxcblxcbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XFxuXFx0dmFyIGksXFxuXFx0XFx0c2V0TWF0Y2hlcnMgPSBbXSxcXG5cXHRcXHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcXG5cXHRcXHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFxcXCIgXFxcIiBdO1xcblxcblxcdGlmICggIWNhY2hlZCApIHtcXG5cXHRcXHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcXG5cXHRcXHRpZiAoICFtYXRjaCApIHtcXG5cXHRcXHRcXHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xcblxcdFxcdH1cXG5cXHRcXHRpID0gbWF0Y2gubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xcblxcdFxcdFxcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0XFx0XFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cXG5cXHRcXHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcXG5cXG5cXHRcXHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cXG5cXHRcXHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcXG5cXHR9XFxuXFx0cmV0dXJuIGNhY2hlZDtcXG59O1xcblxcbi8qKlxcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XFxuICovXFxuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcXG5cXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcXG5cXHRcXHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzZWxlY3RvcixcXG5cXHRcXHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcXG5cXG5cXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxcblxcdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcXG5cXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcXG5cXG5cXHRcXHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxcblxcdFxcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcXG5cXHRcXHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXFxcIklEXFxcIiAmJlxcblxcdFxcdFxcdFxcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcXG5cXG5cXHRcXHRcXHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXFxcIklEXFxcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xcblxcdFxcdFxcdGlmICggIWNvbnRleHQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xcblxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXFxuXFx0XFx0aSA9IG1hdGNoRXhwcltcXFwibmVlZHNDb250ZXh0XFxcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdHRva2VuID0gdG9rZW5zW2ldO1xcblxcblxcdFxcdFxcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcXG5cXHRcXHRcXHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcXG5cXHRcXHRcXHRcXHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcXG5cXHRcXHRcXHRcXHRpZiAoIChzZWVkID0gZmluZChcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXFxuXFx0XFx0XFx0XFx0XFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxcblxcdFxcdFxcdFxcdCkpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxcblxcdFxcdFxcdFxcdFxcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggIXNlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxcblxcdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcXG5cXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXFxuXFx0XFx0c2VlZCxcXG5cXHRcXHRjb250ZXh0LFxcblxcdFxcdCFkb2N1bWVudElzSFRNTCxcXG5cXHRcXHRyZXN1bHRzLFxcblxcdFxcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcXG5cXHQpO1xcblxcdHJldHVybiByZXN1bHRzO1xcbn07XFxuXFxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcXG5cXG4vLyBTb3J0IHN0YWJpbGl0eVxcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXFxcIlxcXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXFxcIlxcXCIpID09PSBleHBhbmRvO1xcblxcbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXFxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XFxuXFxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XFxuc2V0RG9jdW1lbnQoKTtcXG5cXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcXG5cXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImZpZWxkc2V0XFxcIikgKSAmIDE7XFxufSk7XFxuXFxuLy8gU3VwcG9ydDogSUU8OFxcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFxcXCJpbnRlcnBvbGF0aW9uXFxcIlxcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRlbC5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nIyc+PC9hPlxcXCI7XFxuXFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikgPT09IFxcXCIjXFxcIiA7XFxufSkgKSB7XFxuXFx0YWRkSGFuZGxlKCBcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcInR5cGVcXFwiID8gMSA6IDIgKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbi8vIFN1cHBvcnQ6IElFPDlcXG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKVxcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRlbC5pbm5lckhUTUwgPSBcXFwiPGlucHV0Lz5cXFwiO1xcblxcdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiLCBcXFwiXFxcIiApO1xcblxcdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXFxcInZhbHVlXFxcIiApID09PSBcXFwiXFxcIjtcXG59KSApIHtcXG5cXHRhZGRIYW5kbGUoIFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xcblxcdFxcdH1cXG5cXHR9KTtcXG59XFxuXFxuLy8gU3VwcG9ydDogSUU8OVxcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIikgPT0gbnVsbDtcXG59KSApIHtcXG5cXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0dmFyIHZhbDtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcXG5cXHRcXHRcXHRcXHRcXHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xcblxcdFxcdFxcdFxcdFxcdHZhbC52YWx1ZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbnJldHVybiBTaXp6bGU7XFxuXFxufSkoIHdpbmRvdyApO1xcblxcblxcblxcbmpRdWVyeS5maW5kID0gU2l6emxlO1xcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcXG5cXG4vLyBEZXByZWNhdGVkXFxualF1ZXJ5LmV4cHJbIFxcXCI6XFxcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcXG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcXG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcXG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XFxualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcXG5cXG5cXG5cXG5cXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XFxuXFx0dmFyIG1hdGNoZWQgPSBbXSxcXG5cXHRcXHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XFxuXFxuXFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XFxuXFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hdGNoZWQucHVzaCggZWxlbSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIG1hdGNoZWQ7XFxufTtcXG5cXG5cXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcXG5cXHR2YXIgbWF0Y2hlZCA9IFtdO1xcblxcblxcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XFxuXFx0XFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0bWF0Y2hlZC5wdXNoKCBuICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gbWF0Y2hlZDtcXG59O1xcblxcblxcbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xcblxcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcXFwvXFxcXDA+OlxcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0qKVtcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvaSApO1xcblxcblxcblxcbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxcXFtcXFxcLixdKiQvO1xcblxcbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XFxuXFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gU2luZ2xlIGVsZW1lbnRcXG5cXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXFxuXFx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gU2ltcGxlIHNlbGVjdG9yIHRoYXQgY2FuIGJlIGZpbHRlcmVkIGRpcmVjdGx5LCByZW1vdmluZyBub24tRWxlbWVudHNcXG5cXHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XFxuXFx0fVxcblxcblxcdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcXG5cXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XFxuXFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xcblxcdH0gKTtcXG59XFxuXFxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xcblxcdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcXG5cXG5cXHRpZiAoIG5vdCApIHtcXG5cXHRcXHRleHByID0gXFxcIjpub3QoXFxcIiArIGV4cHIgKyBcXFwiKVxcXCI7XFxuXFx0fVxcblxcblxcdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XFxuXFx0fSApICk7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBpLCByZXQsXFxuXFx0XFx0XFx0bGVuID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0c2VsZiA9IHRoaXM7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xcblxcdH0sXFxuXFx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XFxuXFx0fSxcXG5cXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xcblxcdH0sXFxuXFx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gISF3aW5ub3coXFxuXFx0XFx0XFx0dGhpcyxcXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XFxuXFx0XFx0XFx0Ly8gc28gJChcXFwicDpmaXJzdFxcXCIpLmlzKFxcXCJwOmxhc3RcXFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXFxcInBcXFwiLlxcblxcdFxcdFxcdHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHNlbGVjdG9yICkgOlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yIHx8IFtdLFxcblxcdFxcdFxcdGZhbHNlXFxuXFx0XFx0KS5sZW5ndGg7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxcblxcblxcbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxcbnZhciByb290alF1ZXJ5LFxcblxcblxcdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXFxuXFx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxcblxcdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxcblxcdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcXG5cXHRycXVpY2tFeHByID0gL14oPzpcXFxccyooPFtcXFxcd1xcXFxXXSs+KVtePl0qfCMoW1xcXFx3LV0rKSkkLyxcXG5cXG5cXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XFxuXFx0XFx0dmFyIG1hdGNoLCBlbGVtO1xcblxcblxcdFxcdC8vIEhBTkRMRTogJChcXFwiXFxcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcXG5cXHRcXHRpZiAoICFzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XFxuXFx0XFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxcblxcdFxcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFxcXCI8XFxcIiAmJlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFxcXCI+XFxcIiAmJlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXFxuXFx0XFx0XFx0XFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxcblxcdFxcdFxcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRjaFsgMSBdICkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcXG5cXHRcXHRcXHRcXHRcXHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaFsgMSBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ1ZVxcblxcdFxcdFxcdFxcdFxcdCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJCgjaWQpXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyAwIF0gPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcXG5cXHRcXHRcXHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXFxuXFx0XFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0dGhpcy5sZW5ndGggPSAxO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcXG5cXHRcXHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcXG5cXHRcXHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0c2VsZWN0b3IoIGpRdWVyeSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcXG5cXHR9O1xcblxcbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcXG5cXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXFxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcXG5cXG5cXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuXFxuXFx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcXG5cXHRndWFyYW50ZWVkVW5pcXVlID0ge1xcblxcdFxcdGNoaWxkcmVuOiB0cnVlLFxcblxcdFxcdGNvbnRlbnRzOiB0cnVlLFxcblxcdFxcdG5leHQ6IHRydWUsXFxuXFx0XFx0cHJldjogdHJ1ZVxcblxcdH07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcXG5cXHRcXHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXFxuXFx0XFx0XFx0bCA9IHRhcmdldHMubGVuZ3RoO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xcblxcdFxcdHZhciBjdXIsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0bCA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdG1hdGNoZWQgPSBbXSxcXG5cXHRcXHRcXHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXFxcInN0cmluZ1xcXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcXG5cXG5cXHRcXHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XFxuXFx0XFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XFxuXFx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XFxuXFx0XFx0aWYgKCAhZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEluZGV4IGluIHNlbGVjdG9yXFxuXFx0XFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcXG5cXHRcXHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxcblxcblxcdFxcdFxcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxcblxcdFxcdFxcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxcblxcdFxcdCk7XFxuXFx0fSxcXG5cXG5cXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXFxuXFx0XFx0XFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxcblxcdFxcdFxcdClcXG5cXHRcXHQpO1xcblxcdH0sXFxuXFxuXFx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XFxuXFx0XFx0XFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxcblxcdFxcdCk7XFxuXFx0fVxcbn0gKTtcXG5cXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcXG5cXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XFxuXFx0cmV0dXJuIGN1cjtcXG59XFxuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcXG5cXHR9LFxcblxcdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwYXJlbnROb2RlXFxcIiApO1xcblxcdH0sXFxuXFx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInBhcmVudE5vZGVcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIsIHVudGlsICk7XFxuXFx0fSxcXG5cXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgdW50aWwgKTtcXG5cXHR9LFxcblxcdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xcblxcdH0sXFxuXFx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XFxuXFx0fSxcXG5cXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xcblxcdH1cXG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XFxuXFxuXFx0XFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcXFwiVW50aWxcXFwiICkge1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW50aWw7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcXG5cXHRcXHRcXHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcXG5cXHRcXHRcXHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlZC5yZXZlcnNlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcXG5cXHR9O1xcbn0gKTtcXG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSsvZyApO1xcblxcblxcblxcbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXFxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcXG5cXHR2YXIgb2JqZWN0ID0ge307XFxuXFx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XFxuXFx0XFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xcblxcdH0gKTtcXG5cXHRyZXR1cm4gb2JqZWN0O1xcbn1cXG5cXG4vKlxcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxcbiAqXFxuICpcXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XFxuICpcXHRcXHRcXHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XFxuICpcXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxcbiAqIFxcXCJmaXJlZFxcXCIgbXVsdGlwbGUgdGltZXMuXFxuICpcXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxcbiAqXFxuICpcXHRvbmNlOlxcdFxcdFxcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcXG4gKlxcbiAqXFx0bWVtb3J5OlxcdFxcdFxcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcXG4gKlxcdFxcdFxcdFxcdFxcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFxcXCJtZW1vcml6ZWRcXFwiXFxuICpcXHRcXHRcXHRcXHRcXHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcXG4gKlxcbiAqXFx0dW5pcXVlOlxcdFxcdFxcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxcbiAqXFxuICpcXHRzdG9wT25GYWxzZTpcXHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcXG4gKlxcbiAqL1xcbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXG5cXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXFxuXFx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxcblxcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcInN0cmluZ1xcXCIgP1xcblxcdFxcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcXG5cXG5cXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xcblxcdFxcdGZpcmluZyxcXG5cXG5cXHRcXHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xcblxcdFxcdG1lbW9yeSxcXG5cXG5cXHRcXHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxcblxcdFxcdGZpcmVkLFxcblxcblxcdFxcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcXG5cXHRcXHRsb2NrZWQsXFxuXFxuXFx0XFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcXG5cXHRcXHRsaXN0ID0gW10sXFxuXFxuXFx0XFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcXG5cXHRcXHRxdWV1ZSA9IFtdLFxcblxcblxcdFxcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxcblxcdFxcdGZpcmluZ0luZGV4ID0gLTEsXFxuXFxuXFx0XFx0Ly8gRmlyZSBjYWxsYmFja3NcXG5cXHRcXHRmaXJlID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXFxuXFx0XFx0XFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xcblxcblxcdFxcdFxcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxcblxcdFxcdFxcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcXG5cXHRcXHRcXHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XFxuXFx0XFx0XFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtZW1vcnkgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XFxuXFx0XFx0XFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZpcmluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXFxuXFx0XFx0XFx0aWYgKCBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xcblxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XFxuXFx0XFx0c2VsZiA9IHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XFxuXFx0XFx0XFx0YWRkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxpc3QucHVzaCggYXJnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFkZCggYXJnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9ICkoIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4LS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxcblxcdFxcdFxcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxcblxcdFxcdFxcdGhhczogZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmbiA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0bGlzdC5sZW5ndGggPiAwO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxcblxcdFxcdFxcdGVtcHR5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IFtdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcXG5cXHRcXHRcXHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcXG5cXHRcXHRcXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xcblxcdFxcdFxcdFxcdGxpc3QgPSBtZW1vcnkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWxpc3Q7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBEaXNhYmxlIC5maXJlXFxuXFx0XFx0XFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXFxuXFx0XFx0XFx0bG9jazogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0bG9ja2VkID0gcXVldWUgPSBbXTtcXG5cXHRcXHRcXHRcXHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gbWVtb3J5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISFsb2NrZWQ7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXFxuXFx0XFx0XFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xcblxcdFxcdFxcdFxcdGlmICggIWxvY2tlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gYXJncyB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXFxuXFx0XFx0XFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIWZpcmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdHJldHVybiBzZWxmO1xcbn07XFxuXFxuXFxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XFxuXFx0cmV0dXJuIHY7XFxufVxcbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xcblxcdHRocm93IGV4O1xcbn1cXG5cXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICkge1xcblxcdHZhciBtZXRob2Q7XFxuXFxuXFx0dHJ5IHtcXG5cXG5cXHRcXHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXFxuXFx0XFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcXG5cXHRcXHRcXHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XFxuXFxuXFx0XFx0Ly8gT3RoZXIgdGhlbmFibGVzXFxuXFx0XFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XFxuXFx0XFx0XFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcXG5cXG5cXHRcXHQvLyBPdGhlciBub24tdGhlbmFibGVzXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XFxuXFx0XFx0XFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxcblxcdFxcdFxcdHJlc29sdmUuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcXG5cXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXFxuXFx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cXG5cXHR9IGNhdGNoICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxcblxcdFxcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcXG5cXHRcXHRyZWplY3QuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xcblxcdH1cXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcXG5cXHRcXHR2YXIgdHVwbGVzID0gW1xcblxcblxcdFxcdFxcdFxcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXFxuXFx0XFx0XFx0XFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxcblxcdFxcdFxcdFxcdFsgXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJtZW1vcnlcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkNhbGxiYWNrcyggXFxcIm1lbW9yeVxcXCIgKSwgMiBdLFxcblxcdFxcdFxcdFxcdFsgXFxcInJlc29sdmVcXFwiLCBcXFwiZG9uZVxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDAsIFxcXCJyZXNvbHZlZFxcXCIgXSxcXG5cXHRcXHRcXHRcXHRbIFxcXCJyZWplY3RcXFwiLCBcXFwiZmFpbFxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDEsIFxcXCJyZWplY3RlZFxcXCIgXVxcblxcdFxcdFxcdF0sXFxuXFx0XFx0XFx0c3RhdGUgPSBcXFwicGVuZGluZ1xcXCIsXFxuXFx0XFx0XFx0cHJvbWlzZSA9IHtcXG5cXHRcXHRcXHRcXHRzdGF0ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHN0YXRlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxcblxcdFxcdFxcdFxcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZm5zID0gYXJndW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLnByb21pc2UoKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcXFwiV2l0aFxcXCIgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmbnMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH0gKS5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1heERlcHRoID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhcmdzID0gYXJndW1lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQsIHRoZW47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcXFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4gPSByZXR1cm5lZCAmJlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggdHlwZW9mIHJldHVybmVkID09PSBcXFwib2JqZWN0XFxcIiB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGVvZiByZXR1cm5lZCA9PT0gXFxcImZ1bmN0aW9uXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQudGhlbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzcGVjaWFsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4uY2FsbChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1heERlcHRoKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhlbi5jYWxsKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBbIHJldHVybmVkIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3MgPSBzcGVjaWFsID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaWdodFRocm93IDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pZ2h0VGhyb3coKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJncyA9IFsgZSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3MoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uUHJvZ3Jlc3MgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdElkZW50aXR5LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLm5vdGlmeVdpdGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b25GdWxmaWxsZWQgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdElkZW50aXR5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvblJlamVjdGVkIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRUaHJvd2VyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0fSApLnByb21pc2UoKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcXG5cXHRcXHRcXHRcXHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XFxuXFx0XFx0XFx0XFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGVmZXJyZWQgPSB7fTtcXG5cXG5cXHRcXHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXFxuXFx0XFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xcblxcdFxcdFxcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcXG5cXHRcXHRcXHRcXHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XFxuXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcXG5cXHRcXHRcXHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxcblxcdFxcdFxcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xcblxcblxcdFxcdFxcdC8vIEhhbmRsZSBzdGF0ZVxcblxcdFxcdFxcdGlmICggc3RhdGVTdHJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0bGlzdC5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3RhdGUgPSBcXFwicmVzb2x2ZWRcXFwiIChpLmUuLCBmdWxmaWxsZWQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3RhdGUgPSBcXFwicmVqZWN0ZWRcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcXG5cXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcXG5cXHRcXHRcXHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XFxuXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cXG5cXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcXFwiV2l0aFxcXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdID0gbGlzdC5maXJlV2l0aDtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXFxuXFx0XFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xcblxcblxcdFxcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcXG5cXHRcXHRpZiAoIGZ1bmMgKSB7XFxuXFx0XFx0XFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWxsIGRvbmUhXFxuXFx0XFx0cmV0dXJuIGRlZmVycmVkO1xcblxcdH0sXFxuXFxuXFx0Ly8gRGVmZXJyZWQgaGVscGVyXFxuXFx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xcblxcdFxcdHZhclxcblxcblxcdFxcdFxcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xcblxcdFxcdFxcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXFxuXFxuXFx0XFx0XFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXFxuXFx0XFx0XFx0aSA9IHJlbWFpbmluZyxcXG5cXG5cXHRcXHRcXHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXFxuXFx0XFx0XFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcXG5cXHRcXHRcXHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXFxuXFxuXFx0XFx0XFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxcblxcdFxcdFxcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcblxcdFxcdFxcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3RvcnlcXG5cXHRcXHRcXHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXFxuXFx0XFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcXG5cXHRcXHRcXHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QgKTtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXFxuXFx0XFx0XFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXFxcInBlbmRpbmdcXFwiIHx8XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXN0ZXIudGhlbigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcXG5cXHR9XFxufSApO1xcblxcblxcbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxcbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xcblxcbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XFxuXFx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcXG5cXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xcblxcdFxcdHdpbmRvdy5jb25zb2xlLndhcm4oIFxcXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcXFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XFxuXFx0fVxcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aHJvdyBlcnJvcjtcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcXG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XFxuXFxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xcblxcblxcdHJlYWR5TGlzdFxcblxcdFxcdC50aGVuKCBmbiApXFxuXFxuXFx0XFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcXG5cXHRcXHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcXG5cXHRcXHQvLyByZWdpc3RyYXRpb24uXFxuXFx0XFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxcblxcdGlzUmVhZHk6IGZhbHNlLFxcblxcblxcdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcXG5cXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxcblxcdHJlYWR5V2FpdDogMSxcXG5cXG5cXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcXG5cXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xcblxcdFxcdGlmICggaG9sZCApIHtcXG5cXHRcXHRcXHRqUXVlcnkucmVhZHlXYWl0Kys7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRqUXVlcnkucmVhZHkoIHRydWUgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xcblxcblxcdFxcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcXG5cXHRcXHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxcblxcdFxcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcXG5cXG5cXHRcXHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxcblxcdFxcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxcblxcdFxcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XFxuXFxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XFxuXFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHRqUXVlcnkucmVhZHkoKTtcXG59XFxuXFxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XFxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXFxcImludGVyYWN0aXZlXFxcIiB0b28gc29vblxcbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXFxcImNvbXBsZXRlXFxcIiB8fFxcblxcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXFxcImxvYWRpbmdcXFwiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcXG5cXG5cXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcXG5cXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XFxuXFxufSBlbHNlIHtcXG5cXG5cXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXFxuXFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXG5cXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xcblxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcXFwibG9hZFxcXCIsIGNvbXBsZXRlZCApO1xcbn1cXG5cXG5cXG5cXG5cXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0YnVsayA9IGtleSA9PSBudWxsO1xcblxcblxcdC8vIFNldHMgbWFueSB2YWx1ZXNcXG5cXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0Y2hhaW5hYmxlID0gdHJ1ZTtcXG5cXHRcXHRmb3IgKCBpIGluIGtleSApIHtcXG5cXHRcXHRcXHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcXG5cXHRcXHR9XFxuXFxuXFx0Ly8gU2V0cyBvbmUgdmFsdWVcXG5cXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdGNoYWluYWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmF3ID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBidWxrICkge1xcblxcblxcdFxcdFxcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxcblxcdFxcdFxcdGlmICggcmF3ICkge1xcblxcdFxcdFxcdFxcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdGZuID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRidWxrID0gZm47XFxuXFx0XFx0XFx0XFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBmbiApIHtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRmbihcXG5cXHRcXHRcXHRcXHRcXHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgOlxcblxcdFxcdFxcdFxcdFxcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoIGNoYWluYWJsZSApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbXM7XFxuXFx0fVxcblxcblxcdC8vIEdldHNcXG5cXHRpZiAoIGJ1bGsgKSB7XFxuXFx0XFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcXG59O1xcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xcblxcblxcdC8vIEFjY2VwdHMgb25seTpcXG5cXHQvLyAgLSBOb2RlXFxuXFx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxcblxcdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXFxuXFx0Ly8gIC0gT2JqZWN0XFxuXFx0Ly8gICAgLSBBbnlcXG5cXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XFxufTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBEYXRhKCkge1xcblxcdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcXG59XFxuXFxuRGF0YS51aWQgPSAxO1xcblxcbkRhdGEucHJvdG90eXBlID0ge1xcblxcblxcdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXFxuXFx0XFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcblxcdFxcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxcblxcdFxcdGlmICggIXZhbHVlICkge1xcblxcdFxcdFxcdHZhbHVlID0ge307XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXFxuXFx0XFx0XFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cXG5cXHRcXHRcXHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cXG5cXHRcXHRcXHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxcblxcdFxcdFxcdFxcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XFxuXFx0XFx0XFx0XFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcXG5cXHRcXHRcXHRcXHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxcblxcdFxcdFxcdFxcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlOiB2YWx1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWVcXG5cXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdH0sXFxuXFx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xcblxcdFxcdHZhciBwcm9wLFxcblxcdFxcdFxcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcXG5cXG5cXHRcXHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXFxuXFx0XFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxcblxcdFxcdGlmICggdHlwZW9mIGRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xcblxcblxcdFxcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxcblxcdFxcdFxcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gY2FjaGU7XFxuXFx0fSxcXG5cXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xcblxcdFxcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XFxuXFxuXFx0XFx0XFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxcblxcdFxcdFxcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XFxuXFx0fSxcXG5cXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXFxuXFx0XFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyBUYWtlIHRoZSBcXFwicmVhZFxcXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXFxuXFx0XFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxcblxcdFxcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcXG5cXHRcXHQvL1xcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcXG5cXHRcXHRcXHRcXHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFxcXCJzdHJpbmdcXFwiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxcblxcdFxcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xcblxcdFxcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXFxuXFx0XFx0Ly9cXG5cXHRcXHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcXG5cXG5cXHRcXHQvLyBTaW5jZSB0aGUgXFxcInNldFxcXCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXFxuXFx0XFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXFxuXFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcXG5cXHR9LFxcblxcdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XFxuXFxuXFx0XFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xcblxcdFxcdFxcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXFxuXFx0XFx0XFx0XFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXFxuXFx0XFx0XFx0XFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0a2V5ID0ga2V5IGluIGNhY2hlID9cXG5cXHRcXHRcXHRcXHRcXHRbIGtleSBdIDpcXG5cXHRcXHRcXHRcXHRcXHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGkgPSBrZXkubGVuZ3RoO1xcblxcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxcblxcdFxcdFxcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXFxuXFx0XFx0XFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XFxuXFx0XFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcdFxcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcXG5cXHR9XFxufTtcXG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xcblxcbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XFxuXFxuXFxuXFxuLy9cXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XFxuLy9cXG4vL1xcdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcXG4vL1xcdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxcbi8vXFx0XFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxcbi8vXFx0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcXFwicHJpdmF0ZVxcXCIgYW5kIFxcXCJ1c2VyXFxcIiBkYXRhLlxcbi8vXFx0NC4gX05ldmVyXyBleHBvc2UgXFxcInByaXZhdGVcXFwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcXG4vL1xcdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxcbi8vXFx0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XFxuXFxudmFyIHJicmFjZSA9IC9eKD86XFxcXHtbXFxcXHdcXFxcV10qXFxcXH18XFxcXFtbXFxcXHdcXFxcV10qXFxcXF0pJC8sXFxuXFx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xcblxcbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XFxuXFx0aWYgKCBkYXRhID09PSBcXFwidHJ1ZVxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fVxcblxcblxcdGlmICggZGF0YSA9PT0gXFxcImZhbHNlXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcblxcblxcdGlmICggZGF0YSA9PT0gXFxcIm51bGxcXFwiICkge1xcblxcdFxcdHJldHVybiBudWxsO1xcblxcdH1cXG5cXG5cXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xcblxcdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcXFwiXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gK2RhdGE7XFxuXFx0fVxcblxcblxcdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcXG5cXHRcXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZGF0YTtcXG59XFxuXFxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcXG5cXHR2YXIgbmFtZTtcXG5cXG5cXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XFxuXFx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXFxuXFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRuYW1lID0gXFxcImRhdGEtXFxcIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcXFwiLSQmXFxcIiApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xcblxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge31cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcXG5cXHRcXHRcXHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBkYXRhO1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XFxuXFx0fSxcXG5cXG5cXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcXG5cXHRcXHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcXG5cXHRcXHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcXG5cXHR9LFxcblxcblxcdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXFxuXFx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXFxuXFx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xcblxcdFxcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcXG5cXHR9LFxcblxcblxcdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcXG5cXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgaSwgbmFtZSwgZGF0YSxcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdLFxcblxcdFxcdFxcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0Ly8gR2V0cyBhbGwgdmFsdWVzXFxuXFx0XFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXFxcImhhc0RhdGFBdHRyc1xcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpID0gYXR0cnMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGF0dHJzWyBpIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5hbWUuaW5kZXhPZiggXFxcImRhdGEtXFxcIiApID09PSAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXFxuXFx0XFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBkYXRhO1xcblxcblxcdFxcdFxcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XFxuXFx0XFx0XFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcXG5cXHRcXHRcXHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcXG5cXHRcXHRcXHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxcblxcdFxcdFxcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcXG5cXHRcXHRcXHRcXHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBdHRlbXB0IHRvIFxcXCJkaXNjb3ZlclxcXCIgdGhlIGRhdGEgaW5cXG5cXHRcXHRcXHRcXHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBkYXRhLi4uXFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XFxuXFx0XFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIHF1ZXVlO1xcblxcblxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHR0eXBlID0gKCB0eXBlIHx8IFxcXCJmeFxcXCIgKSArIFxcXCJxdWV1ZVxcXCI7XFxuXFx0XFx0XFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXFxuXFx0XFx0XFx0aWYgKCBkYXRhICkge1xcblxcdFxcdFxcdFxcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUucHVzaCggZGF0YSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xcblxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0XFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXFxuXFx0XFx0XFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXFxuXFx0XFx0XFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXFxuXFx0XFx0XFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXFxuXFx0XFx0aWYgKCBmbiA9PT0gXFxcImlucHJvZ3Jlc3NcXFwiICkge1xcblxcdFxcdFxcdGZuID0gcXVldWUuc2hpZnQoKTtcXG5cXHRcXHRcXHRzdGFydExlbmd0aC0tO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGZuICkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcXG5cXHRcXHRcXHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXFxuXFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwiZnhcXFwiICkge1xcblxcdFxcdFxcdFxcdHF1ZXVlLnVuc2hpZnQoIFxcXCJpbnByb2dyZXNzXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXFxuXFx0XFx0XFx0ZGVsZXRlIGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XFxuXFx0XFx0XFx0aG9va3MuZW1wdHkuZmlyZSgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXFxuXFx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xcblxcdFxcdHZhciBrZXkgPSB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiO1xcblxcdFxcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XFxuXFx0XFx0XFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXFxcInF1ZXVlXFxcIiwga2V5IF0gKTtcXG5cXHRcXHRcXHR9IClcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHZhciBzZXR0ZXIgPSAyO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGRhdGEgPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSBcXFwiZnhcXFwiO1xcblxcdFxcdFxcdHNldHRlci0tO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdHRoaXMgOlxcblxcdFxcdFxcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcXG5cXHRcXHRcXHRcXHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJmeFxcXCIgJiYgcXVldWVbIDAgXSAhPT0gXFxcImlucHJvZ3Jlc3NcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHR9LFxcblxcdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXFxcImZ4XFxcIiwgW10gKTtcXG5cXHR9LFxcblxcblxcdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcXG5cXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcXG5cXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xcblxcdFxcdHZhciB0bXAsXFxuXFx0XFx0XFx0Y291bnQgPSAxLFxcblxcdFxcdFxcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFx0XFx0XFx0ZWxlbWVudHMgPSB0aGlzLFxcblxcdFxcdFxcdGkgPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRvYmogPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiICk7XFxuXFx0XFx0XFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xcblxcdFxcdFxcdFxcdGNvdW50Kys7XFxuXFx0XFx0XFx0XFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmVzb2x2ZSgpO1xcblxcdFxcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcXG5cXHR9XFxufSApO1xcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXFxcZCpcXFxcLnwpXFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrfCkvICkuc291cmNlO1xcblxcbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXFxcIl4oPzooWystXSk9fCkoXFxcIiArIHBudW0gKyBcXFwiKShbYS16JV0qKSRcXFwiLCBcXFwiaVxcXCIgKTtcXG5cXG5cXG52YXIgY3NzRXhwYW5kID0gWyBcXFwiVG9wXFxcIiwgXFxcIlJpZ2h0XFxcIiwgXFxcIkJvdHRvbVxcXCIsIFxcXCJMZWZ0XFxcIiBdO1xcblxcbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XFxuXFxuXFx0XFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XFxuXFx0XFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XFxuXFx0XFx0ZWxlbSA9IGVsIHx8IGVsZW07XFxuXFxuXFx0XFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcXG5cXHRcXHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgfHxcXG5cXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmXFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XFxuXFx0XFx0XFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXFxuXFx0XFx0XFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxcblxcdFxcdFxcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcXG5cXG5cXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKSA9PT0gXFxcIm5vbmVcXFwiO1xcblxcdH07XFxuXFxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XFxuXFx0dmFyIHJldCwgbmFtZSxcXG5cXHRcXHRvbGQgPSB7fTtcXG5cXG5cXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcXG5cXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XFxuXFx0XFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xcblxcdH1cXG5cXG5cXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xcblxcblxcdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xcblxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldDtcXG59O1xcblxcblxcblxcblxcbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XFxuXFx0dmFyIGFkanVzdGVkLFxcblxcdFxcdHNjYWxlID0gMSxcXG5cXHRcXHRtYXhJdGVyYXRpb25zID0gMjAsXFxuXFx0XFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xcblxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0d2Vlbi5jdXIoKTtcXG5cXHRcXHRcXHR9IDpcXG5cXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXFxcIlxcXCIgKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcXG5cXHRcXHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIgKSxcXG5cXG5cXHRcXHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xcblxcdFxcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcXFwicHhcXFwiICYmICtpbml0aWFsICkgJiZcXG5cXHRcXHRcXHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xcblxcblxcdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XFxuXFxuXFx0XFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xcblxcdFxcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXFxuXFx0XFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XFxuXFxuXFx0XFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXFxuXFx0XFx0XFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcXG5cXHRcXHRcXHRzY2FsZSA9IHNjYWxlIHx8IFxcXCIuNVxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxcblxcdFxcdFxcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XFxuXFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xcblxcblxcdFxcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXFxuXFx0XFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cXG5cXHRcXHR9IHdoaWxlIChcXG5cXHRcXHRcXHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xcblxcdFxcdCk7XFxuXFx0fVxcblxcblxcdGlmICggdmFsdWVQYXJ0cyApIHtcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcXG5cXG5cXHRcXHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcXG5cXHRcXHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XFxuXFx0XFx0XFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcXG5cXHRcXHRcXHQrdmFsdWVQYXJ0c1sgMiBdO1xcblxcdFxcdGlmICggdHdlZW4gKSB7XFxuXFx0XFx0XFx0dHdlZW4udW5pdCA9IHVuaXQ7XFxuXFx0XFx0XFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xcblxcdFxcdFxcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIGFkanVzdGVkO1xcbn1cXG5cXG5cXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcXG5cXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcXG5cXHR2YXIgdGVtcCxcXG5cXHRcXHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXFxuXFx0XFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxcblxcdFxcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcXG5cXG5cXHRpZiAoIGRpc3BsYXkgKSB7XFxuXFx0XFx0cmV0dXJuIGRpc3BsYXk7XFxuXFx0fVxcblxcblxcdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcXG5cXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFxuXFx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XFxuXFxuXFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0ZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuXFx0fVxcblxcdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcXG5cXG5cXHRyZXR1cm4gZGlzcGxheTtcXG59XFxuXFxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xcblxcdHZhciBkaXNwbGF5LCBlbGVtLFxcblxcdFxcdHZhbHVlcyA9IFtdLFxcblxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XFxuXFxuXFx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXFxuXFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XFxuXFx0XFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcXG5cXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcXG5cXHRcXHRpZiAoIHNob3cgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxcblxcdFxcdFxcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxcblxcdFxcdFxcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcXG5cXHRcXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApIHx8IG51bGw7XFxuXFx0XFx0XFx0XFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0aWYgKCBkaXNwbGF5ICE9PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWVzWyBpbmRleCBdID0gXFxcIm5vbmVcXFwiO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5zZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiwgZGlzcGxheSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcXG5cXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtZW50cztcXG59XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHNob3c6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xcblxcdH0sXFxuXFx0aGlkZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XFxuXFx0fSxcXG5cXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XFxuXFxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFxcXC9cXFxcMD5cXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKykvaSApO1xcblxcbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcXFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XFxuXFxuXFxuXFxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcXG52YXIgd3JhcE1hcCA9IHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdG9wdGlvbjogWyAxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiIF0sXFxuXFxuXFx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcXG5cXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXFxuXFx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxcblxcdHRoZWFkOiBbIDEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIiBdLFxcblxcdGNvbDogWyAyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCIgXSxcXG5cXHR0cjogWyAyLCBcXFwiPHRhYmxlPjx0Ym9keT5cXFwiLCBcXFwiPC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXHR0ZDogWyAzLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXG5cXHRfZGVmYXVsdDogWyAwLCBcXFwiXFxcIiwgXFxcIlxcXCIgXVxcbn07XFxuXFxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XFxuXFxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcXG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcXG5cXG5cXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxcblxcdHZhciByZXQ7XFxuXFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSB7XFxuXFx0XFx0cmV0ID0gW107XFxuXFx0fVxcblxcblxcdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0O1xcbn1cXG5cXG5cXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGwgPSBlbGVtcy5sZW5ndGg7XFxuXFxuXFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdGRhdGFQcml2LnNldChcXG5cXHRcXHRcXHRlbGVtc1sgaSBdLFxcblxcdFxcdFxcdFxcXCJnbG9iYWxFdmFsXFxcIixcXG5cXHRcXHRcXHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcXFwiZ2xvYmFsRXZhbFxcXCIgKVxcblxcdFxcdCk7XFxuXFx0fVxcbn1cXG5cXG5cXG52YXIgcmh0bWwgPSAvPHwmIz9cXFxcdys7LztcXG5cXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xcblxcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXFxuXFx0XFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG5cXHRcXHRub2RlcyA9IFtdLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGwgPSBlbGVtcy5sZW5ndGg7XFxuXFxuXFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdGVsZW0gPSBlbGVtc1sgaSBdO1xcblxcblxcdFxcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxcblxcdFxcdFxcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXFxuXFx0XFx0XFx0XFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcXFwiXFxcIiwgXFxcIlxcXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRcXHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcXG5cXHRcXHRcXHRcXHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRqID0gd3JhcFsgMCBdO1xcblxcdFxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXFxuXFx0XFx0XFx0XFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXFxuXFx0XFx0XFx0XFx0dG1wLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxcblxcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFxuXFx0aSA9IDA7XFxuXFx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxcblxcdFxcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xcblxcdFxcdFxcdGlmICggaWdub3JlZCApIHtcXG5cXHRcXHRcXHRcXHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcXG5cXHRcXHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFxcXCJzY3JpcHRcXFwiICk7XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcdFxcdGlmICggY29udGFpbnMgKSB7XFxuXFx0XFx0XFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcXG5cXHRcXHRpZiAoIHNjcmlwdHMgKSB7XFxuXFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXFxcIlxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGZyYWdtZW50O1xcbn1cXG5cXG5cXG4oIGZ1bmN0aW9uKCkge1xcblxcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG5cXHRcXHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKSApLFxcblxcdFxcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApO1xcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcXG5cXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxcblxcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcXG5cXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcXG5cXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgXFxcInJhZGlvXFxcIiApO1xcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcImNoZWNrZWRcXFwiLCBcXFwiY2hlY2tlZFxcXCIgKTtcXG5cXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJuYW1lXFxcIiwgXFxcInRcXFwiICk7XFxuXFxuXFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxcblxcdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xcblxcdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxcblxcdGRpdi5pbm5lckhUTUwgPSBcXFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlxcXCI7XFxuXFx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XFxufSApKCk7XFxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXG5cXG52YXJcXG5cXHRya2V5RXZlbnQgPSAvXmtleS8sXFxuXFx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXFxuXFx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXFxcLiguKyl8KS87XFxuXFxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcXG5cXHRyZXR1cm4gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XFxuXFx0cmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFx0fSBjYXRjaCAoIGVyciApIHsgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xcblxcdHZhciBvcmlnRm4sIHR5cGU7XFxuXFxuXFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXFxuXFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcXG5cXHRcXHRcXHRkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcXG5cXHRcXHRcXHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcXG5cXG5cXHRcXHQvLyAoIHR5cGVzLCBmbiApXFxuXFx0XFx0Zm4gPSBzZWxlY3RvcjtcXG5cXHRcXHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcXG5cXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcXG5cXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0ZGF0YSA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0Zm4gPSByZXR1cm5GYWxzZTtcXG5cXHR9IGVsc2UgaWYgKCAhZm4gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0fVxcblxcblxcdGlmICggb25lID09PSAxICkge1xcblxcdFxcdG9yaWdGbiA9IGZuO1xcblxcdFxcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xcblxcdFxcdFxcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXFxuXFx0XFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XFxuXFx0fVxcblxcdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcXG5cXHR9ICk7XFxufVxcblxcbi8qXFxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxcbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXFxuICovXFxualF1ZXJ5LmV2ZW50ID0ge1xcblxcblxcdGdsb2JhbDoge30sXFxuXFxuXFx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xcblxcblxcdFxcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcXG5cXHRcXHRcXHRldmVudHMsIHQsIGhhbmRsZU9iaixcXG5cXHRcXHRcXHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXFxuXFx0XFx0XFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxcblxcdFxcdGlmICggIWVsZW1EYXRhICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXFxuXFx0XFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XFxuXFx0XFx0XFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xcblxcdFxcdFxcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcXG5cXHRcXHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcXG5cXHRcXHRpZiAoIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcXG5cXHRcXHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XFxuXFx0XFx0XFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxcblxcdFxcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XFxuXFx0XFx0fVxcblxcdFxcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcXG5cXHRcXHRcXHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXFxuXFx0XFx0XFx0XFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxcblxcdFxcdFxcdFxcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxcblxcdFxcdHR5cGVzID0gKCB0eXBlcyB8fCBcXFwiXFxcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcdFxcdHQgPSB0eXBlcy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCB0LS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xcblxcdFxcdFxcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFxcXCJcXFwiICkuc3BsaXQoIFxcXCIuXFxcIiApLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcXG5cXHRcXHRcXHRpZiAoICF0eXBlICkge1xcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcXG5cXHRcXHRcXHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0XFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdGRhdGE6IGRhdGEsXFxuXFx0XFx0XFx0XFx0aGFuZGxlcjogaGFuZGxlcixcXG5cXHRcXHRcXHRcXHRndWlkOiBoYW5kbGVyLmd1aWQsXFxuXFx0XFx0XFx0XFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxcblxcdFxcdFxcdFxcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXFxuXFx0XFx0XFx0XFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFxcXCIuXFxcIiApXFxuXFx0XFx0XFx0fSwgaGFuZGxlT2JqSW4gKTtcXG5cXG5cXHRcXHRcXHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxcblxcdFxcdFxcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcXG5cXHRcXHRcXHRcXHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XFxuXFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcXG5cXHRcXHRcXHRcXHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxcblxcdFxcdFxcdGlmICggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHR9LFxcblxcblxcdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxcblxcdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XFxuXFxuXFx0XFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxcblxcdFxcdFxcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxcblxcdFxcdFxcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcXG5cXHRcXHRcXHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcXG5cXHRcXHR0eXBlcyA9ICggdHlwZXMgfHwgXFxcIlxcXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXHRcXHR0ID0gdHlwZXMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggdC0tICkge1xcblxcdFxcdFxcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcXG5cXHRcXHRcXHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcXFwiXFxcIiApLnNwbGl0KCBcXFwiLlxcXCIgKS5zb3J0KCk7XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0aWYgKCAhdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcdFxcdFxcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcXG5cXHRcXHRcXHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdHRtcCA9IHRtcFsgMiBdICYmXFxuXFx0XFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIihefFxcXFxcXFxcLilcXFwiICsgbmFtZXNwYWNlcy5qb2luKCBcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIgKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcXG5cXHRcXHRcXHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXFxuXFx0XFx0XFx0XFx0XFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RvciA9PT0gXFxcIioqXFxcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxcblxcdFxcdFxcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxcblxcdFxcdFxcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcXFwiaGFuZGxlIGV2ZW50c1xcXCIgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xcblxcblxcdFxcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxcblxcdFxcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XFxuXFxuXFx0XFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXFxuXFx0XFx0XFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxcblxcdFxcdFxcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFxcXCJldmVudHNcXFwiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XFxuXFx0XFx0YXJnc1sgMCBdID0gZXZlbnQ7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXFxuXFx0XFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcXG5cXHRcXHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XFxuXFxuXFx0XFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcXG5cXHRcXHRpID0gMDtcXG5cXHRcXHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXHRcXHRcXHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xcblxcblxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXFxuXFx0XFx0XFx0XFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxcblxcdFxcdFxcdFxcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxcblxcdFxcdFxcdFxcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXFxuXFx0XFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcXG5cXHRcXHRcXHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQucmVzdWx0O1xcblxcdH0sXFxuXFxuXFx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XFxuXFx0XFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXFxuXFx0XFx0XFx0aGFuZGxlclF1ZXVlID0gW10sXFxuXFx0XFx0XFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXFxuXFx0XFx0XFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcXG5cXHRcXHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTlcXG5cXHRcXHRcXHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcXG5cXHRcXHRcXHRjdXIubm9kZVR5cGUgJiZcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcXG5cXHRcXHRcXHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcXG5cXHRcXHRcXHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcXFwiY2xpY2tzXFxcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxcblxcdFxcdFxcdCEoIGV2ZW50LnR5cGUgPT09IFxcXCJjbGlja1xcXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcXG5cXHRcXHRcXHRcXHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcXFwiY2xpY2tcXFwiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXFxcIiBcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcXG5cXHRcXHRjdXIgPSB0aGlzO1xcblxcdFxcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcXG5cXHR9LFxcblxcblxcdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xcblxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlLFxcblxcblxcdFxcdFxcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XFxuXFx0XFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0d3JpdGFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cXG5cXHRcXHRcXHRvcmlnaW5hbEV2ZW50IDpcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XFxuXFx0fSxcXG5cXG5cXHRzcGVjaWFsOiB7XFxuXFx0XFx0bG9hZDoge1xcblxcblxcdFxcdFxcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcXG5cXHRcXHRcXHRub0J1YmJsZTogdHJ1ZVxcblxcdFxcdH0sXFxuXFx0XFx0Zm9jdXM6IHtcXG5cXG5cXHRcXHRcXHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcXG5cXHRcXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiXFxuXFx0XFx0fSxcXG5cXHRcXHRibHVyOiB7XFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNvdXRcXFwiXFxuXFx0XFx0fSxcXG5cXHRcXHRjbGljazoge1xcblxcblxcdFxcdFxcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFxcXCJpbnB1dFxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsaWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xcblxcdFxcdFxcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcXFwiYVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiZWZvcmV1bmxvYWQ6IHtcXG5cXHRcXHRcXHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xcblxcdFxcdFxcdFxcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cXG5cXHRcXHRcXHRcXHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xcblxcblxcdC8vIFRoaXMgXFxcImlmXFxcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcXG5cXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xcblxcdH1cXG59O1xcblxcbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xcblxcblxcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxcblxcdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xcblxcdFxcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XFxuXFx0fVxcblxcblxcdC8vIEV2ZW50IG9iamVjdFxcblxcdGlmICggc3JjICYmIHNyYy50eXBlICkge1xcblxcdFxcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcXG5cXHRcXHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcXG5cXG5cXHRcXHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxcblxcdFxcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxcblxcdFxcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcXG5cXHRcXHRcXHRcXHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XFxuXFx0XFx0XFx0XFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XFxuXFx0XFx0XFx0cmV0dXJuVHJ1ZSA6XFxuXFx0XFx0XFx0cmV0dXJuRmFsc2U7XFxuXFxuXFx0XFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXFxuXFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxcblxcdFxcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXFxuXFx0XFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cXG5cXHRcXHRcXHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxcblxcdFxcdFxcdHNyYy50YXJnZXQ7XFxuXFxuXFx0XFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XFxuXFx0XFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XFxuXFxuXFx0Ly8gRXZlbnQgdHlwZVxcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhpcy50eXBlID0gc3JjO1xcblxcdH1cXG5cXG5cXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxcblxcdGlmICggcHJvcHMgKSB7XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcXG5cXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcXG5cXG5cXHQvLyBNYXJrIGl0IGFzIGZpeGVkXFxuXFx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XFxufTtcXG5cXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcXG5cXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxcblxcdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXFxuXFx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcblxcdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG5cXHRpc1NpbXVsYXRlZDogZmFsc2UsXFxuXFxuXFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xcblxcdFxcdFxcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcXG5cXG5cXHRcXHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHR9XFxufTtcXG5cXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0YWx0S2V5OiB0cnVlLFxcblxcdGJ1YmJsZXM6IHRydWUsXFxuXFx0Y2FuY2VsYWJsZTogdHJ1ZSxcXG5cXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcXG5cXHRjdHJsS2V5OiB0cnVlLFxcblxcdGRldGFpbDogdHJ1ZSxcXG5cXHRldmVudFBoYXNlOiB0cnVlLFxcblxcdG1ldGFLZXk6IHRydWUsXFxuXFx0cGFnZVg6IHRydWUsXFxuXFx0cGFnZVk6IHRydWUsXFxuXFx0c2hpZnRLZXk6IHRydWUsXFxuXFx0dmlldzogdHJ1ZSxcXG5cXHRcXFwiY2hhclxcXCI6IHRydWUsXFxuXFx0Y2hhckNvZGU6IHRydWUsXFxuXFx0a2V5OiB0cnVlLFxcblxcdGtleUNvZGU6IHRydWUsXFxuXFx0YnV0dG9uOiB0cnVlLFxcblxcdGJ1dHRvbnM6IHRydWUsXFxuXFx0Y2xpZW50WDogdHJ1ZSxcXG5cXHRjbGllbnRZOiB0cnVlLFxcblxcdG9mZnNldFg6IHRydWUsXFxuXFx0b2Zmc2V0WTogdHJ1ZSxcXG5cXHRwb2ludGVySWQ6IHRydWUsXFxuXFx0cG9pbnRlclR5cGU6IHRydWUsXFxuXFx0c2NyZWVuWDogdHJ1ZSxcXG5cXHRzY3JlZW5ZOiB0cnVlLFxcblxcdHRhcmdldFRvdWNoZXM6IHRydWUsXFxuXFx0dG9FbGVtZW50OiB0cnVlLFxcblxcdHRvdWNoZXM6IHRydWUsXFxuXFxuXFx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xcblxcblxcdFxcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xcblxcdFxcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xcblxcdFxcdFxcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XFxuXFx0XFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xcblxcdFxcdFxcdGlmICggYnV0dG9uICYgMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBidXR0b24gJiAyICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJ1dHRvbiAmIDQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQud2hpY2g7XFxuXFx0fVxcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XFxuXFxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXFxuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxcbi8vXFxuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIixcXG5cXHRtb3VzZWxlYXZlOiBcXFwibW91c2VvdXRcXFwiLFxcblxcdHBvaW50ZXJlbnRlcjogXFxcInBvaW50ZXJvdmVyXFxcIixcXG5cXHRwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIlxcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XFxuXFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcXG5cXHRcXHRkZWxlZ2F0ZVR5cGU6IGZpeCxcXG5cXHRcXHRiaW5kVHlwZTogZml4LFxcblxcblxcdFxcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdHZhciByZXQsXFxuXFx0XFx0XFx0XFx0dGFyZ2V0ID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cXG5cXHRcXHRcXHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xcblxcdFxcdFxcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcXG5cXHRcXHRcXHRcXHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xcblxcdFxcdFxcdFxcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRldmVudC50eXBlID0gZml4O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH1cXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xcblxcdH0sXFxuXFx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcXG5cXHR9LFxcblxcdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XFxuXFx0XFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcXG5cXHRcXHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XFxuXFx0XFx0XFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xcblxcdFxcdFxcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iai5zZWxlY3RvcixcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmouaGFuZGxlclxcblxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggdHlwZW9mIHR5cGVzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxcblxcdFxcdFxcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxcblxcdFxcdFxcdGZuID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggZm4gPT09IGZhbHNlICkge1xcblxcdFxcdFxcdGZuID0gcmV0dXJuRmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG52YXJcXG5cXG5cXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXFxuXFxuXFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XFxuXFx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcXFwvXFxcXDA+XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSopW14+XSopXFxcXC8+L2dpLFxcblxcblxcdC8qIGVzbGludC1lbmFibGUgKi9cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xcblxcdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXFxuXFx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cXG5cXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG5cXG5cXHQvLyBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBvciBjaGVja2VkXFxuXFx0cmNoZWNrZWQgPSAvY2hlY2tlZFxcXFxzKig/OltePV18PVxcXFxzKi5jaGVja2VkLikvaSxcXG5cXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcXFwvKC4qKS8sXFxuXFx0cmNsZWFuU2NyaXB0ID0gL15cXFxccyo8ISg/OlxcXFxbQ0RBVEFcXFxcW3wtLSl8KD86XFxcXF1cXFxcXXwtLSk+XFxcXHMqJC9nO1xcblxcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcXG5cXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXFxcInRhYmxlXFxcIiApICYmXFxuXFx0XFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIgKSApIHtcXG5cXG5cXHRcXHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXFxcInRib2R5XFxcIiApWyAwIF0gfHwgZWxlbTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW07XFxufVxcblxcbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xcblxcdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiApICE9PSBudWxsICkgKyBcXFwiL1xcXCIgKyBlbGVtLnR5cGU7XFxuXFx0cmV0dXJuIGVsZW07XFxufVxcbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XFxuXFx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XFxuXFxuXFx0aWYgKCBtYXRjaCApIHtcXG5cXHRcXHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcXG5cXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcXG5cXG5cXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxcblxcdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XFxuXFx0XFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xcblxcdFxcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xcblxcdFxcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcXG5cXG5cXHRcXHRpZiAoIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xcblxcdFxcdFxcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xcblxcblxcdFxcdFxcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcXG5cXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xcblxcdFxcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcXG5cXHRcXHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xcblxcblxcdFxcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcXG5cXHR9XFxufVxcblxcbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XFxuXFx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcblxcdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxcblxcdGlmICggbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcXG5cXHRcXHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcXG5cXG5cXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xcblxcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwidGV4dGFyZWFcXFwiICkge1xcblxcdFxcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcXG5cXG5cXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcXG5cXG5cXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxcblxcdFxcdGlOb0Nsb25lID0gbCAtIDEsXFxuXFx0XFx0dmFsdWUgPSBhcmdzWyAwIF0sXFxuXFx0XFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xcblxcblxcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxcblxcdGlmICggaXNGdW5jdGlvbiB8fFxcblxcdFxcdFxcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xcblxcdFxcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcXG5cXHRcXHRcXHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XFxuXFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uICkge1xcblxcdFxcdFxcdFxcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdGlmICggbCApIHtcXG5cXHRcXHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xcblxcdFxcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xcblxcdFxcdFxcdGZyYWdtZW50ID0gZmlyc3Q7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xcblxcdFxcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcXG5cXHRcXHRcXHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXFxcInNjcmlwdFxcXCIgKSwgZGlzYWJsZVNjcmlwdCApO1xcblxcdFxcdFxcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXFxuXFx0XFx0XFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXFxuXFx0XFx0XFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IGZyYWdtZW50O1xcblxcblxcdFxcdFxcdFxcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhhc1NjcmlwdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcXFwic2NyaXB0XFxcIiApICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBoYXNTY3JpcHRzICkge1xcblxcdFxcdFxcdFxcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xcblxcdFxcdFxcdFxcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcXFwiXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXFxcImdsb2JhbEV2YWxcXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZS5zcmMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFxcXCJcXFwiICksIGRvYyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBjb2xsZWN0aW9uO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcXG5cXHR2YXIgbm9kZSxcXG5cXHRcXHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXFxuXFx0XFx0aSA9IDA7XFxuXFxuXFx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xcblxcdFxcdFxcdFxcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtO1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcXFwiPCQxPjwvJDI+XFxcIiApO1xcblxcdH0sXFxuXFxuXFx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcXG5cXHRcXHRcXHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXFxuXFx0XFx0XFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcXG5cXHRcXHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXFxuXFx0XFx0XFx0XFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxcblxcdFxcdFxcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcXG5cXHRcXHRcXHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxcblxcdFxcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHRcXHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdFxcdFxcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcXG5cXHRcXHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcXFwic2NyaXB0XFxcIiApO1xcblxcdFxcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XFxuXFx0XFx0XFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcXG5cXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0fSxcXG5cXG5cXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcXG5cXHRcXHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xcblxcdFxcdFxcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcXG5cXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xcblxcdH0sXFxuXFxuXFx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XFxuXFx0XFx0XFx0XFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XFxuXFx0fSxcXG5cXG5cXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0YmVmb3JlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRhZnRlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXFxuXFx0XFx0XFx0XFx0ZWxlbS50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XFxuXFx0XFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xcblxcblxcdFxcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxcblxcdFxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdFxcdGwgPSB0aGlzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXFxuXFx0XFx0XFx0XFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFxcXCJcXFwiLCBcXFwiXFxcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcXG5cXHR9LFxcblxcblxcdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaWdub3JlZCA9IFtdO1xcblxcblxcdFxcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xcblxcblxcdFxcdFxcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXFxuXFx0XFx0fSwgaWdub3JlZCApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsXFxuXFx0cHJlcGVuZFRvOiBcXFwicHJlcGVuZFxcXCIsXFxuXFx0aW5zZXJ0QmVmb3JlOiBcXFwiYmVmb3JlXFxcIixcXG5cXHRpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIixcXG5cXHRyZXBsYWNlQWxsOiBcXFwicmVwbGFjZVdpdGhcXFwiXFxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBlbGVtcyxcXG5cXHRcXHRcXHRyZXQgPSBbXSxcXG5cXHRcXHRcXHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXFxuXFx0XFx0XFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XFxuXFx0XFx0XFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcXG5cXHRcXHRcXHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcXG5cXHR9O1xcbn0gKTtcXG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XFxuXFxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBwbnVtICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiApO1xcblxcbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXFxuXFx0XFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXFxuXFx0XFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFxcXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXFxcIlxcblxcdFxcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xcblxcblxcdFxcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xcblxcdFxcdFxcdHZpZXcgPSB3aW5kb3c7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcXG5cXHR9O1xcblxcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFxuXFx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XFxuXFx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cXG5cXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcXG5cXG5cXHRcXHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXFxuXFx0XFx0aWYgKCAhZGl2ICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxcblxcdFxcdFxcdFxcXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XFxcIiArXFxuXFx0XFx0XFx0XFxcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XFxcIiArXFxuXFx0XFx0XFx0XFxcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XFxcIiArXFxuXFx0XFx0XFx0XFxcInRvcDoxJTt3aWR0aDo1MCVcXFwiO1xcblxcdFxcdGRpdi5pbm5lckhUTUwgPSBcXFwiXFxcIjtcXG5cXHRcXHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xcblxcblxcdFxcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcXG5cXHRcXHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcXFwiMSVcXFwiO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcXG5cXHRcXHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcXFwiMnB4XFxcIjtcXG5cXHRcXHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcXFwiNHB4XFxcIjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XFxuXFx0XFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XFxuXFx0XFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXFxcIjUwJVxcXCI7XFxuXFx0XFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcXFwiNHB4XFxcIjtcXG5cXG5cXHRcXHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xcblxcblxcdFxcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcXG5cXHRcXHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXFxuXFx0XFx0ZGl2ID0gbnVsbDtcXG5cXHR9XFxuXFxuXFx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXFxuXFx0XFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKSxcXG5cXHRcXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApO1xcblxcblxcdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXFxuXFx0aWYgKCAhZGl2LnN0eWxlICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxcblxcdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcXG5cXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiY29udGVudC1ib3hcXFwiO1xcblxcdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiO1xcblxcdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcXFwiY29udGVudC1ib3hcXFwiO1xcblxcblxcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXFxcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XFxcIiArXFxuXFx0XFx0XFxcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVxcXCI7XFxuXFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcXG5cXG5cXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XFxuXFx0XFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XFxuXFx0XFx0fSxcXG5cXHRcXHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcXG5cXHRcXHR9XFxuXFx0fSApO1xcbn0gKSgpO1xcblxcblxcbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XFxuXFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcXG5cXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXFxuXFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcXG5cXG5cXHRcXHRpZiAoIHJldCA9PT0gXFxcIlxcXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXFxcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcXFwiXFxuXFx0XFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXFxuXFx0XFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cXG5cXHRcXHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XFxuXFx0XFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcXG5cXHRcXHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xcblxcdFxcdFxcdHdpZHRoID0gc3R5bGUud2lkdGg7XFxuXFx0XFx0XFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcXG5cXHRcXHRcXHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xcblxcblxcdFxcdFxcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcXG5cXHRcXHRcXHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XFxuXFx0XFx0XFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XFxuXFxuXFx0XFx0XFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xcblxcdFxcdFxcdHN0eWxlLndpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcXG5cXHRcXHRcXHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0XFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cXG5cXHRcXHRyZXQgKyBcXFwiXFxcIiA6XFxuXFx0XFx0cmV0O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XFxuXFxuXFx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cXG5cXHRyZXR1cm4ge1xcblxcdFxcdGdldDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCBjb25kaXRpb25GbigpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxcblxcdFxcdFxcdFxcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5nZXQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuXFxudmFyXFxuXFxuXFx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxcblxcdC8vIGV4Y2VwdCBcXFwidGFibGVcXFwiLCBcXFwidGFibGUtY2VsbFxcXCIsIG9yIFxcXCJ0YWJsZS1jYXB0aW9uXFxcIlxcblxcdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxcblxcdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcXG5cXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgdmlzaWJpbGl0eTogXFxcImhpZGRlblxcXCIsIGRpc3BsYXk6IFxcXCJibG9ja1xcXCIgfSxcXG5cXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XFxuXFx0XFx0bGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLFxcblxcdFxcdGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiXFxuXFx0fSxcXG5cXG5cXHRjc3NQcmVmaXhlcyA9IFsgXFxcIldlYmtpdFxcXCIsIFxcXCJNb3pcXFwiLCBcXFwibXNcXFwiIF0sXFxuXFx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkuc3R5bGU7XFxuXFxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xcblxcblxcdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXFxuXFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XFxuXFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcXG5cXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxcblxcdFxcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XFxuXFxuXFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xcblxcdFxcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xcblxcdFxcdFxcdHJldHVybiBuYW1lO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XFxuXFxuXFx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxcblxcdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxcblxcdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xcblxcdHJldHVybiBtYXRjaGVzID9cXG5cXG5cXHRcXHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcXFwic3VidHJhY3RcXFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcXG5cXHRcXHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFxcXCJweFxcXCIgKSA6XFxuXFx0XFx0dmFsdWU7XFxufVxcblxcbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcXG5cXHR2YXIgaSxcXG5cXHRcXHR2YWwgPSAwO1xcblxcblxcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxcblxcdGlmICggZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcXFwiYm9yZGVyXFxcIiA6IFxcXCJjb250ZW50XFxcIiApICkge1xcblxcdFxcdGkgPSA0O1xcblxcblxcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGkgPSBuYW1lID09PSBcXFwid2lkdGhcXFwiID8gMSA6IDA7XFxuXFx0fVxcblxcblxcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcXG5cXG5cXHRcXHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XFxuXFx0XFx0aWYgKCBleHRyYSA9PT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0XFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGlzQm9yZGVyQm94ICkge1xcblxcblxcdFxcdFxcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxcblxcdFxcdFxcdGlmICggZXh0cmEgPT09IFxcXCJjb250ZW50XFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxcblxcdFxcdFxcdGlmICggZXh0cmEgIT09IFxcXCJtYXJnaW5cXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcXG5cXHRcXHRcXHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcblxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcXG5cXHRcXHRcXHRpZiAoIGV4dHJhICE9PSBcXFwicGFkZGluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kWyBpIF0gKyBcXFwiV2lkdGhcXFwiLCB0cnVlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gdmFsO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcXG5cXG5cXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxcblxcdHZhciB2YWwsXFxuXFx0XFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXFxuXFx0XFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXFxuXFx0XFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiYm9yZGVyLWJveFxcXCI7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxcblxcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cXG5cXHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XFxuXFx0XFx0dmFsID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdO1xcblxcdH1cXG5cXG5cXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcXG5cXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcXG5cXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcXG5cXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xcblxcblxcdFxcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxcblxcdFxcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XFxuXFx0XFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xcblxcdFxcdFxcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cXG5cXHRcXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xcblxcdFxcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcXG5cXHRcXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcXG5cXHRcXHRcXHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xcblxcblxcdFxcdC8vIE5vcm1hbGl6ZSBcXFwiXFxcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXFxuXFx0XFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcXG5cXHR9XFxuXFxuXFx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcXG5cXHRyZXR1cm4gKCB2YWwgK1xcblxcdFxcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxcblxcdFxcdFxcdGVsZW0sXFxuXFx0XFx0XFx0bmFtZSxcXG5cXHRcXHRcXHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIgKSxcXG5cXHRcXHRcXHR2YWx1ZUlzQm9yZGVyQm94LFxcblxcdFxcdFxcdHN0eWxlc1xcblxcdFxcdClcXG5cXHQpICsgXFxcInB4XFxcIjtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxcblxcdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxcblxcdGNzc0hvb2tzOiB7XFxuXFx0XFx0b3BhY2l0eToge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcXFwib3BhY2l0eVxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09PSBcXFwiXFxcIiA/IFxcXCIxXFxcIiA6IHJldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFxcXCJweFxcXCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xcblxcdGNzc051bWJlcjoge1xcblxcdFxcdFxcXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImNvbHVtbkNvdW50XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZmlsbE9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmbGV4R3Jvd1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZsZXhTaHJpbmtcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmb250V2VpZ2h0XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwibGluZUhlaWdodFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJvcmRlclxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9ycGhhbnNcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ3aWRvd3NcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6SW5kZXhcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6b29tXFxcIjogdHJ1ZVxcblxcdH0sXFxuXFxuXFx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxcblxcdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcXG5cXHRjc3NQcm9wczoge1xcblxcdFxcdFxcXCJmbG9hdFxcXCI6IFxcXCJjc3NGbG9hdFxcXCJcXG5cXHR9LFxcblxcblxcdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXFxuXFx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XFxuXFxuXFx0XFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXFxuXFx0XFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcXG5cXHRcXHR2YXIgcmV0LCB0eXBlLCBob29rcyxcXG5cXHRcXHRcXHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcXG5cXHRcXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0XFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxcblxcdFxcdFxcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcXG5cXG5cXHRcXHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xcblxcblxcdFxcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxcblxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHR0eXBlID0gdHlwZW9mIHZhbHVlO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgXFxcIis9XFxcIiBvciBcXFwiLT1cXFwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxcblxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRml4ZXMgYnVnICM5MjM3XFxuXFx0XFx0XFx0XFx0dHlwZSA9IFxcXCJudW1iZXJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxcblxcdFxcdFxcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xcblxcdFxcdFxcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcXFwiXFxcIiAmJiBuYW1lLmluZGV4T2YoIFxcXCJiYWNrZ3JvdW5kXFxcIiApID09PSAwICkge1xcblxcdFxcdFxcdFxcdHN0eWxlWyBuYW1lIF0gPSBcXFwiaW5oZXJpdFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxcblxcdFxcdFxcdGlmICggIWhvb2tzIHx8ICEoIFxcXCJzZXRcXFwiIGluIGhvb2tzICkgfHxcXG5cXHRcXHRcXHRcXHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XFxuXFx0XFx0XFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcXG5cXHRcXHR2YXIgdmFsLCBudW0sIGhvb2tzLFxcblxcdFxcdFxcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxcblxcdFxcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcXG5cXHRcXHRcXHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XFxuXFxuXFx0XFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xcblxcblxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyApIHtcXG5cXHRcXHRcXHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XFxuXFx0XFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb252ZXJ0IFxcXCJub3JtYWxcXFwiIHRvIGNvbXB1dGVkIHZhbHVlXFxuXFx0XFx0aWYgKCB2YWwgPT09IFxcXCJub3JtYWxcXFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xcblxcdFxcdFxcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcXG5cXHRcXHRpZiAoIGV4dHJhID09PSBcXFwiXFxcIiB8fCBleHRyYSApIHtcXG5cXHRcXHRcXHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2YWw7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggWyBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XFxuXFx0XFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cXG5cXHRcXHRcXHRcXHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxcblxcdFxcdFxcdFxcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICkgKSAmJlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xcblxcdFxcdFxcdFxcdFxcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxcblxcdFxcdFxcdFxcdFxcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcXG5cXHRcXHRcXHR2YXIgbWF0Y2hlcyxcXG5cXHRcXHRcXHRcXHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcXG5cXHRcXHRcXHRcXHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxcblxcdFxcdFxcdFxcdFxcdGVsZW0sXFxuXFx0XFx0XFx0XFx0XFx0bmFtZSxcXG5cXHRcXHRcXHRcXHRcXHRleHRyYSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiYm9yZGVyLWJveFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0c3R5bGVzXFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxcblxcdFxcdFxcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcXG5cXHRcXHRcXHRcXHQoIG1hdGNoZXNbIDMgXSB8fCBcXFwicHhcXFwiICkgIT09IFxcXCJweFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XFxuXFx0XFx0fVxcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcXG5cXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XFxuXFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFxcXCJtYXJnaW5MZWZ0XFxcIiApICkgfHxcXG5cXHRcXHRcXHRcXHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxcblxcdFxcdFxcdFxcdFxcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdH0gKVxcblxcdFxcdFxcdFxcdCkgKyBcXFwicHhcXFwiO1xcblxcdFxcdH1cXG5cXHR9XFxuKTtcXG5cXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRtYXJnaW46IFxcXCJcXFwiLFxcblxcdHBhZGRpbmc6IFxcXCJcXFwiLFxcblxcdGJvcmRlcjogXFxcIldpZHRoXFxcIlxcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xcblxcdFxcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBpID0gMCxcXG5cXHRcXHRcXHRcXHRleHBhbmRlZCA9IHt9LFxcblxcblxcdFxcdFxcdFxcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xcblxcdFxcdFxcdFxcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiA/IHZhbHVlLnNwbGl0KCBcXFwiIFxcXCIgKSA6IFsgdmFsdWUgXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxcblxcdFxcdFxcdFxcdFxcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGV4cGFuZGVkO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XFxuXFx0XFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIHN0eWxlcywgbGVuLFxcblxcdFxcdFxcdFxcdG1hcCA9IHt9LFxcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdFxcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcXG5cXHRcXHRcXHRcXHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRsZW4gPSBuYW1lLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxcblxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9XFxufSApO1xcblxcblxcbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcXG5cXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xcbn1cXG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcXG5cXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XFxuXFx0Y29uc3RydWN0b3I6IFR3ZWVuLFxcblxcdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcXG5cXHRcXHR0aGlzLmVsZW0gPSBlbGVtO1xcblxcdFxcdHRoaXMucHJvcCA9IHByb3A7XFxuXFx0XFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcXG5cXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdFxcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XFxuXFx0XFx0dGhpcy5lbmQgPSBlbmQ7XFxuXFx0XFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiApO1xcblxcdH0sXFxuXFx0Y3VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xcblxcblxcdFxcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xcblxcdFxcdFxcdGhvb2tzLmdldCggdGhpcyApIDpcXG5cXHRcXHRcXHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XFxuXFx0fSxcXG5cXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xcblxcdFxcdHZhciBlYXNlZCxcXG5cXHRcXHRcXHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XFxuXFxuXFx0XFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XFxuXFx0XFx0XFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXFxuXFx0XFx0XFx0XFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xcblxcdFxcdH1cXG5cXHRcXHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XFxuXFxuXFx0XFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xcblxcdFxcdFxcdGhvb2tzLnNldCggdGhpcyApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9XFxufTtcXG5cXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XFxuXFxuVHdlZW4ucHJvcEhvb2tzID0ge1xcblxcdF9kZWZhdWx0OiB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XFxuXFx0XFx0XFx0dmFyIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxcblxcdFxcdFxcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXFxuXFx0XFx0XFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XFxuXFx0XFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XFxuXFx0XFx0XFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cXG5cXHRcXHRcXHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXFxcIjEwcHhcXFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XFxuXFx0XFx0XFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcXFwicm90YXRlKDFyYWQpXFxcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXFxuXFx0XFx0XFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFxcXCJhdXRvXFxcIiBhcmUgY29udmVydGVkIHRvIDAuXFxuXFx0XFx0XFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcXFwiYXV0b1xcXCIgPyAwIDogcmVzdWx0O1xcblxcdFxcdH0sXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXFxuXFx0XFx0XFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxcblxcdFxcdFxcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdFxcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xcblxcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xcblxcdFxcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZWFzaW5nID0ge1xcblxcdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIHA7XFxuXFx0fSxcXG5cXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcXG5cXHR9LFxcblxcdF9kZWZhdWx0OiBcXFwic3dpbmdcXFwiXFxufTtcXG5cXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcXG5cXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxcbmpRdWVyeS5meC5zdGVwID0ge307XFxuXFxuXFxuXFxuXFxudmFyXFxuXFx0ZnhOb3csIHRpbWVySWQsXFxuXFx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXFxuXFx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XFxuXFxuZnVuY3Rpb24gcmFmKCkge1xcblxcdGlmICggdGltZXJJZCApIHtcXG5cXHRcXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKTtcXG5cXHRcXHRqUXVlcnkuZngudGljaygpO1xcblxcdH1cXG59XFxuXFxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG5cXHR9ICk7XFxuXFx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcXG59XFxuXFxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xcblxcdHZhciB3aGljaCxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XFxuXFxuXFx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxcblxcdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XFxuXFx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XFxuXFx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xcblxcdFxcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XFxuXFx0XFx0YXR0cnNbIFxcXCJtYXJnaW5cXFwiICsgd2hpY2ggXSA9IGF0dHJzWyBcXFwicGFkZGluZ1xcXCIgKyB3aGljaCBdID0gdHlwZTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XFxuXFx0XFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGF0dHJzO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcXG5cXHR2YXIgdHdlZW4sXFxuXFx0XFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXFxcIipcXFwiIF0gKSxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XFxuXFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xcblxcblxcdFxcdFxcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XFxuXFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xcblxcdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcXG5cXHRcXHRpc0JveCA9IFxcXCJ3aWR0aFxcXCIgaW4gcHJvcHMgfHwgXFxcImhlaWdodFxcXCIgaW4gcHJvcHMsXFxuXFx0XFx0YW5pbSA9IHRoaXMsXFxuXFx0XFx0b3JpZyA9IHt9LFxcblxcdFxcdHN0eWxlID0gZWxlbS5zdHlsZSxcXG5cXHRcXHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxcblxcdFxcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiZnhzaG93XFxcIiApO1xcblxcblxcdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xcblxcdGlmICggIW9wdHMucXVldWUgKSB7XFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFxcXCJmeFxcXCIgKTtcXG5cXHRcXHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0aG9va3MudW5xdWV1ZWQgPSAwO1xcblxcdFxcdFxcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xcblxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRvbGRmaXJlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcdFxcdGhvb2tzLnVucXVldWVkKys7XFxuXFxuXFx0XFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXFxuXFx0XFx0XFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGhvb2tzLnVucXVldWVkLS07XFxuXFx0XFx0XFx0XFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcXFwiZnhcXFwiICkubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXFxuXFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcXG5cXHRcXHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XFxuXFx0XFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xcblxcdFxcdFxcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXFxcInRvZ2dsZVxcXCI7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcXFwiaGlkZVxcXCIgOiBcXFwic2hvd1xcXCIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXFxcInNob3dcXFwiIGFuZFxcblxcdFxcdFxcdFxcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXFxuXFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gXFxcInNob3dcXFwiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRoaWRkZW4gPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXFxuXFx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xcblxcdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gUmVzdHJpY3QgXFxcIm92ZXJmbG93XFxcIiBhbmQgXFxcImRpc3BsYXlcXFwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcXG5cXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xcblxcdFxcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxcblxcdFxcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXFxuXFx0XFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XFxuXFxuXFx0XFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXFxuXFx0XFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xcblxcdFxcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0fVxcblxcdFxcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKTtcXG5cXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xcblxcdFxcdFxcdFxcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcXG5cXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHRcXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcXG5cXHRcXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJpbmxpbmVcXFwiIHx8IGRpc3BsYXkgPT09IFxcXCJpbmxpbmUtYmxvY2tcXFwiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZmxvYXRcXFwiICkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggIXByb3BUd2VlbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiID8gXFxcIlxcXCIgOiBkaXNwbGF5O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3R5bGUuZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGlmICggb3B0cy5vdmVyZmxvdyApIHtcXG5cXHRcXHRzdHlsZS5vdmVyZmxvdyA9IFxcXCJoaWRkZW5cXFwiO1xcblxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcXG5cXHRcXHRcXHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXFxuXFx0cHJvcFR3ZWVuID0gZmFsc2U7XFxuXFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xcblxcblxcdFxcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXFxuXFx0XFx0aWYgKCAhcHJvcFR3ZWVuICkge1xcblxcdFxcdFxcdGlmICggZGF0YVNob3cgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBcXFwiaGlkZGVuXFxcIiBpbiBkYXRhU2hvdyApIHtcXG5cXHRcXHRcXHRcXHRcXHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFxcXCJmeHNob3dcXFwiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXFxcInJldmVyc2VzXFxcIlxcblxcdFxcdFxcdGlmICggdG9nZ2xlICkge1xcblxcdFxcdFxcdFxcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXFxuXFx0XFx0XFx0aWYgKCBoaWRkZW4gKSB7XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xcblxcblxcdFxcdFxcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFxcXCJoaWRlXFxcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0XFx0aWYgKCAhaGlkZGVuICkge1xcblxcdFxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFxcXCJmeHNob3dcXFwiICk7XFxuXFx0XFx0XFx0XFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXFxuXFx0XFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XFxuXFx0XFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XFxuXFx0XFx0XFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcXG5cXHRcXHRcXHRpZiAoIGhpZGRlbiApIHtcXG5cXHRcXHRcXHRcXHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xcblxcdFxcdFxcdFxcdHByb3BUd2Vlbi5zdGFydCA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xcblxcdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XFxuXFxuXFx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXFxuXFx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XFxuXFx0XFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XFxuXFx0XFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xcblxcdFxcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xcblxcdFxcdFxcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xcblxcdFxcdFxcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZXhwYW5kXFxcIiBpbiBob29rcyApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXFxuXFx0XFx0XFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcXFwibmFtZVxcXCJcXG5cXHRcXHRcXHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcXG5cXHRcXHRcXHRcXHRcXHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xcblxcdHZhciByZXN1bHQsXFxuXFx0XFx0c3RvcHBlZCxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxcblxcdFxcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcXG5cXHRcXHRcXHRkZWxldGUgdGljay5lbGVtO1xcblxcdFxcdH0gKSxcXG5cXHRcXHR0aWNrID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCBzdG9wcGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcXG5cXHRcXHRcXHRcXHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxcblxcdFxcdFxcdFxcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcXG5cXHRcXHRcXHRcXHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXFxuXFx0XFx0XFx0XFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxcblxcdFxcdFxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdFxcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xcblxcblxcdFxcdFxcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZW1haW5pbmc7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcXG5cXHRcXHRcXHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XFxuXFx0XFx0XFx0XFx0c3BlY2lhbEVhc2luZzoge30sXFxuXFx0XFx0XFx0XFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XFxuXFx0XFx0XFx0fSwgb3B0aW9ucyApLFxcblxcdFxcdFxcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcXG5cXHRcXHRcXHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXFxuXFx0XFx0XFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxcblxcdFxcdFxcdHR3ZWVuczogW10sXFxuXFx0XFx0XFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcXG5cXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gMCxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcXG5cXHRcXHRcXHRcXHRcXHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xcblxcdFxcdFxcdFxcdGlmICggc3RvcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3RvcHBlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxcblxcdFxcdFxcdFxcdGlmICggZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKSxcXG5cXHRcXHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcXG5cXG5cXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xcblxcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcXG5cXHRcXHRpZiAoIHJlc3VsdCApIHtcXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xcblxcblxcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XFxuXFx0XFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XFxuXFx0fVxcblxcblxcdGpRdWVyeS5meC50aW1lcihcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRhbmltOiBhbmltYXRpb24sXFxuXFx0XFx0XFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXFxuXFx0XFx0fSApXFxuXFx0KTtcXG5cXG5cXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xcblxcdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcXG5cXHRcXHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxcblxcdFxcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcXG5cXHRcXHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcXG59XFxuXFxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xcblxcblxcdHR3ZWVuZXJzOiB7XFxuXFx0XFx0XFxcIipcXFwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xcblxcdFxcdFxcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xcblxcdFxcdFxcdHJldHVybiB0d2VlbjtcXG5cXHRcXHR9IF1cXG5cXHR9LFxcblxcblxcdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcXG5cXHRcXHRcXHRjYWxsYmFjayA9IHByb3BzO1xcblxcdFxcdFxcdHByb3BzID0gWyBcXFwiKlxcXCIgXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHByb3AsXFxuXFx0XFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdFxcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcXG5cXG5cXHRcXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcXG5cXHRcXHRcXHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xcblxcdFxcdFxcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXFxuXFxuXFx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XFxuXFx0XFx0aWYgKCBwcmVwZW5kICkge1xcblxcdFxcdFxcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcXG5cXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcXFwib2JqZWN0XFxcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xcblxcdFxcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XFxuXFx0XFx0XFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXFxuXFx0XFx0ZHVyYXRpb246IHNwZWVkLFxcblxcdFxcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xcblxcdH07XFxuXFxuXFx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxcblxcdGlmICggalF1ZXJ5LmZ4Lm9mZiB8fCBkb2N1bWVudC5oaWRkZW4gKSB7XFxuXFx0XFx0b3B0LmR1cmF0aW9uID0gMDtcXG5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcXG5cXHRcXHRcXHRcXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXFxcImZ4XFxcIlxcblxcdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xcblxcdFxcdG9wdC5xdWV1ZSA9IFxcXCJmeFxcXCI7XFxuXFx0fVxcblxcblxcdC8vIFF1ZXVlaW5nXFxuXFx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcXG5cXG5cXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XFxuXFx0XFx0XFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggb3B0LnF1ZXVlICkge1xcblxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gb3B0O1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcXG5cXHRcXHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXFxcIm9wYWNpdHlcXFwiLCAwICkuc2hvdygpXFxuXFxuXFx0XFx0XFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXFxuXFx0XFx0XFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcXG5cXHR9LFxcblxcdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxcblxcdFxcdFxcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcXG5cXHRcXHRcXHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XFxuXFx0XFx0XFx0XFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xcblxcblxcdFxcdFxcdFxcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxcblxcdFxcdFxcdFxcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiZmluaXNoXFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdGFuaW0uc3RvcCggdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xcblxcblxcdFxcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxcblxcdFxcdFxcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcXG5cXHR9LFxcblxcdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xcblxcdFxcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XFxuXFx0XFx0XFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xcblxcdFxcdFxcdGRlbGV0ZSBob29rcy5zdG9wO1xcblxcdFxcdFxcdHN0b3AoIGdvdG9FbmQgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xcblxcdFxcdFxcdGNsZWFyUXVldWUgPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcXG5cXHRcXHRcXHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFxcXCJmeFxcXCIsIFtdICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcXG5cXHRcXHRcXHRcXHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcblxcdFxcdFxcdFxcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxcblxcdFxcdFxcdFxcdFxcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcXG5cXHRcXHRcXHRcXHRcXHRkZXF1ZXVlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXFxuXFx0XFx0XFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxcblxcdFxcdFxcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cXG5cXHRcXHRcXHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xcblxcdFxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBpbmRleCxcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXFxuXFx0XFx0XFx0XFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXFxcInF1ZXVlXFxcIiBdLFxcblxcdFxcdFxcdFxcdGhvb2tzID0gZGF0YVsgdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIiBdLFxcblxcdFxcdFxcdFxcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xcblxcblxcdFxcdFxcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcXG5cXHRcXHRcXHRkYXRhLmZpbmlzaCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XFxuXFx0XFx0XFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xcblxcblxcdFxcdFxcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcXG5cXHRcXHRcXHRcXHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cXG5cXHRcXHRcXHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xcblxcdFxcdFxcdFxcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xcblxcdFxcdFxcdFxcdFxcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cXG5cXHRcXHRcXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdFxcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xcblxcdFxcdFxcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggWyBcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcXFwiYm9vbGVhblxcXCIgP1xcblxcdFxcdFxcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XFxuXFx0XFx0XFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcXG5qUXVlcnkuZWFjaCgge1xcblxcdHNsaWRlRG93bjogZ2VuRngoIFxcXCJzaG93XFxcIiApLFxcblxcdHNsaWRlVXA6IGdlbkZ4KCBcXFwiaGlkZVxcXCIgKSxcXG5cXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFxcXCJ0b2dnbGVcXFwiICksXFxuXFx0ZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LFxcblxcdGZhZGVPdXQ6IHsgb3BhY2l0eTogXFxcImhpZGVcXFwiIH0sXFxuXFx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9XFxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS50aW1lcnMgPSBbXTtcXG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xcblxcdHZhciB0aW1lcixcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xcblxcblxcdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xcblxcblxcdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcXG5cXHRcXHR0aW1lciA9IHRpbWVyc1sgaSBdO1xcblxcblxcdFxcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxcblxcdFxcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xcblxcdFxcdFxcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRqUXVlcnkuZnguc3RvcCgpO1xcblxcdH1cXG5cXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG59O1xcblxcbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcXG5cXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XFxuXFx0aWYgKCB0aW1lcigpICkge1xcblxcdFxcdGpRdWVyeS5meC5zdGFydCgpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcXG5cXHRpZiAoICF0aW1lcklkICkge1xcblxcdFxcdHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID9cXG5cXHRcXHRcXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKSA6XFxuXFx0XFx0XFx0d2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHRpZiAoIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSApIHtcXG5cXHRcXHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVySWQgKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XFxuXFx0fVxcblxcblxcdHRpbWVySWQgPSBudWxsO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcXG5cXHRzbG93OiA2MDAsXFxuXFx0ZmFzdDogMjAwLFxcblxcblxcdC8vIERlZmF1bHQgc3BlZWRcXG5cXHRfZGVmYXVsdDogNDAwXFxufTtcXG5cXG5cXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXFxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcXG5cXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xcblxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcXG5cXHRcXHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XFxuXFx0XFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcXG5cXHRcXHR9O1xcblxcdH0gKTtcXG59O1xcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApLFxcblxcdFxcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJzZWxlY3RcXFwiICksXFxuXFx0XFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwib3B0aW9uXFxcIiApICk7XFxuXFxuXFx0aW5wdXQudHlwZSA9IFxcXCJjaGVja2JveFxcXCI7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XFxuXFx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXFxcIm9uXFxcIlxcblxcdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcXFwiXFxcIjtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxcblxcdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cXG5cXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJpbnB1dFxcXCIgKTtcXG5cXHRpbnB1dC52YWx1ZSA9IFxcXCJ0XFxcIjtcXG5cXHRpbnB1dC50eXBlID0gXFxcInJhZGlvXFxcIjtcXG5cXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXFxcInRcXFwiO1xcbn0gKSgpO1xcblxcblxcbnZhciBib29sSG9vayxcXG5cXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cXG5cXHRcXHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXFxuXFx0XFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxcblxcdFxcdFxcdFxcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwic2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcXFwiXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xcblxcblxcdFxcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXFxuXFx0XFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xcblxcdH0sXFxuXFxuXFx0YXR0ckhvb2tzOiB7XFxuXFx0XFx0dHlwZToge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXFxcInJhZGlvXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXFxcImlucHV0XFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS52YWx1ZSA9IHZhbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdHZhciBuYW1lLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcblxcdFxcdFxcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcXG5cXHRcXHRcXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcXG5cXHRcXHRcXHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xcblxcblxcdFxcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xcbmJvb2xIb29rID0ge1xcblxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xcblxcdFxcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcXG5cXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFxcXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xcblxcblxcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHR2YXIgcmV0LCBoYW5kbGUsXFxuXFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xcblxcdFxcdFxcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcXG5cXHRcXHRcXHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XFxuXFx0XFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG5cXHRcXHRcXHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcblxcdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXFxuXFx0XFx0XFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcXG5cXHR9LFxcblxcblxcdHByb3BIb29rczoge1xcblxcdFxcdHRhYkluZGV4OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXFxuXFx0XFx0XFx0XFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MilcXG5cXHRcXHRcXHRcXHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcXFwidGFiaW5kZXhcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0YWJpbmRleCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoXFxuXFx0XFx0XFx0XFx0XFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uaHJlZlxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHByb3BGaXg6IHtcXG5cXHRcXHRcXFwiZm9yXFxcIjogXFxcImh0bWxGb3JcXFwiLFxcblxcdFxcdFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiXFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcXG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXFxuLy8gb24gdGhlIG9wdGlvblxcbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxcbi8vIGVzbGludCBydWxlIFxcXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcXFwiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xcblxcdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcXFwib2ZmXFxcIiAqL1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFxcXCJvZmZcXFwiICovXFxuXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxualF1ZXJ5LmVhY2goIFtcXG5cXHRcXFwidGFiSW5kZXhcXFwiLFxcblxcdFxcXCJyZWFkT25seVxcXCIsXFxuXFx0XFxcIm1heExlbmd0aFxcXCIsXFxuXFx0XFxcImNlbGxTcGFjaW5nXFxcIixcXG5cXHRcXFwiY2VsbFBhZGRpbmdcXFwiLFxcblxcdFxcXCJyb3dTcGFuXFxcIixcXG5cXHRcXFwiY29sU3BhblxcXCIsXFxuXFx0XFxcInVzZU1hcFxcXCIsXFxuXFx0XFxcImZyYW1lQm9yZGVyXFxcIixcXG5cXHRcXFwiY29udGVudEVkaXRhYmxlXFxcIlxcbl0sIGZ1bmN0aW9uKCkge1xcblxcdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XFxufSApO1xcblxcblxcblxcblxcblxcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcXG5cXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXFxuXFx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XFxuXFx0XFx0cmV0dXJuIHRva2Vucy5qb2luKCBcXFwiIFxcXCIgKTtcXG5cXHR9XFxuXFxuXFxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XFxuXFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiICkgfHwgXFxcIlxcXCI7XFxufVxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiB2YWx1ZSApIHtcXG5cXHRcXHRcXHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xcblxcdFxcdFxcdFxcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcXFwiIFxcXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXFxcIiBcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGN1ci5pbmRleE9mKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiApIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXIgKz0gY2xhenogKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxcblxcdFxcdFxcdFxcdFxcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiLCBmaW5hbFZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmF0dHIoIFxcXCJjbGFzc1xcXCIsIFxcXCJcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiB2YWx1ZSApIHtcXG5cXHRcXHRcXHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXFxuXFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcXFwiIFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyID0gY3VyLnJlcGxhY2UoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsIGZpbmFsVmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcXG5cXHRcXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXFxcImJvb2xlYW5cXFwiICYmIHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGVWYWxcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcXG5cXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0XFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxcblxcdFxcdFxcdFxcdFxcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcXFwiYm9vbGVhblxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGNsYXNzTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIsIGNsYXNzTmFtZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxcblxcdFxcdFxcdFxcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcXG5cXHRcXHRcXHRcXHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiXFxcIiA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIgKSB8fCBcXFwiXFxcIlxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBjbGFzc05hbWUsIGVsZW0sXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Y2xhc3NOYW1lID0gXFxcIiBcXFwiICsgc2VsZWN0b3IgKyBcXFwiIFxcXCI7XFxuXFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xcblxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdFxcdCggXFxcIiBcXFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXFxcIiBcXFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbnZhciBycmV0dXJuID0gL1xcXFxyL2c7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF07XFxuXFxuXFx0XFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0XFx0XFxcImdldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXFxcInZhbHVlXFxcIiApICkgIT09IHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldCA9IGVsZW0udmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xcblxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHJldCA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09IG51bGwgPyBcXFwiXFxcIiA6IHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0dmFyIHZhbDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24gKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcXFwiXFxcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xcblxcdFxcdFxcdGlmICggdmFsID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsICs9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFxcXCJcXFwiIDogdmFsdWUgKyBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xcblxcblxcdFxcdFxcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXFxuXFx0XFx0XFx0aWYgKCAhaG9va3MgfHwgISggXFxcInNldFxcXCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXFxcInZhbHVlXFxcIiApID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy52YWx1ZSA9IHZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHZhbEhvb2tzOiB7XFxuXFx0XFx0b3B0aW9uOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdFxcdFxcdHJldHVybiB2YWwgIT0gbnVsbCA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxcblxcdFxcdFxcdFxcdFxcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcXG5cXHRcXHRcXHRcXHRcXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNlbGVjdDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcXG5cXHRcXHRcXHRcXHRcXHRvbmUgPSBlbGVtLnR5cGUgPT09IFxcXCJzZWxlY3Qtb25lXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXFxuXFx0XFx0XFx0XFx0XFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG1heDtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBvbmUgPyBpbmRleCA6IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb24gPSBvcHRpb25zWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcXG5cXHRcXHRcXHRcXHRcXHRpID0gb3B0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcXG5cXHRcXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25TZXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XFxuXFx0XFx0XFx0XFx0aWYgKCAhb3B0aW9uU2V0ICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxcbmpRdWVyeS5lYWNoKCBbIFxcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCIgXSwgZnVuY3Rpb24oKSB7XFxuXFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XFxuXFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiICkgPT09IG51bGwgPyBcXFwib25cXFwiIDogZWxlbS52YWx1ZTtcXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxcblxcblxcbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcXG5cXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcXG5cXG5cXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcXG5cXG5cXHRcXHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxcblxcdFxcdFxcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxcblxcdFxcdFxcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFxcXCJ0eXBlXFxcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFxcXCJuYW1lc3BhY2VcXFwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFxcXCIuXFxcIiApIDogW107XFxuXFxuXFx0XFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xcblxcdFxcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZS5pbmRleE9mKCBcXFwiLlxcXCIgKSA+IC0xICkge1xcblxcblxcdFxcdFxcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXFxcIi5cXFwiICk7XFxuXFx0XFx0XFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzLnNvcnQoKTtcXG5cXHRcXHR9XFxuXFx0XFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcXFwiOlxcXCIgKSA8IDAgJiYgXFxcIm9uXFxcIiArIHR5cGU7XFxuXFxuXFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXFxuXFx0XFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0ZXZlbnQgOlxcblxcdFxcdFxcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXFxcIm9iamVjdFxcXCIgJiYgZXZlbnQgKTtcXG5cXG5cXHRcXHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXFxuXFx0XFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XFxuXFx0XFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcXFwiLlxcXCIgKTtcXG5cXHRcXHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cXG5cXHRcXHRcXHRuZXcgUmVnRXhwKCBcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIiApICsgXFxcIihcXFxcXFxcXC58JClcXFwiICkgOlxcblxcdFxcdFxcdG51bGw7XFxuXFxuXFx0XFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXFxuXFx0XFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xcblxcdFxcdGlmICggIWV2ZW50LnRhcmdldCApIHtcXG5cXHRcXHRcXHRldmVudC50YXJnZXQgPSBlbGVtO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XFxuXFx0XFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XFxuXFx0XFx0XFx0WyBldmVudCBdIDpcXG5cXHRcXHRcXHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcXG5cXG5cXHRcXHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXFxuXFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XFxuXFx0XFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcXG5cXHRcXHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XFxuXFx0XFx0XFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcXG5cXHRcXHRcXHRcXHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHR0bXAgPSBjdXI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxcblxcdFxcdFxcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcXG5cXHRcXHRpID0gMDtcXG5cXHRcXHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcblxcdFxcdFxcdGV2ZW50LnR5cGUgPSBpID4gMSA/XFxuXFx0XFx0XFx0XFx0YnViYmxlVHlwZSA6XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xcblxcblxcdFxcdFxcdC8vIGpRdWVyeSBoYW5kbGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXFxcImV2ZW50c1xcXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5nZXQoIGN1ciwgXFxcImhhbmRsZVxcXCIgKTtcXG5cXHRcXHRcXHRpZiAoIGhhbmRsZSApIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBOYXRpdmUgaGFuZGxlclxcblxcdFxcdFxcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xcblxcdFxcdFxcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcXG5cXHRcXHRcXHRcXHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xcblxcdFxcdFxcdFxcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdGV2ZW50LnR5cGUgPSB0eXBlO1xcblxcblxcdFxcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcXG5cXHRcXHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xcblxcblxcdFxcdFxcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxcblxcdFxcdFxcdFxcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXFxuXFx0XFx0XFx0XFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxcblxcdFxcdFxcdFxcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxcblxcdFxcdFxcdFxcdFxcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdG1wICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyB0eXBlIF0oKTtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdG1wICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQucmVzdWx0O1xcblxcdH0sXFxuXFxuXFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXFxuXFx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcXG5cXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xcblxcdFxcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCksXFxuXFx0XFx0XFx0ZXZlbnQsXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0aXNTaW11bGF0ZWQ6IHRydWVcXG5cXHRcXHRcXHR9XFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xcblxcdH1cXG5cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xcblxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZWFjaCggKCBcXFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXFxcIiArXFxuXFx0XFxcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFxcXCIgK1xcblxcdFxcXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XFxcIiApLnNwbGl0KCBcXFwiIFxcXCIgKSxcXG5cXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXG5cXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XFxuXFx0XFx0XFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbnN1cHBvcnQuZm9jdXNpbiA9IFxcXCJvbmZvY3VzaW5cXFwiIGluIHdpbmRvdztcXG5cXG5cXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcXG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXFxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcXG4vL1xcbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XFxuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xcblxcdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcXG5cXG5cXHRcXHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxcblxcdFxcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcXG5cXHRcXHRcXHRzZXR1cDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggIWF0dGFjaGVzICkge1xcblxcdFxcdFxcdFxcdFxcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhYXR0YWNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufVxcbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcXG5cXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XFxuXFxudmFyIHJxdWVyeSA9ICggL1xcXFw/LyApO1xcblxcblxcblxcbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcXG5cXHR2YXIgeG1sO1xcblxcdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiBudWxsO1xcblxcdH1cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxcblxcdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxcblxcdHRyeSB7XFxuXFx0XFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcXFwidGV4dC94bWxcXFwiICk7XFxuXFx0fSBjYXRjaCAoIGUgKSB7XFxuXFx0XFx0eG1sID0gdW5kZWZpbmVkO1xcblxcdH1cXG5cXG5cXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcXFwicGFyc2VyZXJyb3JcXFwiICkubGVuZ3RoICkge1xcblxcdFxcdGpRdWVyeS5lcnJvciggXFxcIkludmFsaWQgWE1MOiBcXFwiICsgZGF0YSApO1xcblxcdH1cXG5cXHRyZXR1cm4geG1sO1xcbn07XFxuXFxuXFxudmFyXFxuXFx0cmJyYWNrZXQgPSAvXFxcXFtcXFxcXSQvLFxcblxcdHJDUkxGID0gL1xcXFxyP1xcXFxuL2csXFxuXFx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxcblxcdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcXG5cXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XFxuXFx0dmFyIG5hbWU7XFxuXFxuXFx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXFxuXFx0XFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XFxuXFx0XFx0XFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXFxuXFx0XFx0XFx0XFx0YWRkKCBwcmVmaXgsIHYgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxcblxcdFxcdFxcdFxcdGJ1aWxkUGFyYW1zKFxcblxcdFxcdFxcdFxcdFxcdHByZWZpeCArIFxcXCJbXFxcIiArICggdHlwZW9mIHYgPT09IFxcXCJvYmplY3RcXFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcXFwiXFxcIiApICsgXFxcIl1cXFwiLFxcblxcdFxcdFxcdFxcdFxcdHYsXFxuXFx0XFx0XFx0XFx0XFx0dHJhZGl0aW9uYWwsXFxuXFx0XFx0XFx0XFx0XFx0YWRkXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcblxcdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cXG5cXHRcXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcXG5cXHRcXHRcXHRidWlsZFBhcmFtcyggcHJlZml4ICsgXFxcIltcXFwiICsgbmFtZSArIFxcXCJdXFxcIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXFxuXFx0XFx0YWRkKCBwcmVmaXgsIG9iaiApO1xcblxcdH1cXG59XFxuXFxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XFxuXFx0dmFyIHByZWZpeCxcXG5cXHRcXHRzID0gW10sXFxuXFx0XFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xcblxcblxcdFxcdFxcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xcblxcdFxcdFxcdFxcdHZhbHVlT3JGdW5jdGlvbigpIDpcXG5cXHRcXHRcXHRcXHR2YWx1ZU9yRnVuY3Rpb247XFxuXFxuXFx0XFx0XFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcXFwiPVxcXCIgK1xcblxcdFxcdFxcdFxcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFxcXCJcXFwiIDogdmFsdWUgKTtcXG5cXHRcXHR9O1xcblxcblxcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXFxuXFx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcXG5cXHRcXHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcXFwib2xkXFxcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcXG5cXHRcXHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cXG5cXHRcXHRmb3IgKCBwcmVmaXggaW4gYSApIHtcXG5cXHRcXHRcXHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxcblxcdHJldHVybiBzLmpvaW4oIFxcXCImXFxcIiApO1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XFxuXFx0fSxcXG5cXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcXFwiZWxlbWVudHNcXFwiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xcblxcdFxcdFxcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcXFwiZWxlbWVudHNcXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XFxuXFx0XFx0fSApXFxuXFx0XFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIC5pcyggXFxcIjpkaXNhYmxlZFxcXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcXFwiOmRpc2FibGVkXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxcblxcdFxcdFxcdFxcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcXG5cXHRcXHR9IClcXG5cXHRcXHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFxcXCJcXFxcclxcXFxuXFxcIiApIH07XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFxcXCJcXFxcclxcXFxuXFxcIiApIH07XFxuXFx0XFx0fSApLmdldCgpO1xcblxcdH1cXG59ICk7XFxuXFxuXFxudmFyXFxuXFx0cjIwID0gLyUyMC9nLFxcblxcdHJoYXNoID0gLyMuKiQvLFxcblxcdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXFxuXFx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFxcXHRdKihbXlxcXFxyXFxcXG5dKikkL21nLFxcblxcblxcdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxcblxcdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXFxuXFx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXFxuXFx0cnByb3RvY29sID0gL15cXFxcL1xcXFwvLyxcXG5cXG5cXHQvKiBQcmVmaWx0ZXJzXFxuXFx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcXG5cXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxcblxcdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcXG5cXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXFxuXFx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxcblxcdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXFxcIipcXFwiIGNhbiBiZSB1c2VkXFxuXFx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcXFwiKlxcXCIgaWYgbmVlZGVkXFxuXFx0ICovXFxuXFx0cHJlZmlsdGVycyA9IHt9LFxcblxcblxcdC8qIFRyYW5zcG9ydHMgYmluZGluZ3NcXG5cXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuXFx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcXFwiKlxcXCIgY2FuIGJlIHVzZWRcXG5cXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcXFwiKlxcXCIgaWYgbmVlZGVkXFxuXFx0ICovXFxuXFx0dHJhbnNwb3J0cyA9IHt9LFxcblxcblxcdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxcblxcdGFsbFR5cGVzID0gXFxcIiovXFxcIi5jb25jYXQoIFxcXCIqXFxcIiApLFxcblxcblxcdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxcblxcdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJhXFxcIiApO1xcblxcdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcXG5cXG4vLyBCYXNlIFxcXCJjb25zdHJ1Y3RvclxcXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xcblxcblxcdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXFxcIipcXFwiXFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xcblxcdFxcdFxcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFxcXCIqXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGRhdGFUeXBlLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XFxuXFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xcblxcblxcdFxcdFxcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cXG5cXHRcXHRcXHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFxcXCIrXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXFxcIipcXFwiO1xcblxcdFxcdFxcdFxcdFxcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBhcHBlbmRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XFxuXFxuXFx0dmFyIGluc3BlY3RlZCA9IHt9LFxcblxcdFxcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xcblxcblxcdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xcblxcdFxcdHZhciBzZWxlY3RlZDtcXG5cXHRcXHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xcblxcdFxcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XFxuXFx0XFx0XFx0XFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdFxcdHJldHVybiBzZWxlY3RlZDtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcXFwiKlxcXCIgXSAmJiBpbnNwZWN0KCBcXFwiKlxcXCIgKTtcXG59XFxuXFxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXFxuLy8gdGhhdCB0YWtlcyBcXFwiZmxhdFxcXCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXFxuLy8gRml4ZXMgIzk4ODdcXG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcXG5cXHR2YXIga2V5LCBkZWVwLFxcblxcdFxcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRmb3IgKCBrZXkgaW4gc3JjICkge1xcblxcdFxcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRpZiAoIGRlZXAgKSB7XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XFxuXFx0fVxcblxcblxcdHJldHVybiB0YXJnZXQ7XFxufVxcblxcbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcXG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxcbiAqL1xcbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XFxuXFxuXFx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxcblxcdFxcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcXG5cXHRcXHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcXG5cXG5cXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xcblxcdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFxcXCIqXFxcIiApIHtcXG5cXHRcXHRkYXRhVHlwZXMuc2hpZnQoKTtcXG5cXHRcXHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcXFwiQ29udGVudC1UeXBlXFxcIiApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXFxuXFx0aWYgKCBjdCApIHtcXG5cXHRcXHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xcblxcdFxcdFxcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcXG5cXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcXG5cXHRcXHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXFxuXFx0XFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XFxuXFx0XFx0XFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXFxcIiBcXFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcXG5cXHRcXHRcXHRcXHRmaW5hbERhdGFUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRmaXJzdERhdGFUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxcblxcdFxcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XFxuXFx0fVxcblxcblxcdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcXG5cXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxcblxcdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcXG5cXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XFxuXFx0XFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcXG5cXHRcXHRcXHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XFxuXFx0fVxcbn1cXG5cXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXFxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXFxuICovXFxuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xcblxcdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxcblxcdFxcdGNvbnZlcnRlcnMgPSB7fSxcXG5cXG5cXHRcXHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXFxuXFx0XFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcXG5cXG5cXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcXG5cXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xcblxcdFxcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xcblxcdFxcdFxcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFxuXFx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcXG5cXHR3aGlsZSAoIGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XFxuXFx0XFx0XFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXFxuXFx0XFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xcblxcdFxcdFxcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwcmV2ID0gY3VycmVudDtcXG5cXHRcXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFxuXFx0XFx0aWYgKCBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnQgPT09IFxcXCIqXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gcHJldjtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcHJldiAhPT0gXFxcIipcXFwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcXG5cXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFxcXCIgXFxcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcXFwiKiBcXFwiICsgY3VycmVudCBdO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXFxuXFx0XFx0XFx0XFx0aWYgKCAhY29udiApIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IGNvbnYyLnNwbGl0KCBcXFwiIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXFxcIiBcXFwiICsgdG1wWyAwIF0gXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnZlcnRlcnNbIFxcXCIqIFxcXCIgKyB0bXBbIDAgXSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29udiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb252ID09PSB0cnVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnQgPSB0bXBbIDAgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxcblxcdFxcdFxcdFxcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGU6IFxcXCJwYXJzZXJlcnJvclxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXJyb3I6IGNvbnYgPyBlIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgcHJldiArIFxcXCIgdG8gXFxcIiArIGN1cnJlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiB7IHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsIGRhdGE6IHJlc3BvbnNlIH07XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcXG5cXHRhY3RpdmU6IDAsXFxuXFxuXFx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxcblxcdGxhc3RNb2RpZmllZDoge30sXFxuXFx0ZXRhZzoge30sXFxuXFxuXFx0YWpheFNldHRpbmdzOiB7XFxuXFx0XFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxcblxcdFxcdHR5cGU6IFxcXCJHRVRcXFwiLFxcblxcdFxcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXFxuXFx0XFx0Z2xvYmFsOiB0cnVlLFxcblxcdFxcdHByb2Nlc3NEYXRhOiB0cnVlLFxcblxcdFxcdGFzeW5jOiB0cnVlLFxcblxcdFxcdGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIixcXG5cXG5cXHRcXHQvKlxcblxcdFxcdHRpbWVvdXQ6IDAsXFxuXFx0XFx0ZGF0YTogbnVsbCxcXG5cXHRcXHRkYXRhVHlwZTogbnVsbCxcXG5cXHRcXHR1c2VybmFtZTogbnVsbCxcXG5cXHRcXHRwYXNzd29yZDogbnVsbCxcXG5cXHRcXHRjYWNoZTogbnVsbCxcXG5cXHRcXHR0aHJvd3M6IGZhbHNlLFxcblxcdFxcdHRyYWRpdGlvbmFsOiBmYWxzZSxcXG5cXHRcXHRoZWFkZXJzOiB7fSxcXG5cXHRcXHQqL1xcblxcblxcdFxcdGFjY2VwdHM6IHtcXG5cXHRcXHRcXHRcXFwiKlxcXCI6IGFsbFR5cGVzLFxcblxcdFxcdFxcdHRleHQ6IFxcXCJ0ZXh0L3BsYWluXFxcIixcXG5cXHRcXHRcXHRodG1sOiBcXFwidGV4dC9odG1sXFxcIixcXG5cXHRcXHRcXHR4bWw6IFxcXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXFxcIixcXG5cXHRcXHRcXHRqc29uOiBcXFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udGVudHM6IHtcXG5cXHRcXHRcXHR4bWw6IC9cXFxcYnhtbFxcXFxiLyxcXG5cXHRcXHRcXHRodG1sOiAvXFxcXGJodG1sLyxcXG5cXHRcXHRcXHRqc29uOiAvXFxcXGJqc29uXFxcXGIvXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXNwb25zZUZpZWxkczoge1xcblxcdFxcdFxcdHhtbDogXFxcInJlc3BvbnNlWE1MXFxcIixcXG5cXHRcXHRcXHR0ZXh0OiBcXFwicmVzcG9uc2VUZXh0XFxcIixcXG5cXHRcXHRcXHRqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXFxuXFx0XFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFxcXCIqXFxcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcXG5cXHRcXHRjb252ZXJ0ZXJzOiB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XFxuXFx0XFx0XFx0XFxcIiogdGV4dFxcXCI6IFN0cmluZyxcXG5cXG5cXHRcXHRcXHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcXG5cXHRcXHRcXHRcXFwidGV4dCBodG1sXFxcIjogdHJ1ZSxcXG5cXG5cXHRcXHRcXHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXFxuXFx0XFx0XFx0XFxcInRleHQganNvblxcXCI6IEpTT04ucGFyc2UsXFxuXFxuXFx0XFx0XFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcXG5cXHRcXHRcXHRcXFwidGV4dCB4bWxcXFwiOiBqUXVlcnkucGFyc2VYTUxcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XFxuXFx0XFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxcblxcdFxcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXFxuXFx0XFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXFxuXFx0XFx0ZmxhdE9wdGlvbnM6IHtcXG5cXHRcXHRcXHR1cmw6IHRydWUsXFxuXFx0XFx0XFx0Y29udGV4dDogdHJ1ZVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XFxuXFx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxcblxcdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXFxuXFx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcXG5cXHRcXHRyZXR1cm4gc2V0dGluZ3MgP1xcblxcblxcdFxcdFxcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XFxuXFx0XFx0XFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxcblxcblxcdFxcdFxcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3NcXG5cXHRcXHRcXHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcXG5cXHR9LFxcblxcblxcdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxcblxcdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxcblxcblxcdC8vIE1haW4gbWV0aG9kXFxuXFx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxcblxcdFxcdGlmICggdHlwZW9mIHVybCA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0XFx0b3B0aW9ucyA9IHVybDtcXG5cXHRcXHRcXHR1cmwgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XFxuXFx0XFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuXFx0XFx0dmFyIHRyYW5zcG9ydCxcXG5cXG5cXHRcXHRcXHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXFxuXFx0XFx0XFx0Y2FjaGVVUkwsXFxuXFxuXFx0XFx0XFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xcblxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcXG5cXHRcXHRcXHRyZXNwb25zZUhlYWRlcnMsXFxuXFxuXFx0XFx0XFx0Ly8gdGltZW91dCBoYW5kbGVcXG5cXHRcXHRcXHR0aW1lb3V0VGltZXIsXFxuXFxuXFx0XFx0XFx0Ly8gVXJsIGNsZWFudXAgdmFyXFxuXFx0XFx0XFx0dXJsQW5jaG9yLFxcblxcblxcdFxcdFxcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcXG5cXHRcXHRcXHRjb21wbGV0ZWQsXFxuXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXFxuXFx0XFx0XFx0ZmlyZUdsb2JhbHMsXFxuXFxuXFx0XFx0XFx0Ly8gTG9vcCB2YXJpYWJsZVxcblxcdFxcdFxcdGksXFxuXFxuXFx0XFx0XFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXFxuXFx0XFx0XFx0dW5jYWNoZWQsXFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxcblxcdFxcdFxcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxcblxcblxcdFxcdFxcdC8vIENhbGxiYWNrcyBjb250ZXh0XFxuXFx0XFx0XFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXFxuXFxuXFx0XFx0XFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxcblxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxcblxcdFxcdFxcdFxcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LFxcblxcblxcdFxcdFxcdC8vIERlZmVycmVkc1xcblxcdFxcdFxcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFx0XFx0XFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXG5cXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXFxuXFxuXFx0XFx0XFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcXG5cXHRcXHRcXHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxcblxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcXG5cXG5cXHRcXHRcXHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcXG5cXHRcXHRcXHRzdHJBYm9ydCA9IFxcXCJjYW5jZWxlZFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gRmFrZSB4aHJcXG5cXHRcXHRcXHRqcVhIUiA9IHtcXG5cXHRcXHRcXHRcXHRyZWFkeVN0YXRlOiAwLFxcblxcblxcdFxcdFxcdFxcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcXG5cXHRcXHRcXHRcXHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF0Y2g7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBSYXcgc3RyaW5nXFxuXFx0XFx0XFx0XFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIENhY2hlcyB0aGUgaGVhZGVyXFxuXFx0XFx0XFx0XFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxcblxcdFxcdFxcdFxcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5taW1lVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG5cXHRcXHRcXHRcXHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjb2RlO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBjb2RlIGluIG1hcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxcblxcdFxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRyYW5zcG9ydCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRkb25lKCAwLCBmaW5hbFRleHQgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBBdHRhY2ggZGVmZXJyZWRzXFxuXFx0XFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcXG5cXHRcXHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxcblxcdFxcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxcblxcdFxcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcXFwiXFxcIiApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcXFwiLy9cXFwiICk7XFxuXFxuXFx0XFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XFxuXFx0XFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcXG5cXG5cXHRcXHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XFxuXFx0XFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXFxcIipcXFwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXG5cXHRcXHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cXG5cXHRcXHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiYVxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXFxuXFx0XFx0XFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcXG5cXHRcXHRcXHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxcblxcdFxcdFxcdFxcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XFxuXFx0XFx0XFx0XFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cXG5cXHRcXHRcXHRcXHRcXHR1cmxBbmNob3IucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgdXJsQW5jaG9yLmhvc3Q7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXFxuXFx0XFx0XFx0XFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxcblxcdFxcdFxcdFxcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXFxuXFx0XFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSBwcmVmaWx0ZXJzXFxuXFx0XFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XFxuXFxuXFx0XFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcXG5cXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRyZXR1cm4ganFYSFI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXFxuXFx0XFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcXG5cXHRcXHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcXG5cXG5cXHRcXHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXFxuXFx0XFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFxcXCJhamF4U3RhcnRcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxcblxcdFxcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xcblxcblxcdFxcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XFxuXFx0XFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XFxuXFxuXFx0XFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXFxuXFx0XFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXFxuXFx0XFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxcblxcdFxcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcXG5cXHRcXHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXFxuXFx0XFx0XFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxcblxcdFxcdFxcdGlmICggcy5kYXRhICkge1xcblxcdFxcdFxcdFxcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIHMuZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHMuZGF0YTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxcblxcdFxcdFxcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcXFwiJDFcXFwiICk7XFxuXFx0XFx0XFx0XFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiICkgKyBcXFwiXz1cXFwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxcblxcdFxcdFxcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcXG5cXG5cXHRcXHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcXG5cXHRcXHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxcblxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApLmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXFxcIitcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcXG5cXHRcXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiSWYtTm9uZS1NYXRjaFxcXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcXG5cXHRcXHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcXG5cXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiQ29udGVudC1UeXBlXFxcIiwgcy5jb250ZW50VHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXFxuXFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcXG5cXHRcXHRcXHRcXFwiQWNjZXB0XFxcIixcXG5cXHRcXHRcXHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cXG5cXHRcXHRcXHRcXHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXFxuXFx0XFx0XFx0XFx0XFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcXFwiKlxcXCIgPyBcXFwiLCBcXFwiICsgYWxsVHlwZXMgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIgKSA6XFxuXFx0XFx0XFx0XFx0cy5hY2NlcHRzWyBcXFwiKlxcXCIgXVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXFxuXFx0XFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxcblxcdFxcdGlmICggcy5iZWZvcmVTZW5kICYmXFxuXFx0XFx0XFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cXG5cXHRcXHRcXHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXFxuXFx0XFx0c3RyQWJvcnQgPSBcXFwiYWJvcnRcXFwiO1xcblxcblxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xcblxcdFxcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XFxuXFx0XFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XFxuXFx0XFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xcblxcblxcdFxcdC8vIEdldCB0cmFuc3BvcnRcXG5cXHRcXHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcXG5cXHRcXHRpZiAoICF0cmFuc3BvcnQgKSB7XFxuXFx0XFx0XFx0ZG9uZSggLTEsIFxcXCJObyBUcmFuc3BvcnRcXFwiICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcXG5cXG5cXHRcXHRcXHQvLyBTZW5kIGdsb2JhbCBldmVudFxcblxcdFxcdFxcdGlmICggZmlyZUdsb2JhbHMgKSB7XFxuXFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFxcXCJhamF4U2VuZFxcXCIsIFsganFYSFIsIHMgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxcblxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGltZW91dFxcblxcdFxcdFxcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xcblxcdFxcdFxcdFxcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRqcVhIUi5hYm9ydCggXFxcInRpbWVvdXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0fSwgcy50aW1lb3V0ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0Y29tcGxldGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xcblxcdFxcdFxcdFxcdGRvbmUoIC0xLCBlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcXG5cXHRcXHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcXG5cXHRcXHRcXHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxcblxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xcblxcblxcdFxcdFxcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcXG5cXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvbXBsZXRlZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcXG5cXHRcXHRcXHRpZiAoIHRpbWVvdXRUaW1lciApIHtcXG5cXHRcXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cXG5cXHRcXHRcXHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxcblxcdFxcdFxcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgcmVhZHlTdGF0ZVxcblxcdFxcdFxcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcXG5cXHRcXHRcXHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcXG5cXG5cXHRcXHRcXHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxcblxcdFxcdFxcdGlmICggcmVzcG9uc2VzICkge1xcblxcdFxcdFxcdFxcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXFxuXFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0XFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcIkxhc3QtTW9kaWZpZWRcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb2RpZmllZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFxcXCJldGFnXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGlmIG5vIGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXFxcIkhFQURcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwibm9jb250ZW50XFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBub3QgbW9kaWZpZWRcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcIm5vdG1vZGlmaWVkXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcXG5cXHRcXHRcXHRcXHRcXHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xcblxcdFxcdFxcdFxcdFxcdGlzU3VjY2VzcyA9ICFlcnJvcjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXFxuXFx0XFx0XFx0XFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xcblxcdFxcdFxcdFxcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwiZXJyb3JcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmICggc3RhdHVzIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xcblxcdFxcdFxcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VjY2Vzcy9FcnJvclxcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xcblxcdFxcdFxcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBmaXJlR2xvYmFscyApIHtcXG5cXHRcXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbXBsZXRlXFxuXFx0XFx0XFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGZpcmVHbG9iYWxzICkge1xcblxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcXFwiYWpheENvbXBsZXRlXFxcIiwgWyBqcVhIUiwgcyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXFxuXFx0XFx0XFx0XFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXFxcImFqYXhTdG9wXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHR9LFxcblxcblxcdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcXFwianNvblxcXCIgKTtcXG5cXHR9LFxcblxcblxcdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXFxcInNjcmlwdFxcXCIgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJnZXRcXFwiLCBcXFwicG9zdFxcXCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcXG5cXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XFxuXFxuXFx0XFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcXG5cXHRcXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XFxuXFx0XFx0XFx0Y2FsbGJhY2sgPSBkYXRhO1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxcblxcdFxcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdHVybDogdXJsLFxcblxcdFxcdFxcdHR5cGU6IG1ldGhvZCxcXG5cXHRcXHRcXHRkYXRhVHlwZTogdHlwZSxcXG5cXHRcXHRcXHRkYXRhOiBkYXRhLFxcblxcdFxcdFxcdHN1Y2Nlc3M6IGNhbGxiYWNrXFxuXFx0XFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcXG5cXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcXG5cXHRcXHR1cmw6IHVybCxcXG5cXG5cXHRcXHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcXG5cXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsXFxuXFx0XFx0Y2FjaGU6IHRydWUsXFxuXFx0XFx0YXN5bmM6IGZhbHNlLFxcblxcdFxcdGdsb2JhbDogZmFsc2UsXFxuXFx0XFx0XFxcInRocm93c1xcXCI6IHRydWVcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0dmFyIHdyYXA7XFxuXFxuXFx0XFx0aWYgKCB0aGlzWyAwIF0gKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xcblxcdFxcdFxcdFxcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxcblxcdFxcdFxcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xcblxcblxcdFxcdFxcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0gPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0XFx0XFx0fSApLmFwcGVuZCggdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXFxuXFx0XFx0XFx0XFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFxcXCJib2R5XFxcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XFxufTtcXG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcXG5cXHR0cnkge1xcblxcdFxcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XFxuXFx0fSBjYXRjaCAoIGUgKSB7fVxcbn07XFxuXFxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XFxuXFxuXFx0XFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcXG5cXHRcXHQwOiAyMDAsXFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcXG5cXHRcXHQxMjIzOiAyMDRcXG5cXHR9LFxcblxcdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XFxuXFxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcXFwid2l0aENyZWRlbnRpYWxzXFxcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcXG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcXG5cXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XFxuXFx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xcblxcblxcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcXG5cXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0XFx0XFx0eGhyID0gb3B0aW9ucy54aHIoKTtcXG5cXG5cXHRcXHRcXHRcXHR4aHIub3BlbihcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy51cmwsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5hc3luYyxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnVzZXJuYW1lLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMucGFzc3dvcmRcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxcblxcdFxcdFxcdFxcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcXG5cXHRcXHRcXHRcXHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxcblxcdFxcdFxcdFxcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxcblxcdFxcdFxcdFxcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxcblxcdFxcdFxcdFxcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIiBdICkge1xcblxcdFxcdFxcdFxcdFxcdGhlYWRlcnNbIFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIiBdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IGhlYWRlcnNcXG5cXHRcXHRcXHRcXHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWxsYmFja1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcImFib3J0XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB0eXBlID09PSBcXFwiZXJyb3JcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKCAwLCBcXFwiZXJyb3JcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZShcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5zdGF0dXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1c1RleHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5zdGF0dXNUZXh0LFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFxcXCJ0ZXh0XFxcIiApICE9PSBcXFwidGV4dFxcXCIgIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFxcXCJzdHJpbmdcXFwiID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xcblxcdFxcdFxcdFxcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcXFwiZXJyb3JcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcXG5cXHRcXHRcXHRcXHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXFxuXFx0XFx0XFx0XFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXJyb3JDYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcXFwiYWJvcnRcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXFxuXFx0XFx0XFx0XFx0XFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcXG5qUXVlcnkuYWpheFNldHVwKCB7XFxuXFx0YWNjZXB0czoge1xcblxcdFxcdHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXFxcIiArXFxuXFx0XFx0XFx0XFxcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCJcXG5cXHR9LFxcblxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0c2NyaXB0OiAvXFxcXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxcXGIvXFxuXFx0fSxcXG5cXHRjb252ZXJ0ZXJzOiB7XFxuXFx0XFx0XFxcInRleHQgc2NyaXB0XFxcIjogZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dDtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiggcyApIHtcXG5cXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRzLmNhY2hlID0gZmFsc2U7XFxuXFx0fVxcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLnR5cGUgPSBcXFwiR0VUXFxcIjtcXG5cXHR9XFxufSApO1xcblxcbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24oIHMgKSB7XFxuXFxuXFx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcXG5cXHRcXHRcXHRcXHRzY3JpcHQgPSBqUXVlcnkoIFxcXCI8c2NyaXB0PlxcXCIgKS5wcm9wKCB7XFxuXFx0XFx0XFx0XFx0XFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxcblxcdFxcdFxcdFxcdFxcdHNyYzogcy51cmxcXG5cXHRcXHRcXHRcXHR9ICkub24oXFxuXFx0XFx0XFx0XFx0XFx0XFxcImxvYWQgZXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JpcHQucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZXZ0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXFxcImVycm9yXFxcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XFxuXFx0XFx0XFx0XFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxcblxcdHJqc29ucCA9IC8oPSlcXFxcPyg/PSZ8JCl8XFxcXD9cXFxcPy87XFxuXFxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xcbmpRdWVyeS5hamF4U2V0dXAoIHtcXG5cXHRqc29ucDogXFxcImNhbGxiYWNrXFxcIixcXG5cXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFxcXCJfXFxcIiArICggbm9uY2UrKyApICk7XFxuXFx0XFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XFxuXFx0XFx0cmV0dXJuIGNhbGxiYWNrO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xcblxcblxcdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcXG5cXHRcXHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xcblxcdFxcdFxcdFxcXCJ1cmxcXFwiIDpcXG5cXHRcXHRcXHR0eXBlb2Ygcy5kYXRhID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApXFxuXFx0XFx0XFx0XFx0XFx0LmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgJiZcXG5cXHRcXHRcXHRcXHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXFxcImRhdGFcXFwiXFxuXFx0XFx0KTtcXG5cXG5cXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXFxcImpzb25wXFxcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxcblxcdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXFxcImpzb25wXFxcIiApIHtcXG5cXG5cXHRcXHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XFxuXFx0XFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cXG5cXHRcXHRcXHRzLmpzb25wQ2FsbGJhY2soKSA6XFxuXFx0XFx0XFx0cy5qc29ucENhbGxiYWNrO1xcblxcblxcdFxcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcXG5cXHRcXHRpZiAoIGpzb25Qcm9wICkge1xcblxcdFxcdFxcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXFxcIiQxXFxcIiArIGNhbGxiYWNrTmFtZSApO1xcblxcdFxcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xcblxcdFxcdFxcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIHMuanNvbnAgKyBcXFwiPVxcXCIgKyBjYWxsYmFja05hbWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cXG5cXHRcXHRzLmNvbnZlcnRlcnNbIFxcXCJzY3JpcHQganNvblxcXCIgXSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXFxcIiB3YXMgbm90IGNhbGxlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXFxuXFx0XFx0cy5kYXRhVHlwZXNbIDAgXSA9IFxcXCJqc29uXFxcIjtcXG5cXG5cXHRcXHQvLyBJbnN0YWxsIGNhbGxiYWNrXFxuXFx0XFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xcblxcdFxcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxcblxcdFxcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XFxuXFx0XFx0XFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcXG5cXHRcXHRcXHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xcblxcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxcblxcdFxcdFxcdFxcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcXG5cXG5cXHRcXHRcXHRcXHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXFxuXFx0XFx0XFx0XFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcXG5cXHRcXHRcXHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xcblxcdFxcdFxcdFxcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XFxuXFx0XFx0fSApO1xcblxcblxcdFxcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxcblxcdFxcdHJldHVybiBcXFwic2NyaXB0XFxcIjtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcXG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXFxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4Llxcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcXG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFxcXCJcXFwiICkuYm9keTtcXG5cXHRib2R5LmlubmVySFRNTCA9IFxcXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlxcXCI7XFxuXFx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XFxufSApKCk7XFxuXFxuXFxuLy8gQXJndW1lbnQgXFxcImRhdGFcXFwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xcblxcdGlmICggdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiBbXTtcXG5cXHR9XFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcXG5cXHRcXHRjb250ZXh0ID0gZmFsc2U7XFxuXFx0fVxcblxcblxcdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XFxuXFxuXFx0aWYgKCAhY29udGV4dCApIHtcXG5cXG5cXHRcXHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcXG5cXHRcXHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxcblxcdFxcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcXG5cXHRcXHRcXHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xcblxcdFxcdFxcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXFxuXFx0XFx0XFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXFxcImJhc2VcXFwiICk7XFxuXFx0XFx0XFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcXG5cXHRcXHRcXHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNvbnRleHQgPSBkb2N1bWVudDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xcblxcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XFxuXFxuXFx0Ly8gU2luZ2xlIHRhZ1xcblxcdGlmICggcGFyc2VkICkge1xcblxcdFxcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xcblxcdH1cXG5cXG5cXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xcblxcblxcdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcXG5cXHRcXHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XFxufTtcXG5cXG5cXG4vKipcXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXFxuICovXFxualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xcblxcdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXFxuXFx0XFx0c2VsZiA9IHRoaXMsXFxuXFx0XFx0b2ZmID0gdXJsLmluZGV4T2YoIFxcXCIgXFxcIiApO1xcblxcblxcdGlmICggb2ZmID4gLTEgKSB7XFxuXFx0XFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XFxuXFx0XFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXFxuXFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XFxuXFxuXFx0XFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcXG5cXHRcXHRjYWxsYmFjayA9IHBhcmFtcztcXG5cXHRcXHRwYXJhbXMgPSB1bmRlZmluZWQ7XFxuXFxuXFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xcblxcdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHR0eXBlID0gXFxcIlBPU1RcXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxcblxcdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xcblxcdFxcdGpRdWVyeS5hamF4KCB7XFxuXFx0XFx0XFx0dXJsOiB1cmwsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgXFxcInR5cGVcXFwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcXFwiR0VUXFxcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxcblxcdFxcdFxcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxcblxcdFxcdFxcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxcblxcdFxcdFxcdHR5cGU6IHR5cGUgfHwgXFxcIkdFVFxcXCIsXFxuXFx0XFx0XFx0ZGF0YVR5cGU6IFxcXCJodG1sXFxcIixcXG5cXHRcXHRcXHRkYXRhOiBwYXJhbXNcXG5cXHRcXHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcXG5cXG5cXHRcXHRcXHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcXG5cXHRcXHRcXHRyZXNwb25zZSA9IGFyZ3VtZW50cztcXG5cXG5cXHRcXHRcXHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIFxcXCI8ZGl2PlxcXCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcXG5cXHRcXHRcXHRcXHRyZXNwb25zZVRleHQgKTtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFxcXCJkYXRhXFxcIiwgXFxcInN0YXR1c1xcXCIsIFxcXCJqcVhIUlxcXCJcXG5cXHRcXHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXFxuXFx0XFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcXFwianFYSFJcXFwiLCBcXFwic3RhdHVzXFxcIiwgXFxcImVycm9yXFxcIlxcblxcdFxcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xcblxcdFxcdFxcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcblxcblxcblxcbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXFxualF1ZXJ5LmVhY2goIFtcXG5cXHRcXFwiYWpheFN0YXJ0XFxcIixcXG5cXHRcXFwiYWpheFN0b3BcXFwiLFxcblxcdFxcXCJhamF4Q29tcGxldGVcXFwiLFxcblxcdFxcXCJhamF4RXJyb3JcXFwiLFxcblxcdFxcXCJhamF4U3VjY2Vzc1xcXCIsXFxuXFx0XFxcImFqYXhTZW5kXFxcIlxcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xcblxcdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xcblxcdH07XFxufSApO1xcblxcblxcblxcblxcbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcXG5cXHR9ICkubGVuZ3RoO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcXG4gKi9cXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XFxuXFx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0VmlldztcXG59XFxuXFxualF1ZXJ5Lm9mZnNldCA9IHtcXG5cXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xcblxcdFxcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICksXFxuXFx0XFx0XFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxcblxcdFxcdFxcdHByb3BzID0ge307XFxuXFxuXFx0XFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxcblxcdFxcdGlmICggcG9zaXRpb24gPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcdFxcdFxcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xcblxcdFxcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJ0b3BcXFwiICk7XFxuXFx0XFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJsZWZ0XFxcIiApO1xcblxcdFxcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiApICYmXFxuXFx0XFx0XFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXFxcImF1dG9cXFwiICkgPiAtMTtcXG5cXG5cXHRcXHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxcblxcdFxcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxcblxcdFxcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XFxuXFx0XFx0XFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xcblxcdFxcdFxcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcXG5cXHRcXHRcXHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcXG5cXHRcXHRcXHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xcblxcdFxcdFxcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggXFxcInVzaW5nXFxcIiBpbiBvcHRpb25zICkge1xcblxcdFxcdFxcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXG5cXHRcXHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXFxuXFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdHRoaXMgOlxcblxcdFxcdFxcdFxcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYyxcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdO1xcblxcblxcdFxcdGlmICggIWVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHRcXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXFxuXFx0XFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXFxuXFx0XFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcXG5cXHRcXHRpZiAoIHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQgKSB7XFxuXFx0XFx0XFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xcblxcdFxcdFxcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XFxuXFx0XFx0XFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXFxuXFx0XFx0XFx0XFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoZ2gtMjMxMClcXG5cXHRcXHRyZXR1cm4gcmVjdDtcXG5cXHR9LFxcblxcblxcdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoICF0aGlzWyAwIF0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXSxcXG5cXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcblxcdFxcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXFxuXFx0XFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XFxuXFx0XFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJmaXhlZFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXFxuXFx0XFx0XFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XFxuXFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcXG5cXG5cXHRcXHRcXHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXFxuXFx0XFx0XFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcXG5cXHRcXHRcXHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcXFwiaHRtbFxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xcblxcdFxcdFxcdHBhcmVudE9mZnNldCA9IHtcXG5cXHRcXHRcXHRcXHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgdHJ1ZSApLFxcblxcdFxcdFxcdFxcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCB0cnVlIClcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXFxcIm1hcmdpblRvcFxcXCIsIHRydWUgKSxcXG5cXHRcXHRcXHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXFxcIm1hcmdpbkxlZnRcXFwiLCB0cnVlIClcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFxuXFx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XFxuXFx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxcblxcdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xcblxcdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcXG5cXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXFxuXFx0Ly9cXG5cXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcXG5cXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cXG5cXHQvL1xcblxcdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXFxuXFx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFxcXCJwb3NpdGlvblxcXCIgKSA9PT0gXFxcInN0YXRpY1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXFxualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXFxcInBhZ2VYT2Zmc2V0XFxcIiwgc2Nyb2xsVG9wOiBcXFwicGFnZVlPZmZzZXRcXFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XFxuXFx0dmFyIHRvcCA9IFxcXCJwYWdlWU9mZnNldFxcXCIgPT09IHByb3A7XFxuXFxuXFx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xcblxcdFxcdFxcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHdpbiApIHtcXG5cXHRcXHRcXHRcXHR3aW4uc2Nyb2xsVG8oXFxuXFx0XFx0XFx0XFx0XFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcXG5cXHRcXHRcXHRcXHRcXHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXFxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXFxualF1ZXJ5LmVhY2goIFsgXFxcInRvcFxcXCIsIFxcXCJsZWZ0XFxcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRpZiAoIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdFxcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcXFwicHhcXFwiIDpcXG5cXHRcXHRcXHRcXHRcXHRjb21wdXRlZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdCk7XFxufSApO1xcblxcblxcbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xcblxcdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIG5hbWUgfSxcXG5cXHRcXHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcXG5cXG5cXHRcXHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcXG5cXHRcXHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcXFwiYm9vbGVhblxcXCIgKSxcXG5cXHRcXHRcXHRcXHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvYztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFxcXCJvdXRlclxcXCIgKSA9PT0gMCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVsgXFxcImlubmVyXFxcIiArIG5hbWUgXSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFxcXCJjbGllbnRcXFwiICsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gTWF0aC5tYXgoXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5ib2R5WyBcXFwic2Nyb2xsXFxcIiArIG5hbWUgXSwgZG9jWyBcXFwic2Nyb2xsXFxcIiArIG5hbWUgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmJvZHlbIFxcXCJvZmZzZXRcXFwiICsgbmFtZSBdLCBkb2NbIFxcXCJvZmZzZXRcXFwiICsgbmFtZSBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRvY1sgXFxcImNsaWVudFxcXCIgKyBuYW1lIF1cXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xcblxcdFxcdFxcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufSApO1xcblxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xcblxcdH0sXFxuXFxuXFx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XFxuXFx0fSxcXG5cXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcXG5cXG5cXHRcXHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXFxuXFx0XFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xcblxcdFxcdFxcdHRoaXMub2ZmKCBzZWxlY3RvciwgXFxcIioqXFxcIiApIDpcXG5cXHRcXHRcXHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFxcXCIqKlxcXCIsIGZuICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcXG5cXG5cXG5cXG5cXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cXG5cXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cXG5cXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCApIHtcXG5cXHRkZWZpbmUoIFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeTtcXG5cXHR9ICk7XFxufVxcblxcblxcblxcblxcbnZhclxcblxcblxcdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcblxcdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxcblxcblxcdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXFxuXFx0XyQgPSB3aW5kb3cuJDtcXG5cXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xcblxcdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcXG5cXHRcXHR3aW5kb3cuJCA9IF8kO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xcblxcdFxcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xcblxcdH1cXG5cXG5cXHRyZXR1cm4galF1ZXJ5O1xcbn07XFxuXFxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXFxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxcbmlmICggIW5vR2xvYmFsICkge1xcblxcdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcXG59XFxuXFxuXFxuXFxuXFxuXFxucmV0dXJuIGpRdWVyeTtcXG59ICk7XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gKiB3aGF0LWlucHV0IC0gQSBnbG9iYWwgdXRpbGl0eSBmb3IgdHJhY2tpbmcgdGhlIGN1cnJlbnQgaW5wdXQgbWV0aG9kIChtb3VzZSwga2V5Ym9hcmQgb3IgdG91Y2gpLlxcbiAqIEB2ZXJzaW9uIHY0LjAuNFxcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW4xc2V2ZW4vd2hhdC1pbnB1dFxcbiAqIEBsaWNlbnNlIE1JVFxcbiAqL1xcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xcblxcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxcblxcdFxcdGRlZmluZShcXFwid2hhdElucHV0XFxcIiwgW10sIGZhY3RvcnkpO1xcblxcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxcblxcdFxcdGV4cG9ydHNbXFxcIndoYXRJbnB1dFxcXCJdID0gZmFjdG9yeSgpO1xcblxcdGVsc2VcXG5cXHRcXHRyb290W1xcXCJ3aGF0SW5wdXRcXFwiXSA9IGZhY3RvcnkoKTtcXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcbi8qKioqKiovIFxcdC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcblxcbi8qKioqKiovIFxcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9LFxcbi8qKioqKiovIFxcdFxcdFxcdGlkOiBtb2R1bGVJZCxcXG4vKioqKioqLyBcXHRcXHRcXHRsb2FkZWQ6IGZhbHNlXFxuLyoqKioqKi8gXFx0XFx0fTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0fVxcblxcblxcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiXFxcIjtcXG5cXG4vKioqKioqLyBcXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcXG4vKioqKioqLyBcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKioqKioqLyB9KVxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKi8gKFtcXG4vKiAwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAvKlxcblxcdCAgICAtLS0tLS0tLS0tLS0tLS1cXG5cXHQgICAgVmFyaWFibGVzXFxuXFx0ICAgIC0tLS0tLS0tLS0tLS0tLVxcblxcdCAgKi9cXG5cXG5cXHQgIC8vIGNhY2hlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxcblxcdCAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFx0ICAvLyBsYXN0IHVzZWQgaW5wdXQgdHlwZVxcblxcdCAgdmFyIGN1cnJlbnRJbnB1dCA9ICdpbml0aWFsJztcXG5cXG5cXHQgIC8vIGxhc3QgdXNlZCBpbnB1dCBpbnRlbnRcXG5cXHQgIHZhciBjdXJyZW50SW50ZW50ID0gbnVsbDtcXG5cXG5cXHQgIC8vIGZvcm0gaW5wdXQgdHlwZXNcXG5cXHQgIHZhciBmb3JtSW5wdXRzID0gW1xcblxcdCAgICAnaW5wdXQnLFxcblxcdCAgICAnc2VsZWN0JyxcXG5cXHQgICAgJ3RleHRhcmVhJ1xcblxcdCAgXTtcXG5cXG5cXHQgIC8vIGxpc3Qgb2YgbW9kaWZpZXIga2V5cyBjb21tb25seSB1c2VkIHdpdGggdGhlIG1vdXNlIGFuZFxcblxcdCAgLy8gY2FuIGJlIHNhZmVseSBpZ25vcmVkIHRvIHByZXZlbnQgZmFsc2Uga2V5Ym9hcmQgZGV0ZWN0aW9uXFxuXFx0ICB2YXIgaWdub3JlTWFwID0gW1xcblxcdCAgICAxNiwgLy8gc2hpZnRcXG5cXHQgICAgMTcsIC8vIGNvbnRyb2xcXG5cXHQgICAgMTgsIC8vIGFsdFxcblxcdCAgICA5MSwgLy8gV2luZG93cyBrZXkgLyBsZWZ0IEFwcGxlIGNtZFxcblxcdCAgICA5MyAgLy8gV2luZG93cyBtZW51IC8gcmlnaHQgQXBwbGUgY21kXFxuXFx0ICBdO1xcblxcblxcdCAgLy8gbWFwcGluZyBvZiBldmVudHMgdG8gaW5wdXQgdHlwZXNcXG5cXHQgIHZhciBpbnB1dE1hcCA9IHtcXG5cXHQgICAgJ2tleXVwJzogJ2tleWJvYXJkJyxcXG5cXHQgICAgJ21vdXNlZG93bic6ICdtb3VzZScsXFxuXFx0ICAgICdtb3VzZW1vdmUnOiAnbW91c2UnLFxcblxcdCAgICAnTVNQb2ludGVyRG93bic6ICdwb2ludGVyJyxcXG5cXHQgICAgJ01TUG9pbnRlck1vdmUnOiAncG9pbnRlcicsXFxuXFx0ICAgICdwb2ludGVyZG93bic6ICdwb2ludGVyJyxcXG5cXHQgICAgJ3BvaW50ZXJtb3ZlJzogJ3BvaW50ZXInLFxcblxcdCAgICAndG91Y2hzdGFydCc6ICd0b3VjaCdcXG5cXHQgIH07XFxuXFxuXFx0ICAvLyBhcnJheSBvZiBhbGwgdXNlZCBpbnB1dCB0eXBlc1xcblxcdCAgdmFyIGlucHV0VHlwZXMgPSBbXTtcXG5cXG5cXHQgIC8vIGJvb2xlYW46IHRydWUgaWYgdG91Y2ggYnVmZmVyIHRpbWVyIGlzIHJ1bm5pbmdcXG5cXHQgIHZhciBpc0J1ZmZlcmluZyA9IGZhbHNlO1xcblxcblxcdCAgLy8gbWFwIG9mIElFIDEwIHBvaW50ZXIgZXZlbnRzXFxuXFx0ICB2YXIgcG9pbnRlck1hcCA9IHtcXG5cXHQgICAgMjogJ3RvdWNoJyxcXG5cXHQgICAgMzogJ3RvdWNoJywgLy8gdHJlYXQgcGVuIGxpa2UgdG91Y2hcXG5cXHQgICAgNDogJ21vdXNlJ1xcblxcdCAgfTtcXG5cXG5cXHQgIC8vIHRvdWNoIGJ1ZmZlciB0aW1lclxcblxcdCAgdmFyIHRvdWNoVGltZXIgPSBudWxsO1xcblxcblxcblxcdCAgLypcXG5cXHQgICAgLS0tLS0tLS0tLS0tLS0tXFxuXFx0ICAgIFNldCB1cFxcblxcdCAgICAtLS0tLS0tLS0tLS0tLS1cXG5cXHQgICovXFxuXFxuXFx0ICB2YXIgc2V0VXAgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgLy8gYWRkIGNvcnJlY3QgbW91c2Ugd2hlZWwgZXZlbnQgbWFwcGluZyB0byBgaW5wdXRNYXBgXFxuXFx0ICAgIGlucHV0TWFwW2RldGVjdFdoZWVsKCldID0gJ21vdXNlJztcXG5cXG5cXHQgICAgYWRkTGlzdGVuZXJzKCk7XFxuXFx0ICAgIHNldElucHV0KCk7XFxuXFx0ICB9O1xcblxcblxcblxcdCAgLypcXG5cXHQgICAgLS0tLS0tLS0tLS0tLS0tXFxuXFx0ICAgIEV2ZW50c1xcblxcdCAgICAtLS0tLS0tLS0tLS0tLS1cXG5cXHQgICovXFxuXFxuXFx0ICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIC8vIGBwb2ludGVybW92ZWAsIGBNU1BvaW50ZXJNb3ZlYCwgYG1vdXNlbW92ZWAgYW5kIG1vdXNlIHdoZWVsIGV2ZW50IGJpbmRpbmdcXG5cXHQgICAgLy8gY2FuIG9ubHkgZGVtb25zdHJhdGUgcG90ZW50aWFsLCBidXQgbm90IGFjdHVhbCwgaW50ZXJhY3Rpb25cXG5cXHQgICAgLy8gYW5kIGFyZSB0cmVhdGVkIHNlcGFyYXRlbHlcXG5cXG5cXHQgICAgLy8gcG9pbnRlciBldmVudHMgKG1vdXNlLCBwZW4sIHRvdWNoKVxcblxcdCAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xcblxcdCAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHNldEludGVudCk7XFxuXFx0ICAgIH0gZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XFxuXFx0ICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdXBkYXRlSW5wdXQpO1xcblxcdCAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHNldEludGVudCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFxuXFx0ICAgICAgLy8gbW91c2UgZXZlbnRzXFxuXFx0ICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZXRJbnRlbnQpO1xcblxcblxcdCAgICAgIC8vIHRvdWNoIGV2ZW50c1xcblxcdCAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcXG5cXHQgICAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoQnVmZmVyKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gbW91c2Ugd2hlZWxcXG5cXHQgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKGRldGVjdFdoZWVsKCksIHNldEludGVudCk7XFxuXFxuXFx0ICAgIC8vIGtleWJvYXJkIGV2ZW50c1xcblxcdCAgICBkb2NFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gY2hlY2tzIGNvbmRpdGlvbnMgYmVmb3JlIHVwZGF0aW5nIG5ldyBpbnB1dFxcblxcdCAgdmFyIHVwZGF0ZUlucHV0ID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXG5cXHQgICAgLy8gb25seSBleGVjdXRlIGlmIHRoZSB0b3VjaCBidWZmZXIgdGltZXIgaXNuJ3QgcnVubmluZ1xcblxcdCAgICBpZiAoIWlzQnVmZmVyaW5nKSB7XFxuXFx0ICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQud2hpY2g7XFxuXFx0ICAgICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XFxuXFx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xcblxcblxcdCAgICAgIGlmIChcXG5cXHQgICAgICAgIGN1cnJlbnRJbnB1dCAhPT0gdmFsdWUgfHxcXG5cXHQgICAgICAgIGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlXFxuXFx0ICAgICAgKSB7XFxuXFxuXFx0ICAgICAgICB2YXIgYWN0aXZlSW5wdXQgPSAoXFxuXFx0ICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcXG5cXHQgICAgICAgICAgZm9ybUlucHV0cy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xXFxuXFx0ICAgICAgICApID8gdHJ1ZSA6IGZhbHNlO1xcblxcblxcdCAgICAgICAgaWYgKFxcblxcdCAgICAgICAgICB2YWx1ZSA9PT0gJ3RvdWNoJyB8fFxcblxcblxcdCAgICAgICAgICAvLyBpZ25vcmUgbW91c2UgbW9kaWZpZXIga2V5c1xcblxcdCAgICAgICAgICAodmFsdWUgPT09ICdtb3VzZScgJiYgaWdub3JlTWFwLmluZGV4T2YoZXZlbnRLZXkpID09PSAtMSkgfHxcXG5cXG5cXHQgICAgICAgICAgLy8gZG9uJ3Qgc3dpdGNoIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSBmb3JtIGlucHV0XFxuXFx0ICAgICAgICAgICh2YWx1ZSA9PT0gJ2tleWJvYXJkJyAmJiBhY3RpdmVJbnB1dClcXG5cXHQgICAgICAgICkge1xcblxcblxcdCAgICAgICAgICAvLyBzZXQgdGhlIGN1cnJlbnQgYW5kIGNhdGNoLWFsbCB2YXJpYWJsZVxcblxcdCAgICAgICAgICBjdXJyZW50SW5wdXQgPSBjdXJyZW50SW50ZW50ID0gdmFsdWU7XFxuXFxuXFx0ICAgICAgICAgIHNldElucHV0KCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gdXBkYXRlcyB0aGUgZG9jIGFuZCBgaW5wdXRUeXBlc2AgYXJyYXkgd2l0aCBuZXcgaW5wdXRcXG5cXHQgIHZhciBzZXRJbnB1dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW5wdXQnLCBjdXJyZW50SW5wdXQpO1xcblxcdCAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW50ZW50JywgY3VycmVudElucHV0KTtcXG5cXG5cXHQgICAgaWYgKGlucHV0VHlwZXMuaW5kZXhPZihjdXJyZW50SW5wdXQpID09PSAtMSkge1xcblxcdCAgICAgIGlucHV0VHlwZXMucHVzaChjdXJyZW50SW5wdXQpO1xcblxcdCAgICAgIGRvY0VsZW0uY2xhc3NOYW1lICs9ICcgd2hhdGlucHV0LXR5cGVzLScgKyBjdXJyZW50SW5wdXQ7XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICAvLyB1cGRhdGVzIGlucHV0IGludGVudCBmb3IgYG1vdXNlbW92ZWAgYW5kIGBwb2ludGVybW92ZWBcXG5cXHQgIHZhciBzZXRJbnRlbnQgPSBmdW5jdGlvbihldmVudCkge1xcblxcblxcdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIHRvdWNoIGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXFxuXFx0ICAgIGlmICghaXNCdWZmZXJpbmcpIHtcXG5cXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcXG5cXHQgICAgICBpZiAodmFsdWUgPT09ICdwb2ludGVyJykgdmFsdWUgPSBwb2ludGVyVHlwZShldmVudCk7XFxuXFxuXFx0ICAgICAgaWYgKGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlKSB7XFxuXFx0ICAgICAgICBjdXJyZW50SW50ZW50ID0gdmFsdWU7XFxuXFxuXFx0ICAgICAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW50ZW50JywgY3VycmVudEludGVudCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gYnVmZmVycyB0b3VjaCBldmVudHMgYmVjYXVzZSB0aGV5IGZyZXF1ZW50bHkgYWxzbyBmaXJlIG1vdXNlIGV2ZW50c1xcblxcdCAgdmFyIHRvdWNoQnVmZmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXG5cXHQgICAgLy8gY2xlYXIgdGhlIHRpbWVyIGlmIGl0IGhhcHBlbnMgdG8gYmUgcnVubmluZ1xcblxcdCAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRvdWNoVGltZXIpO1xcblxcblxcdCAgICAvLyBzZXQgdGhlIGN1cnJlbnQgaW5wdXRcXG5cXHQgICAgdXBkYXRlSW5wdXQoZXZlbnQpO1xcblxcblxcdCAgICAvLyBzZXQgdGhlIGlzQnVmZmVyaW5nIHRvIGB0cnVlYFxcblxcdCAgICBpc0J1ZmZlcmluZyA9IHRydWU7XFxuXFxuXFx0ICAgIC8vIHJ1biB0aGUgdGltZXJcXG5cXHQgICAgdG91Y2hUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICAgIC8vIGlmIHRoZSB0aW1lciBydW5zIG91dCwgc2V0IGlzQnVmZmVyaW5nIGJhY2sgdG8gYGZhbHNlYFxcblxcdCAgICAgIGlzQnVmZmVyaW5nID0gZmFsc2U7XFxuXFx0ICAgIH0sIDIwMCk7XFxuXFx0ICB9O1xcblxcblxcblxcdCAgLypcXG5cXHQgICAgLS0tLS0tLS0tLS0tLS0tXFxuXFx0ICAgIFV0aWxpdGllc1xcblxcdCAgICAtLS0tLS0tLS0tLS0tLS1cXG5cXHQgICovXFxuXFxuXFx0ICB2YXIgcG9pbnRlclR5cGUgPSBmdW5jdGlvbihldmVudCkge1xcblxcdCAgIGlmICh0eXBlb2YgZXZlbnQucG9pbnRlclR5cGUgPT09ICdudW1iZXInKSB7XFxuXFx0ICAgICAgcmV0dXJuIHBvaW50ZXJNYXBbZXZlbnQucG9pbnRlclR5cGVdO1xcblxcdCAgIH0gZWxzZSB7XFxuXFx0ICAgICAgcmV0dXJuIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpID8gJ3RvdWNoJyA6IGV2ZW50LnBvaW50ZXJUeXBlOyAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxcblxcdCAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICAvLyBkZXRlY3QgdmVyc2lvbiBvZiBtb3VzZSB3aGVlbCBldmVudCB0byB1c2VcXG5cXHQgIC8vIHZpYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcXG5cXHQgIHZhciBkZXRlY3RXaGVlbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICByZXR1cm4gJ29ud2hlZWwnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpID9cXG5cXHQgICAgICAnd2hlZWwnIDogLy8gTW9kZXJuIGJyb3dzZXJzIHN1cHBvcnQgXFxcIndoZWVsXFxcIlxcblxcblxcdCAgICAgIGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkID9cXG5cXHQgICAgICAgICdtb3VzZXdoZWVsJyA6IC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcXFwibW91c2V3aGVlbFxcXCJcXG5cXHQgICAgICAgICdET01Nb3VzZVNjcm9sbCc7IC8vIGxldCdzIGFzc3VtZSB0aGF0IHJlbWFpbmluZyBicm93c2VycyBhcmUgb2xkZXIgRmlyZWZveFxcblxcdCAgfTtcXG5cXG5cXG5cXHQgIC8qXFxuXFx0ICAgIC0tLS0tLS0tLS0tLS0tLVxcblxcdCAgICBJbml0XFxuXFxuXFx0ICAgIGRvbid0IHN0YXJ0IHNjcmlwdCB1bmxlc3MgYnJvd3NlciBjdXRzIHRoZSBtdXN0YXJkXFxuXFx0ICAgIChhbHNvIHBhc3NlcyBpZiBwb2x5ZmlsbHMgYXJlIHVzZWQpXFxuXFx0ICAgIC0tLS0tLS0tLS0tLS0tLVxcblxcdCAgKi9cXG5cXG5cXHQgIGlmIChcXG5cXHQgICAgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyAmJlxcblxcdCAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxcblxcdCAgKSB7XFxuXFx0ICAgIHNldFVwKCk7XFxuXFx0ICB9XFxuXFxuXFxuXFx0ICAvKlxcblxcdCAgICAtLS0tLS0tLS0tLS0tLS1cXG5cXHQgICAgQVBJXFxuXFx0ICAgIC0tLS0tLS0tLS0tLS0tLVxcblxcdCAgKi9cXG5cXG5cXHQgIHJldHVybiB7XFxuXFxuXFx0ICAgIC8vIHJldHVybnMgc3RyaW5nOiB0aGUgY3VycmVudCBpbnB1dCB0eXBlXFxuXFx0ICAgIC8vIG9wdDogJ2xvb3NlJ3wnc3RyaWN0J1xcblxcdCAgICAvLyAnc3RyaWN0JyAoZGVmYXVsdCk6IHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGBkYXRhLXdoYXRpbnB1dGAgYXR0cmlidXRlXFxuXFx0ICAgIC8vICdsb29zZSc6IGluY2x1ZGVzIGBkYXRhLXdoYXRpbnRlbnRgIHZhbHVlIGlmIGl0J3MgbW9yZSBjdXJyZW50IHRoYW4gYGRhdGEtd2hhdGlucHV0YFxcblxcdCAgICBhc2s6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gKG9wdCA9PT0gJ2xvb3NlJykgPyBjdXJyZW50SW50ZW50IDogY3VycmVudElucHV0OyB9LFxcblxcblxcdCAgICAvLyByZXR1cm5zIGFycmF5OiBhbGwgdGhlIGRldGVjdGVkIGlucHV0IHR5cGVzXFxuXFx0ICAgIHR5cGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIGlucHV0VHlwZXM7IH1cXG5cXG5cXHQgIH07XFxuXFxuXFx0fSgpKTtcXG5cXG5cXG4vKioqLyB9XFxuLyoqKioqKi8gXSlcXG59KTtcXG47XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhL1VzZXJzL3RqZm9nYXJ0eS9Db2RlL2JvaWxlcnBsYXRlLXVsdHJhL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvdGpmb2dhcnR5L0NvZGUvYm9pbGVycGxhdGUtdWx0cmEvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL3RqZm9nYXJ0eS9Db2RlL2JvaWxlcnBsYXRlLXVsdHJhL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiISEvVXNlcnMvdGpmb2dhcnR5L0NvZGUvYm9pbGVycGxhdGUtdWx0cmEvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy90amZvZ2FydHkvQ29kZS9ib2lsZXJwbGF0ZS11bHRyYS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvdGpmb2dhcnR5L0NvZGUvYm9pbGVycGxhdGUtdWx0cmEvbm9kZV9tb2R1bGVzL3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi93aGF0LWlucHV0L2Rpc3Qvd2hhdC1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9